
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

80040000 <__start>:

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
80040000:	00000297          	auipc	t0,0x0
80040004:	01428293          	addi	t0,t0,20 # 80040014 <__irq_wrapper>
	csrw mtvec, t0
80040008:	30529073          	csrw	mtvec,t0

	/* Jump to __initialize */
	tail __initialize
8004000c:	ad85                	j	8004067c <__initialize>
	...

Disassembly of section reset:

80040010 <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
80040010:	25b5                	jal	8004067c <__initialize>
	...

Disassembly of section exceptions:

80040014 <__irq_wrapper>:
 * In this architecture, system call (ECALL) is used to perform context
 * switching or IRQ offloading (when enabled).
 */
SECTION_FUNC(exception.entry, __irq_wrapper)
	/* Allocate space on thread stack to save registers */
	addi sp, sp, -__NANO_ESF_SIZEOF
80040014:	715d                	addi	sp,sp,-80
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	sw ra, __NANO_ESF_ra_OFFSET(sp)
80040016:	c006                	sw	ra,0(sp)
	sw gp, __NANO_ESF_gp_OFFSET(sp)
80040018:	c20e                	sw	gp,4(sp)
	sw tp, __NANO_ESF_tp_OFFSET(sp)
8004001a:	c412                	sw	tp,8(sp)
	sw t0, __NANO_ESF_t0_OFFSET(sp)
8004001c:	c616                	sw	t0,12(sp)
	sw t1, __NANO_ESF_t1_OFFSET(sp)
8004001e:	c81a                	sw	t1,16(sp)
	sw t2, __NANO_ESF_t2_OFFSET(sp)
80040020:	ca1e                	sw	t2,20(sp)
	sw t3, __NANO_ESF_t3_OFFSET(sp)
80040022:	cc72                	sw	t3,24(sp)
	sw t4, __NANO_ESF_t4_OFFSET(sp)
80040024:	ce76                	sw	t4,28(sp)
	sw t5, __NANO_ESF_t5_OFFSET(sp)
80040026:	d07a                	sw	t5,32(sp)
	sw t6, __NANO_ESF_t6_OFFSET(sp)
80040028:	d27e                	sw	t6,36(sp)
	sw a0, __NANO_ESF_a0_OFFSET(sp)
8004002a:	d42a                	sw	a0,40(sp)
	sw a1, __NANO_ESF_a1_OFFSET(sp)
8004002c:	d62e                	sw	a1,44(sp)
	sw a2, __NANO_ESF_a2_OFFSET(sp)
8004002e:	d832                	sw	a2,48(sp)
	sw a3, __NANO_ESF_a3_OFFSET(sp)
80040030:	da36                	sw	a3,52(sp)
	sw a4, __NANO_ESF_a4_OFFSET(sp)
80040032:	dc3a                	sw	a4,56(sp)
	sw a5, __NANO_ESF_a5_OFFSET(sp)
80040034:	de3e                	sw	a5,60(sp)
	sw a6, __NANO_ESF_a6_OFFSET(sp)
80040036:	c0c2                	sw	a6,64(sp)
	sw a7, __NANO_ESF_a7_OFFSET(sp)
80040038:	c2c6                	sw	a7,68(sp)

	/* Save MEPC register */
	csrr t0, mepc
8004003a:	341022f3          	csrr	t0,mepc
	sw t0, __NANO_ESF_mepc_OFFSET(sp)
8004003e:	c496                	sw	t0,72(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, SOC_MSTATUS_REG
80040040:	300022f3          	csrr	t0,mstatus
	sw t0, __NANO_ESF_mstatus_OFFSET(sp)
80040044:	c696                	sw	t0,76(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
80040046:	1ae000ef          	jal	ra,800401f4 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
8004004a:	00000313          	li	t1,0
	bnez a0, is_interrupt
8004004e:	e905                	bnez	a0,8004007e <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
80040050:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
80040054:	800003b7          	lui	t2,0x80000
80040058:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
8004005c:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
80040060:	432d                	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call,
	 * otherwise handle fault
	 */
	beq t0, t1, is_syscall
80040062:	00628a63          	beq	t0,t1,80040076 <is_syscall>
	 * Stack pointer is pointing to a NANO_ESF structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to no_reschedule
	 * to restore stack.
	 */
	addi a0, sp, 0
80040066:	00010513          	mv	a0,sp
	la ra, no_reschedule
8004006a:	00000097          	auipc	ra,0x0
8004006e:	11e08093          	addi	ra,ra,286 # 80040188 <no_reschedule>
	tail _Fault
80040072:	1af0006f          	j	80040a20 <_Fault>

80040076 <is_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	lw t0, __NANO_ESF_mepc_OFFSET(sp)
80040076:	42a6                	lw	t0,72(sp)
	addi t0, t0, 4
80040078:	0291                	addi	t0,t0,4
	sw t0, __NANO_ESF_mepc_OFFSET(sp)
8004007a:	c496                	sw	t0,72(sp)
#endif

	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
8004007c:	a041                	j	800400fc <reschedule>

8004007e <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
8004007e:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
80040082:	00005397          	auipc	t2,0x5
80040086:	16638393          	addi	t2,t2,358 # 800451e8 <_kernel>
	lw sp, _kernel_offset_to_irq_stack(t2)
8004008a:	0043a103          	lw	sp,4(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
8004008e:	1141                	addi	sp,sp,-16
	sw t0, 0x00(sp)
80040090:	c016                	sw	t0,0(sp)

80040092 <on_irq_stack>:

on_irq_stack:
	/* Increment _kernel.nested variable */
	lw t3, _kernel_offset_to_nested(t2)
80040092:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
80040096:	0e05                	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
80040098:	01c3a023          	sw	t3,0(t2)

	/*
	 * If we are here due to a system call, t1 register should != 0.
	 * In this case, perform IRQ offloading, otherwise jump to call_irq
	 */
	beqz t1, call_irq
8004009c:	00030863          	beqz	t1,800400ac <call_irq>
	/*
	 * Call z_irq_do_offload to handle IRQ offloading.
	 * Set return address to on_thread_stack in order to jump there
	 * upon returning from z_irq_do_offload
	 */
	la ra, on_thread_stack
800400a0:	00000097          	auipc	ra,0x0
800400a4:	03808093          	addi	ra,ra,56 # 800400d8 <on_thread_stack>
	tail z_irq_do_offload
800400a8:	1df0006f          	j	80040a86 <z_irq_do_offload>

800400ac <call_irq>:
#ifdef CONFIG_TRACING
	call z_sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
800400ac:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
800400b0:	800002b7          	lui	t0,0x80000
800400b4:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
800400b8:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
800400bc:	128000ef          	jal	ra,800401e4 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 8-bytes wide, we should shift index by 3)
	 */
	la t0, _sw_isr_table
800400c0:	00004297          	auipc	t0,0x4
800400c4:	00028293          	mv	t0,t0
	slli a0, a0, 3
800400c8:	050e                	slli	a0,a0,0x3
	add t0, t0, a0
800400ca:	92aa                	add	t0,t0,a0

	/* Load argument in a0 register */
	lw a0, 0x00(t0)
800400cc:	0002a503          	lw	a0,0(t0) # 800440c0 <_image_text_end>

	/* Load ISR function address in register t1 */
	lw t1, 0x04(t0)
800400d0:	0042a303          	lw	t1,4(t0)
	lw t1, 0x04(sp)
	lw a0, 0x00(sp)
	addi sp, sp, 16
#endif
	/* Call ISR function */
	jalr ra, t1
800400d4:	000300e7          	jalr	t1

800400d8 <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
800400d8:	00005317          	auipc	t1,0x5
800400dc:	11030313          	addi	t1,t1,272 # 800451e8 <_kernel>

	/* Decrement _kernel.nested variable */
	lw t2, _kernel_offset_to_nested(t1)
800400e0:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
800400e4:	13fd                	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
800400e6:	00732023          	sw	t2,0(t1)

	/* Restore thread stack pointer */
	lw t0, 0x00(sp)
800400ea:	4282                	lw	t0,0(sp)
	addi sp, t0, 0
800400ec:	00028113          	mv	sp,t0
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	lw t2, _kernel_offset_to_current(t1)
800400f0:	00832383          	lw	t2,8(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	lw t3, _kernel_offset_to_ready_q_cache(t1)
800400f4:	02032e03          	lw	t3,32(t1)
	beq t3, t2, no_reschedule
800400f8:	087e0863          	beq	t3,t2,80040188 <no_reschedule>

800400fc <reschedule>:
reschedule:
#if CONFIG_TRACING
	call z_sys_trace_thread_switched_in
#endif
	/* Get reference to _kernel */
	la t0, _kernel
800400fc:	00005297          	auipc	t0,0x5
80040100:	0ec28293          	addi	t0,t0,236 # 800451e8 <_kernel>

	/* Get pointer to _kernel.current */
	lw t1, _kernel_offset_to_current(t0)
80040104:	0082a303          	lw	t1,8(t0)

	/*
	 * Save callee-saved registers of current thread
	 * prior to handle context-switching
	 */
	sw s0, _thread_offset_to_s0(t1)
80040108:	02832623          	sw	s0,44(t1)
	sw s1, _thread_offset_to_s1(t1)
8004010c:	02932823          	sw	s1,48(t1)
	sw s2, _thread_offset_to_s2(t1)
80040110:	03232a23          	sw	s2,52(t1)
	sw s3, _thread_offset_to_s3(t1)
80040114:	03332c23          	sw	s3,56(t1)
	sw s4, _thread_offset_to_s4(t1)
80040118:	03432e23          	sw	s4,60(t1)
	sw s5, _thread_offset_to_s5(t1)
8004011c:	05532023          	sw	s5,64(t1)
	sw s6, _thread_offset_to_s6(t1)
80040120:	05632223          	sw	s6,68(t1)
	sw s7, _thread_offset_to_s7(t1)
80040124:	05732423          	sw	s7,72(t1)
	sw s8, _thread_offset_to_s8(t1)
80040128:	05832623          	sw	s8,76(t1)
	sw s9, _thread_offset_to_s9(t1)
8004012c:	05932823          	sw	s9,80(t1)
	sw s10, _thread_offset_to_s10(t1)
80040130:	05a32a23          	sw	s10,84(t1)
	sw s11, _thread_offset_to_s11(t1)
80040134:	05b32c23          	sw	s11,88(t1)

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	sw sp, _thread_offset_to_sp(t1)
80040138:	02232423          	sw	sp,40(t1)
	la t2, _k_neg_eagain
8004013c:	00005397          	auipc	t2,0x5
80040140:	c2438393          	addi	t2,t2,-988 # 80044d60 <_k_neg_eagain>
	lw t3, 0x00(t2)
80040144:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
80040148:	07c32623          	sw	t3,108(t1)

	/* Get next thread to schedule. */
	lw t1, _kernel_offset_to_ready_q_cache(t0)
8004014c:	0202a303          	lw	t1,32(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	sw t1, _kernel_offset_to_current(t0)
80040150:	0062a423          	sw	t1,8(t0)

	/* Switch to new thread stack */
	lw sp, _thread_offset_to_sp(t1)
80040154:	02832103          	lw	sp,40(t1)

	/* Restore callee-saved registers of new thread */
	lw s0, _thread_offset_to_s0(t1)
80040158:	02c32403          	lw	s0,44(t1)
	lw s1, _thread_offset_to_s1(t1)
8004015c:	03032483          	lw	s1,48(t1)
	lw s2, _thread_offset_to_s2(t1)
80040160:	03432903          	lw	s2,52(t1)
	lw s3, _thread_offset_to_s3(t1)
80040164:	03832983          	lw	s3,56(t1)
	lw s4, _thread_offset_to_s4(t1)
80040168:	03c32a03          	lw	s4,60(t1)
	lw s5, _thread_offset_to_s5(t1)
8004016c:	04032a83          	lw	s5,64(t1)
	lw s6, _thread_offset_to_s6(t1)
80040170:	04432b03          	lw	s6,68(t1)
	lw s7, _thread_offset_to_s7(t1)
80040174:	04832b83          	lw	s7,72(t1)
	lw s8, _thread_offset_to_s8(t1)
80040178:	04c32c03          	lw	s8,76(t1)
	lw s9, _thread_offset_to_s9(t1)
8004017c:	05032c83          	lw	s9,80(t1)
	lw s10, _thread_offset_to_s10(t1)
80040180:	05432d03          	lw	s10,84(t1)
	lw s11, _thread_offset_to_s11(t1)
80040184:	05832d83          	lw	s11,88(t1)

80040188 <no_reschedule>:
	addi a0, sp, __NANO_ESF_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	lw t0, __NANO_ESF_mepc_OFFSET(sp)
80040188:	42a6                	lw	t0,72(sp)
	csrw mepc, t0
8004018a:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	lw t0, __NANO_ESF_mstatus_OFFSET(sp)
8004018e:	42b6                	lw	t0,76(sp)
	csrw SOC_MSTATUS_REG, t0
80040190:	30029073          	csrw	mstatus,t0

	/* Restore caller-saved registers from thread stack */
	lw ra, __NANO_ESF_ra_OFFSET(sp)
80040194:	4082                	lw	ra,0(sp)
	lw gp, __NANO_ESF_gp_OFFSET(sp)
80040196:	4192                	lw	gp,4(sp)
	lw tp, __NANO_ESF_tp_OFFSET(sp)
80040198:	4222                	lw	tp,8(sp)
	lw t0, __NANO_ESF_t0_OFFSET(sp)
8004019a:	42b2                	lw	t0,12(sp)
	lw t1, __NANO_ESF_t1_OFFSET(sp)
8004019c:	4342                	lw	t1,16(sp)
	lw t2, __NANO_ESF_t2_OFFSET(sp)
8004019e:	43d2                	lw	t2,20(sp)
	lw t3, __NANO_ESF_t3_OFFSET(sp)
800401a0:	4e62                	lw	t3,24(sp)
	lw t4, __NANO_ESF_t4_OFFSET(sp)
800401a2:	4ef2                	lw	t4,28(sp)
	lw t5, __NANO_ESF_t5_OFFSET(sp)
800401a4:	5f02                	lw	t5,32(sp)
	lw t6, __NANO_ESF_t6_OFFSET(sp)
800401a6:	5f92                	lw	t6,36(sp)
	lw a0, __NANO_ESF_a0_OFFSET(sp)
800401a8:	5522                	lw	a0,40(sp)
	lw a1, __NANO_ESF_a1_OFFSET(sp)
800401aa:	55b2                	lw	a1,44(sp)
	lw a2, __NANO_ESF_a2_OFFSET(sp)
800401ac:	5642                	lw	a2,48(sp)
	lw a3, __NANO_ESF_a3_OFFSET(sp)
800401ae:	56d2                	lw	a3,52(sp)
	lw a4, __NANO_ESF_a4_OFFSET(sp)
800401b0:	5762                	lw	a4,56(sp)
	lw a5, __NANO_ESF_a5_OFFSET(sp)
800401b2:	57f2                	lw	a5,60(sp)
	lw a6, __NANO_ESF_a6_OFFSET(sp)
800401b4:	4806                	lw	a6,64(sp)
	lw a7, __NANO_ESF_a7_OFFSET(sp)
800401b6:	4896                	lw	a7,68(sp)

	/* Release stack space */
	addi sp, sp, __NANO_ESF_SIZEOF
800401b8:	6161                	addi	sp,sp,80

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
800401ba:	30200073          	mret
	...

800401c0 <__swap>:
	lw a7, __NANO_ESF_a7_OFFSET(sp)

	/* Release stack space */
	addi sp, sp, __NANO_ESF_SIZEOF
#endif
	ecall
800401c0:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * __swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called z_set_thread_return_value(..).
	 */
	la t0, _kernel
800401c4:	00005297          	auipc	t0,0x5
800401c8:	02428293          	addi	t0,t0,36 # 800451e8 <_kernel>

	/* Get pointer to _kernel.current */
	lw t1, _kernel_offset_to_current(t0)
800401cc:	0082a303          	lw	t1,8(t0)

	/* Load return value of __swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
800401d0:	06c32383          	lw	t2,108(t1)

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, SOC_MSTATUS_IEN
800401d4:	8921                	andi	a0,a0,8
	csrrs t0, mstatus, a0
800401d6:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
800401da:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
800401de:	00008067          	ret
	...

800401e4 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
800401e4:	4305                	li	t1,1
	sll t0, t1, a0
800401e6:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
800401ea:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
800401ee:	00008067          	ret
	...

800401f4 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
800401f4:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
800401f8:	80000337          	lui	t1,0x80000
	and t0, t0, t1
800401fc:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
80040200:	00000513          	li	a0,0
	beqz t0, not_interrupt
80040204:	00028363          	beqz	t0,8004020a <not_interrupt>
	addi a0, a0, 1
80040208:	0505                	addi	a0,a0,1

8004020a <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
8004020a:	00008067          	ret

Disassembly of section text:

80040210 <__lshrdi3>:
80040210:	02060063          	beqz	a2,80040230 <__lshrdi3+0x20>
80040214:	02000793          	li	a5,32
80040218:	40c787b3          	sub	a5,a5,a2
8004021c:	00f04c63          	bgtz	a5,80040234 <__lshrdi3+0x24>
80040220:	fe060513          	addi	a0,a2,-32
80040224:	00000713          	li	a4,0
80040228:	00a5d533          	srl	a0,a1,a0
8004022c:	00070593          	mv	a1,a4
80040230:	00008067          	ret
80040234:	00c5d733          	srl	a4,a1,a2
80040238:	00c55533          	srl	a0,a0,a2
8004023c:	00f595b3          	sll	a1,a1,a5
80040240:	00b56533          	or	a0,a0,a1
80040244:	fe9ff06f          	j	8004022c <__lshrdi3+0x1c>

80040248 <__udivdi3>:
80040248:	00058793          	mv	a5,a1
8004024c:	00060813          	mv	a6,a2
80040250:	00068713          	mv	a4,a3
80040254:	00050313          	mv	t1,a0
80040258:	28069663          	bnez	a3,800404e4 <__udivdi3+0x29c>
8004025c:	800448b7          	lui	a7,0x80044
80040260:	1f088893          	addi	a7,a7,496 # 800441f0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800441f1>
80040264:	0ec5f663          	bgeu	a1,a2,80040350 <__udivdi3+0x108>
80040268:	00010737          	lui	a4,0x10
8004026c:	0ce67863          	bgeu	a2,a4,8004033c <__udivdi3+0xf4>
80040270:	0ff00693          	li	a3,255
80040274:	00c6b6b3          	sltu	a3,a3,a2
80040278:	00369693          	slli	a3,a3,0x3
8004027c:	00d65733          	srl	a4,a2,a3
80040280:	00e888b3          	add	a7,a7,a4
80040284:	0008c703          	lbu	a4,0(a7)
80040288:	00d706b3          	add	a3,a4,a3
8004028c:	02000713          	li	a4,32
80040290:	40d70733          	sub	a4,a4,a3
80040294:	00070c63          	beqz	a4,800402ac <__udivdi3+0x64>
80040298:	00e797b3          	sll	a5,a5,a4
8004029c:	00d556b3          	srl	a3,a0,a3
800402a0:	00e61833          	sll	a6,a2,a4
800402a4:	00f6e5b3          	or	a1,a3,a5
800402a8:	00e51333          	sll	t1,a0,a4
800402ac:	01085513          	srli	a0,a6,0x10
800402b0:	02a5f733          	remu	a4,a1,a0
800402b4:	01081613          	slli	a2,a6,0x10
800402b8:	01065613          	srli	a2,a2,0x10
800402bc:	01035693          	srli	a3,t1,0x10
800402c0:	02a5d5b3          	divu	a1,a1,a0
800402c4:	01071713          	slli	a4,a4,0x10
800402c8:	00d766b3          	or	a3,a4,a3
800402cc:	02b607b3          	mul	a5,a2,a1
800402d0:	00058713          	mv	a4,a1
800402d4:	00f6fe63          	bgeu	a3,a5,800402f0 <__udivdi3+0xa8>
800402d8:	010686b3          	add	a3,a3,a6
800402dc:	fff58713          	addi	a4,a1,-1
800402e0:	0106e863          	bltu	a3,a6,800402f0 <__udivdi3+0xa8>
800402e4:	00f6f663          	bgeu	a3,a5,800402f0 <__udivdi3+0xa8>
800402e8:	ffe58713          	addi	a4,a1,-2
800402ec:	010686b3          	add	a3,a3,a6
800402f0:	40f686b3          	sub	a3,a3,a5
800402f4:	02a6f7b3          	remu	a5,a3,a0
800402f8:	01031313          	slli	t1,t1,0x10
800402fc:	01035313          	srli	t1,t1,0x10
80040300:	02a6d6b3          	divu	a3,a3,a0
80040304:	01079793          	slli	a5,a5,0x10
80040308:	0067e333          	or	t1,a5,t1
8004030c:	02d605b3          	mul	a1,a2,a3
80040310:	00068513          	mv	a0,a3
80040314:	00b37c63          	bgeu	t1,a1,8004032c <__udivdi3+0xe4>
80040318:	00680333          	add	t1,a6,t1
8004031c:	fff68513          	addi	a0,a3,-1
80040320:	01036663          	bltu	t1,a6,8004032c <__udivdi3+0xe4>
80040324:	00b37463          	bgeu	t1,a1,8004032c <__udivdi3+0xe4>
80040328:	ffe68513          	addi	a0,a3,-2
8004032c:	01071713          	slli	a4,a4,0x10
80040330:	00a76733          	or	a4,a4,a0
80040334:	00000593          	li	a1,0
80040338:	0e40006f          	j	8004041c <__udivdi3+0x1d4>
8004033c:	01000737          	lui	a4,0x1000
80040340:	01000693          	li	a3,16
80040344:	f2e66ce3          	bltu	a2,a4,8004027c <__udivdi3+0x34>
80040348:	01800693          	li	a3,24
8004034c:	f31ff06f          	j	8004027c <__udivdi3+0x34>
80040350:	00061663          	bnez	a2,8004035c <__udivdi3+0x114>
80040354:	00100693          	li	a3,1
80040358:	02c6d833          	divu	a6,a3,a2
8004035c:	000106b7          	lui	a3,0x10
80040360:	0cd87263          	bgeu	a6,a3,80040424 <__udivdi3+0x1dc>
80040364:	0ff00693          	li	a3,255
80040368:	0106f463          	bgeu	a3,a6,80040370 <__udivdi3+0x128>
8004036c:	00800713          	li	a4,8
80040370:	00e856b3          	srl	a3,a6,a4
80040374:	00d888b3          	add	a7,a7,a3
80040378:	0008c683          	lbu	a3,0(a7)
8004037c:	00e686b3          	add	a3,a3,a4
80040380:	02000713          	li	a4,32
80040384:	40d70733          	sub	a4,a4,a3
80040388:	0a071863          	bnez	a4,80040438 <__udivdi3+0x1f0>
8004038c:	410787b3          	sub	a5,a5,a6
80040390:	00100593          	li	a1,1
80040394:	01085613          	srli	a2,a6,0x10
80040398:	01081893          	slli	a7,a6,0x10
8004039c:	0108d893          	srli	a7,a7,0x10
800403a0:	01035693          	srli	a3,t1,0x10
800403a4:	02c7f733          	remu	a4,a5,a2
800403a8:	02c7d7b3          	divu	a5,a5,a2
800403ac:	01071713          	slli	a4,a4,0x10
800403b0:	00d766b3          	or	a3,a4,a3
800403b4:	02f88533          	mul	a0,a7,a5
800403b8:	00078713          	mv	a4,a5
800403bc:	00a6fe63          	bgeu	a3,a0,800403d8 <__udivdi3+0x190>
800403c0:	010686b3          	add	a3,a3,a6
800403c4:	fff78713          	addi	a4,a5,-1
800403c8:	0106e863          	bltu	a3,a6,800403d8 <__udivdi3+0x190>
800403cc:	00a6f663          	bgeu	a3,a0,800403d8 <__udivdi3+0x190>
800403d0:	ffe78713          	addi	a4,a5,-2
800403d4:	010686b3          	add	a3,a3,a6
800403d8:	40a686b3          	sub	a3,a3,a0
800403dc:	02c6f7b3          	remu	a5,a3,a2
800403e0:	01031313          	slli	t1,t1,0x10
800403e4:	01035313          	srli	t1,t1,0x10
800403e8:	02c6d6b3          	divu	a3,a3,a2
800403ec:	01079793          	slli	a5,a5,0x10
800403f0:	0067e333          	or	t1,a5,t1
800403f4:	02d888b3          	mul	a7,a7,a3
800403f8:	00068513          	mv	a0,a3
800403fc:	01137c63          	bgeu	t1,a7,80040414 <__udivdi3+0x1cc>
80040400:	00680333          	add	t1,a6,t1
80040404:	fff68513          	addi	a0,a3,-1 # ffff <CONFIG_ISR_STACK_SIZE+0xf7ff>
80040408:	01036663          	bltu	t1,a6,80040414 <__udivdi3+0x1cc>
8004040c:	01137463          	bgeu	t1,a7,80040414 <__udivdi3+0x1cc>
80040410:	ffe68513          	addi	a0,a3,-2
80040414:	01071713          	slli	a4,a4,0x10
80040418:	00a76733          	or	a4,a4,a0
8004041c:	00070513          	mv	a0,a4
80040420:	00008067          	ret
80040424:	010006b7          	lui	a3,0x1000
80040428:	01000713          	li	a4,16
8004042c:	f4d862e3          	bltu	a6,a3,80040370 <__udivdi3+0x128>
80040430:	01800713          	li	a4,24
80040434:	f3dff06f          	j	80040370 <__udivdi3+0x128>
80040438:	00e81833          	sll	a6,a6,a4
8004043c:	00d7d5b3          	srl	a1,a5,a3
80040440:	00e51333          	sll	t1,a0,a4
80040444:	00d556b3          	srl	a3,a0,a3
80040448:	01085513          	srli	a0,a6,0x10
8004044c:	00e797b3          	sll	a5,a5,a4
80040450:	02a5f733          	remu	a4,a1,a0
80040454:	00f6e8b3          	or	a7,a3,a5
80040458:	01081793          	slli	a5,a6,0x10
8004045c:	0107d793          	srli	a5,a5,0x10
80040460:	0108d613          	srli	a2,a7,0x10
80040464:	02a5d5b3          	divu	a1,a1,a0
80040468:	01071713          	slli	a4,a4,0x10
8004046c:	00c76733          	or	a4,a4,a2
80040470:	02b786b3          	mul	a3,a5,a1
80040474:	00058613          	mv	a2,a1
80040478:	00d77e63          	bgeu	a4,a3,80040494 <__udivdi3+0x24c>
8004047c:	01070733          	add	a4,a4,a6
80040480:	fff58613          	addi	a2,a1,-1
80040484:	01076863          	bltu	a4,a6,80040494 <__udivdi3+0x24c>
80040488:	00d77663          	bgeu	a4,a3,80040494 <__udivdi3+0x24c>
8004048c:	ffe58613          	addi	a2,a1,-2
80040490:	01070733          	add	a4,a4,a6
80040494:	40d706b3          	sub	a3,a4,a3
80040498:	02a6f733          	remu	a4,a3,a0
8004049c:	01089893          	slli	a7,a7,0x10
800404a0:	0108d893          	srli	a7,a7,0x10
800404a4:	02a6d6b3          	divu	a3,a3,a0
800404a8:	01071713          	slli	a4,a4,0x10
800404ac:	02d785b3          	mul	a1,a5,a3
800404b0:	011767b3          	or	a5,a4,a7
800404b4:	00068713          	mv	a4,a3
800404b8:	00b7fe63          	bgeu	a5,a1,800404d4 <__udivdi3+0x28c>
800404bc:	010787b3          	add	a5,a5,a6
800404c0:	fff68713          	addi	a4,a3,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xf0bdbf>
800404c4:	0107e863          	bltu	a5,a6,800404d4 <__udivdi3+0x28c>
800404c8:	00b7f663          	bgeu	a5,a1,800404d4 <__udivdi3+0x28c>
800404cc:	ffe68713          	addi	a4,a3,-2
800404d0:	010787b3          	add	a5,a5,a6
800404d4:	40b787b3          	sub	a5,a5,a1
800404d8:	01061593          	slli	a1,a2,0x10
800404dc:	00e5e5b3          	or	a1,a1,a4
800404e0:	eb5ff06f          	j	80040394 <__udivdi3+0x14c>
800404e4:	18d5e663          	bltu	a1,a3,80040670 <__udivdi3+0x428>
800404e8:	00010737          	lui	a4,0x10
800404ec:	04e6f463          	bgeu	a3,a4,80040534 <__udivdi3+0x2ec>
800404f0:	0ff00813          	li	a6,255
800404f4:	00d835b3          	sltu	a1,a6,a3
800404f8:	00359593          	slli	a1,a1,0x3
800404fc:	80044737          	lui	a4,0x80044
80040500:	00b6d833          	srl	a6,a3,a1
80040504:	1f070713          	addi	a4,a4,496 # 800441f0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800441f1>
80040508:	01070733          	add	a4,a4,a6
8004050c:	00074803          	lbu	a6,0(a4)
80040510:	00b80833          	add	a6,a6,a1
80040514:	02000593          	li	a1,32
80040518:	410585b3          	sub	a1,a1,a6
8004051c:	02059663          	bnez	a1,80040548 <__udivdi3+0x300>
80040520:	00100713          	li	a4,1
80040524:	eef6ece3          	bltu	a3,a5,8004041c <__udivdi3+0x1d4>
80040528:	00c53633          	sltu	a2,a0,a2
8004052c:	00164713          	xori	a4,a2,1
80040530:	eedff06f          	j	8004041c <__udivdi3+0x1d4>
80040534:	01000737          	lui	a4,0x1000
80040538:	01000593          	li	a1,16
8004053c:	fce6e0e3          	bltu	a3,a4,800404fc <__udivdi3+0x2b4>
80040540:	01800593          	li	a1,24
80040544:	fb9ff06f          	j	800404fc <__udivdi3+0x2b4>
80040548:	01065733          	srl	a4,a2,a6
8004054c:	00b696b3          	sll	a3,a3,a1
80040550:	00d766b3          	or	a3,a4,a3
80040554:	0106de93          	srli	t4,a3,0x10
80040558:	0107d733          	srl	a4,a5,a6
8004055c:	03d778b3          	remu	a7,a4,t4
80040560:	00b797b3          	sll	a5,a5,a1
80040564:	01055833          	srl	a6,a0,a6
80040568:	00f86333          	or	t1,a6,a5
8004056c:	01069793          	slli	a5,a3,0x10
80040570:	0107d793          	srli	a5,a5,0x10
80040574:	01035813          	srli	a6,t1,0x10
80040578:	00b61633          	sll	a2,a2,a1
8004057c:	03d75733          	divu	a4,a4,t4
80040580:	01089893          	slli	a7,a7,0x10
80040584:	0108e833          	or	a6,a7,a6
80040588:	02e78f33          	mul	t5,a5,a4
8004058c:	00070e13          	mv	t3,a4
80040590:	01e87e63          	bgeu	a6,t5,800405ac <__udivdi3+0x364>
80040594:	00d80833          	add	a6,a6,a3
80040598:	fff70e13          	addi	t3,a4,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xf0bdbf>
8004059c:	00d86863          	bltu	a6,a3,800405ac <__udivdi3+0x364>
800405a0:	01e87663          	bgeu	a6,t5,800405ac <__udivdi3+0x364>
800405a4:	ffe70e13          	addi	t3,a4,-2
800405a8:	00d80833          	add	a6,a6,a3
800405ac:	41e80833          	sub	a6,a6,t5
800405b0:	03d878b3          	remu	a7,a6,t4
800405b4:	03d85833          	divu	a6,a6,t4
800405b8:	01089893          	slli	a7,a7,0x10
800405bc:	03078eb3          	mul	t4,a5,a6
800405c0:	01031793          	slli	a5,t1,0x10
800405c4:	0107d793          	srli	a5,a5,0x10
800405c8:	00f8e7b3          	or	a5,a7,a5
800405cc:	00080713          	mv	a4,a6
800405d0:	01d7fe63          	bgeu	a5,t4,800405ec <__udivdi3+0x3a4>
800405d4:	00d787b3          	add	a5,a5,a3
800405d8:	fff80713          	addi	a4,a6,-1
800405dc:	00d7e863          	bltu	a5,a3,800405ec <__udivdi3+0x3a4>
800405e0:	01d7f663          	bgeu	a5,t4,800405ec <__udivdi3+0x3a4>
800405e4:	ffe80713          	addi	a4,a6,-2
800405e8:	00d787b3          	add	a5,a5,a3
800405ec:	010e1e13          	slli	t3,t3,0x10
800405f0:	41d787b3          	sub	a5,a5,t4
800405f4:	00010eb7          	lui	t4,0x10
800405f8:	00ee6733          	or	a4,t3,a4
800405fc:	fffe8813          	addi	a6,t4,-1 # ffff <CONFIG_ISR_STACK_SIZE+0xf7ff>
80040600:	01077333          	and	t1,a4,a6
80040604:	01075893          	srli	a7,a4,0x10
80040608:	01067833          	and	a6,a2,a6
8004060c:	01065613          	srli	a2,a2,0x10
80040610:	03030e33          	mul	t3,t1,a6
80040614:	03088833          	mul	a6,a7,a6
80040618:	010e5693          	srli	a3,t3,0x10
8004061c:	02c30333          	mul	t1,t1,a2
80040620:	01030333          	add	t1,t1,a6
80040624:	006686b3          	add	a3,a3,t1
80040628:	02c888b3          	mul	a7,a7,a2
8004062c:	0106f463          	bgeu	a3,a6,80040634 <__udivdi3+0x3ec>
80040630:	01d888b3          	add	a7,a7,t4
80040634:	0106d613          	srli	a2,a3,0x10
80040638:	011608b3          	add	a7,a2,a7
8004063c:	0317e663          	bltu	a5,a7,80040668 <__udivdi3+0x420>
80040640:	cf179ae3          	bne	a5,a7,80040334 <__udivdi3+0xec>
80040644:	000107b7          	lui	a5,0x10
80040648:	fff78793          	addi	a5,a5,-1 # ffff <CONFIG_ISR_STACK_SIZE+0xf7ff>
8004064c:	00f6f6b3          	and	a3,a3,a5
80040650:	01069693          	slli	a3,a3,0x10
80040654:	00fe7e33          	and	t3,t3,a5
80040658:	00b51533          	sll	a0,a0,a1
8004065c:	01c686b3          	add	a3,a3,t3
80040660:	00000593          	li	a1,0
80040664:	dad57ce3          	bgeu	a0,a3,8004041c <__udivdi3+0x1d4>
80040668:	fff70713          	addi	a4,a4,-1
8004066c:	cc9ff06f          	j	80040334 <__udivdi3+0xec>
80040670:	00000593          	li	a1,0
80040674:	00000713          	li	a4,0
80040678:	da5ff06f          	j	8004041c <__udivdi3+0x1d4>

8004067c <__initialize>:

	/*
	 * Initially, setup stack pointer to
	 * _interrupt_stack + CONFIG_ISR_STACK_SIZE
	 */
	la sp, _interrupt_stack
8004067c:	00006117          	auipc	sp,0x6
80040680:	3a410113          	addi	sp,sp,932 # 80046a20 <_interrupt_stack>
	li t0, CONFIG_ISR_STACK_SIZE
80040684:	000012b7          	lui	t0,0x1
80040688:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
8004068c:	9116                	add	sp,sp,t0

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
8004068e:	2921                	jal	80040aa6 <_PrepC>

80040690 <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
80040690:	4490006f          	j	800412d8 <z_thread_entry>
	...

80040696 <print_phil_state>:
#endif
}

#include <stdarg.h>
static void print_phil_state(int id, const char *fmt, s32_t delay)
{
80040696:	1101                	addi	sp,sp,-32
80040698:	ce06                	sw	ra,28(sp)
8004069a:	cc22                	sw	s0,24(sp)
8004069c:	ca26                	sw	s1,20(sp)
8004069e:	8432                	mv	s0,a2
800406a0:	84ae                	mv	s1,a1
800406a2:	c84a                	sw	s2,16(sp)
800406a4:	892a                	mv	s2,a0

K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)

K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
800406a6:	62b020ef          	jal	ra,800434d0 <z_impl_k_current_get>

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)

K_SYSCALL_DECLARE1(K_SYSCALL_K_THREAD_PRIORITY_GET, k_thread_priority_get, int, k_tid_t, thread)
800406aa:	357020ef          	jal	ra,80043200 <z_impl_k_thread_priority_get>
800406ae:	c62a                	sw	a0,12(sp)
	printk("\x1b[%d;%dH", id + 1, 1);
800406b0:	80044537          	lui	a0,0x80044
800406b4:	4605                	li	a2,1
800406b6:	00190593          	addi	a1,s2,1
800406ba:	4e050513          	addi	a0,a0,1248 # 800444e0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800444e1>
800406be:	058010ef          	jal	ra,80041716 <printk>
	int prio = k_thread_priority_get(k_current_get());

	set_phil_state_pos(id);

	printk("Philosopher %d [%s:%s%d] ",
800406c2:	4732                	lw	a4,12(sp)
800406c4:	04074963          	bltz	a4,80040716 <print_phil_state+0x80>
800406c8:	80044637          	lui	a2,0x80044
800406cc:	800446b7          	lui	a3,0x80044
800406d0:	4dc60613          	addi	a2,a2,1244 # 800444dc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800444dd>
800406d4:	50468693          	addi	a3,a3,1284 # 80044504 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044505>
800406d8:	80044537          	lui	a0,0x80044
800406dc:	85ca                	mv	a1,s2
800406de:	4ec50513          	addi	a0,a0,1260 # 800444ec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800444ed>
800406e2:	034010ef          	jal	ra,80041716 <printk>
	       id, prio < 0 ? "C" : "P",
	       prio < 0 ? "" : " ",
	       prio);

	if (delay) {
800406e6:	c431                	beqz	s0,80040732 <print_phil_state+0x9c>
		printk(fmt, delay < 1000 ? " " : "", delay);
800406e8:	3e700793          	li	a5,999
800406ec:	0287de63          	bge	a5,s0,80040728 <print_phil_state+0x92>
800406f0:	800445b7          	lui	a1,0x80044
800406f4:	55c58593          	addi	a1,a1,1372 # 8004455c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004455d>
800406f8:	8622                	mv	a2,s0
800406fa:	8526                	mv	a0,s1
800406fc:	01a010ef          	jal	ra,80041716 <printk>
	} else {
		printk(fmt, "");
	}

	printk("\n");
}
80040700:	4462                	lw	s0,24(sp)
80040702:	40f2                	lw	ra,28(sp)
80040704:	44d2                	lw	s1,20(sp)
80040706:	4942                	lw	s2,16(sp)
	printk("\n");
80040708:	80044537          	lui	a0,0x80044
8004070c:	65c50513          	addi	a0,a0,1628 # 8004465c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004465d>
}
80040710:	6105                	addi	sp,sp,32
	printk("\n");
80040712:	0040106f          	j	80041716 <printk>
	printk("Philosopher %d [%s:%s%d] ",
80040716:	80044637          	lui	a2,0x80044
8004071a:	800446b7          	lui	a3,0x80044
8004071e:	4d860613          	addi	a2,a2,1240 # 800444d8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800444d9>
80040722:	55c68693          	addi	a3,a3,1372 # 8004455c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004455d>
80040726:	bf4d                	j	800406d8 <print_phil_state+0x42>
		printk(fmt, delay < 1000 ? " " : "", delay);
80040728:	800445b7          	lui	a1,0x80044
8004072c:	50458593          	addi	a1,a1,1284 # 80044504 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044505>
80040730:	b7e1                	j	800406f8 <print_phil_state+0x62>
		printk(fmt, "");
80040732:	800445b7          	lui	a1,0x80044
80040736:	55c58593          	addi	a1,a1,1372 # 8004455c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004455d>
8004073a:	8526                	mv	a0,s1
8004073c:	7db000ef          	jal	ra,80041716 <printk>
80040740:	b7c1                	j	80040700 <print_phil_state+0x6a>

80040742 <philosopher>:
{
	return id == (NUM_PHIL - 1);
}

void philosopher(void *id, void *unused1, void *unused2)
{
80040742:	7139                	addi	sp,sp,-64
80040744:	da26                	sw	s1,52(sp)
80040746:	d452                	sw	s4,40(sp)
80040748:	de06                	sw	ra,60(sp)
8004074a:	dc22                	sw	s0,56(sp)
8004074c:	d84a                	sw	s2,48(sp)
8004074e:	d64e                	sw	s3,44(sp)
80040750:	d256                	sw	s5,36(sp)
80040752:	d05a                	sw	s6,32(sp)
80040754:	ce5e                	sw	s7,28(sp)
80040756:	cc62                	sw	s8,24(sp)
80040758:	ca66                	sw	s9,20(sp)
8004075a:	c86a                	sw	s10,16(sp)
8004075c:	c66e                	sw	s11,12(sp)
	fork_t fork2;

	int my_id = (int)id;

	/* Djkstra's solution: always pick up the lowest numbered fork first */
	if (is_last_philosopher(my_id)) {
8004075e:	4795                	li	a5,5
{
80040760:	84aa                	mv	s1,a0
80040762:	00150a13          	addi	s4,a0,1
	if (is_last_philosopher(my_id)) {
80040766:	0af50f63          	beq	a0,a5,80040824 <philosopher+0xe2>
		fork1 = fork(0);
		fork2 = fork(my_id);
	} else {
		fork1 = fork(my_id);
8004076a:	800447b7          	lui	a5,0x80044
8004076e:	2f078793          	addi	a5,a5,752 # 800442f0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800442f1>
80040772:	00251713          	slli	a4,a0,0x2
80040776:	973e                	add	a4,a4,a5
80040778:	00072903          	lw	s2,0(a4)
		fork2 = fork(my_id + 1);
8004077c:	002a1713          	slli	a4,s4,0x2
80040780:	97ba                	add	a5,a5,a4
80040782:	0007a983          	lw	s3,0(a5)
	}

	while (1) {
		s32_t delay;

		print_phil_state(my_id, "       STARVING       ", 0);
80040786:	80044db7          	lui	s11,0x80044
		take(fork1);
		print_phil_state(my_id, "   HOLDING ONE FORK   ", 0);
8004078a:	80044d37          	lui	s10,0x80044
	s32_t delay = (k_uptime_get_32()/100 * (id + 1)) & 0x1f;
8004078e:	06400b13          	li	s6,100
	s32_t ms = (delay + 1) * period_in_ms;
80040792:	4ae5                	li	s5,25
		take(fork2);

		delay = get_random_delay(my_id, 25);
		print_phil_state(my_id, "  EATING  [ %s%d ms ] ", delay);
80040794:	80044cb7          	lui	s9,0x80044
		k_sleep(delay);

		drop(fork2);
		print_phil_state(my_id, "   DROPPED ONE FORK   ", 0);
80040798:	80044c37          	lui	s8,0x80044
		drop(fork1);

		delay = get_random_delay(my_id, 25);
		print_phil_state(my_id, " THINKING [ %s%d ms ] ", delay);
8004079c:	80044bb7          	lui	s7,0x80044
		print_phil_state(my_id, "       STARVING       ", 0);
800407a0:	4601                	li	a2,0
800407a2:	460d8593          	addi	a1,s11,1120 # 80044460 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044461>
800407a6:	8526                	mv	a0,s1
800407a8:	35fd                	jal	80040696 <print_phil_state>

K_SYSCALL_DECLARE3(K_SYSCALL_K_STACK_POP, k_stack_pop, int, struct k_stack *, stack, u32_t *, data, s32_t, timeout)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_INIT, k_mutex_init, struct k_mutex *, mutex)

K_SYSCALL_DECLARE2(K_SYSCALL_K_MUTEX_LOCK, k_mutex_lock, int, struct k_mutex *, mutex, s32_t, timeout)
800407aa:	55fd                	li	a1,-1
800407ac:	854a                	mv	a0,s2
800407ae:	6d0010ef          	jal	ra,80041e7e <z_impl_k_mutex_lock>
		print_phil_state(my_id, "   HOLDING ONE FORK   ", 0);
800407b2:	4601                	li	a2,0
800407b4:	478d0593          	addi	a1,s10,1144 # 80044478 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044479>
800407b8:	8526                	mv	a0,s1
800407ba:	3df1                	jal	80040696 <print_phil_state>
800407bc:	55fd                	li	a1,-1
800407be:	854e                	mv	a0,s3
800407c0:	6be010ef          	jal	ra,80041e7e <z_impl_k_mutex_lock>
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
800407c4:	09d030ef          	jal	ra,80044060 <z_impl_k_uptime_get_32>
	s32_t delay = (k_uptime_get_32()/100 * (id + 1)) & 0x1f;
800407c8:	03655433          	divu	s0,a0,s6
		print_phil_state(my_id, "  EATING  [ %s%d ms ] ", delay);
800407cc:	490c8593          	addi	a1,s9,1168 # 80044490 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044491>
800407d0:	8526                	mv	a0,s1
	s32_t delay = (k_uptime_get_32()/100 * (id + 1)) & 0x1f;
800407d2:	03440433          	mul	s0,s0,s4
800407d6:	887d                	andi	s0,s0,31
	s32_t ms = (delay + 1) * period_in_ms;
800407d8:	0405                	addi	s0,s0,1
800407da:	03540433          	mul	s0,s0,s5
		print_phil_state(my_id, "  EATING  [ %s%d ms ] ", delay);
800407de:	8622                	mv	a2,s0
800407e0:	3d5d                	jal	80040696 <print_phil_state>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
800407e2:	8522                	mv	a0,s0
800407e4:	34d020ef          	jal	ra,80043330 <z_impl_k_sleep>

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)
800407e8:	854e                	mv	a0,s3
800407ea:	05b010ef          	jal	ra,80042044 <z_impl_k_mutex_unlock>
		print_phil_state(my_id, "   DROPPED ONE FORK   ", 0);
800407ee:	4a8c0593          	addi	a1,s8,1192 # 800444a8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800444a9>
800407f2:	4601                	li	a2,0
800407f4:	8526                	mv	a0,s1
800407f6:	3545                	jal	80040696 <print_phil_state>
800407f8:	854a                	mv	a0,s2
800407fa:	04b010ef          	jal	ra,80042044 <z_impl_k_mutex_unlock>
K_SYSCALL_DECLARE0(K_SYSCALL_K_UPTIME_GET_32, k_uptime_get_32, u32_t)
800407fe:	063030ef          	jal	ra,80044060 <z_impl_k_uptime_get_32>
	s32_t delay = (k_uptime_get_32()/100 * (id + 1)) & 0x1f;
80040802:	03655433          	divu	s0,a0,s6
		print_phil_state(my_id, " THINKING [ %s%d ms ] ", delay);
80040806:	4c0b8593          	addi	a1,s7,1216 # 800444c0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800444c1>
8004080a:	8526                	mv	a0,s1
	s32_t delay = (k_uptime_get_32()/100 * (id + 1)) & 0x1f;
8004080c:	03440433          	mul	s0,s0,s4
80040810:	887d                	andi	s0,s0,31
	s32_t ms = (delay + 1) * period_in_ms;
80040812:	0405                	addi	s0,s0,1
80040814:	03540433          	mul	s0,s0,s5
		print_phil_state(my_id, " THINKING [ %s%d ms ] ", delay);
80040818:	8622                	mv	a2,s0
8004081a:	3db5                	jal	80040696 <print_phil_state>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
8004081c:	8522                	mv	a0,s0
8004081e:	313020ef          	jal	ra,80043330 <z_impl_k_sleep>
80040822:	bfbd                	j	800407a0 <philosopher+0x5e>
		fork2 = fork(my_id);
80040824:	80045937          	lui	s2,0x80045
80040828:	df090993          	addi	s3,s2,-528 # 80044df0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044df1>
8004082c:	06498993          	addi	s3,s3,100
		fork1 = fork(0);
80040830:	df090913          	addi	s2,s2,-528
80040834:	bf89                	j	80040786 <philosopher+0x44>

80040836 <main>:
	"well as %s %s and thread sleeping.\n", obj_init_type, fork_type_str

static void display_demo_description(void)
{
#if !DEBUG_PRINTF
	printk(DEMO_DESCRIPTION);
80040836:	80044637          	lui	a2,0x80044
8004083a:	800445b7          	lui	a1,0x80044
8004083e:	80044537          	lui	a0,0x80044
#endif
}

void main(void)
{
80040842:	7139                	addi	sp,sp,-64
	printk(DEMO_DESCRIPTION);
80040844:	30860613          	addi	a2,a2,776 # 80044308 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044309>
80040848:	31058593          	addi	a1,a1,784 # 80044310 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044311>
8004084c:	31850513          	addi	a0,a0,792 # 80044318 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044319>
{
80040850:	de06                	sw	ra,60(sp)
80040852:	dc22                	sw	s0,56(sp)
80040854:	da26                	sw	s1,52(sp)
80040856:	d84a                	sw	s2,48(sp)
80040858:	d64e                	sw	s3,44(sp)
8004085a:	d452                	sw	s4,40(sp)
8004085c:	d256                	sw	s5,36(sp)
8004085e:	d05a                	sw	s6,32(sp)
80040860:	ce5e                	sw	s7,28(sp)
	printk(DEMO_DESCRIPTION);
80040862:	6b5000ef          	jal	ra,80041716 <printk>
	display_demo_description();
#if CONFIG_TIMESLICING
	k_sched_time_slice_set(5000, 0);
80040866:	6505                	lui	a0,0x1
80040868:	4581                	li	a1,0
8004086a:	38850513          	addi	a0,a0,904 # 1388 <CONFIG_ISR_STACK_SIZE+0xb88>
8004086e:	243010ef          	jal	ra,800422b0 <k_sched_time_slice_set>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_INIT, k_mutex_init, struct k_mutex *, mutex)
80040872:	80045537          	lui	a0,0x80045
80040876:	df050413          	addi	s0,a0,-528 # 80044df0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044df1>
8004087a:	df050513          	addi	a0,a0,-528
8004087e:	5f2010ef          	jal	ra,80041e70 <z_impl_k_mutex_init>
80040882:	01440513          	addi	a0,s0,20
80040886:	5ea010ef          	jal	ra,80041e70 <z_impl_k_mutex_init>
8004088a:	02840513          	addi	a0,s0,40
8004088e:	5e2010ef          	jal	ra,80041e70 <z_impl_k_mutex_init>
80040892:	03c40513          	addi	a0,s0,60
80040896:	5da010ef          	jal	ra,80041e70 <z_impl_k_mutex_init>
8004089a:	05040513          	addi	a0,s0,80
8004089e:	5d2010ef          	jal	ra,80041e70 <z_impl_k_mutex_init>
800408a2:	06440513          	addi	a0,s0,100
800408a6:	80045937          	lui	s2,0x80045
800408aa:	80045437          	lui	s0,0x80045
800408ae:	5c2010ef          	jal	ra,80041e70 <z_impl_k_mutex_init>
800408b2:	e6840413          	addi	s0,s0,-408 # 80044e68 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044e69>
800408b6:	22090913          	addi	s2,s2,544 # 80045220 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045221>
	for (int i = 0; i < NUM_PHIL; i++) {
800408ba:	4481                	li	s1,0
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
800408bc:	4a8d                	li	s5,3
800408be:	5bfd                	li	s7,-1
800408c0:	4b11                	li	s6,4
800408c2:	80040a37          	lui	s4,0x80040
800408c6:	4999                	li	s3,6
800408c8:	409a88b3          	sub	a7,s5,s1
800408cc:	8726                	mv	a4,s1
800408ce:	85ca                	mv	a1,s2
800408d0:	4801                	li	a6,0
800408d2:	4781                	li	a5,0
800408d4:	742a0693          	addi	a3,s4,1858 # 80040742 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80040743>
800408d8:	30000613          	li	a2,768
800408dc:	8522                	mv	a0,s0
800408de:	c25e                	sw	s7,4(sp)
800408e0:	c05a                	sw	s6,0(sp)
800408e2:	5e7020ef          	jal	ra,800436c8 <z_impl_k_thread_create>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)
800408e6:	8522                	mv	a0,s0
		k_object_access_grant(fork((i + 1) % NUM_PHIL), &threads[i]);
800408e8:	0485                	addi	s1,s1,1
800408ea:	4f9020ef          	jal	ra,800435e2 <z_impl_k_thread_start>
800408ee:	07040413          	addi	s0,s0,112
800408f2:	30090913          	addi	s2,s2,768
	for (int i = 0; i < NUM_PHIL; i++) {
800408f6:	fd3499e3          	bne	s1,s3,800408c8 <main+0x92>
#endif

	init_objects();
	start_threads();
}
800408fa:	50f2                	lw	ra,60(sp)
800408fc:	5462                	lw	s0,56(sp)
800408fe:	54d2                	lw	s1,52(sp)
80040900:	5942                	lw	s2,48(sp)
80040902:	59b2                	lw	s3,44(sp)
80040904:	5a22                	lw	s4,40(sp)
80040906:	5a92                	lw	s5,36(sp)
80040908:	5b02                	lw	s6,32(sp)
8004090a:	4bf2                	lw	s7,28(sp)
8004090c:	6121                	addi	sp,sp,64
8004090e:	8082                	ret

80040910 <z_SysFatalErrorHandler>:
 *
 * @return N/A
 */
FUNC_NORETURN __weak void z_SysFatalErrorHandler(unsigned int reason,
						const NANO_ESF *esf)
{
80040910:	1141                	addi	sp,sp,-16
80040912:	c606                	sw	ra,12(sp)
80040914:	c422                	sw	s0,8(sp)
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
80040916:	4799                	li	a5,6
80040918:	02f50263          	beq	a0,a5,8004093c <z_SysFatalErrorHandler+0x2c>
		goto hang_system;
	}
	if (k_is_in_isr() || z_is_thread_essential()) {
8004091c:	3d3020ef          	jal	ra,800434ee <k_is_in_isr>
80040920:	c10d                	beqz	a0,80040942 <z_SysFatalErrorHandler+0x32>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
80040922:	3cd020ef          	jal	ra,800434ee <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
80040926:	e121                	bnez	a0,80040966 <z_SysFatalErrorHandler+0x56>
80040928:	800445b7          	lui	a1,0x80044
8004092c:	7b858593          	addi	a1,a1,1976 # 800447b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800447b9>
80040930:	80044537          	lui	a0,0x80044
80040934:	7cc50513          	addi	a0,a0,1996 # 800447cc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800447cd>
80040938:	5df000ef          	jal	ra,80041716 <printk>
#else
	ARG_UNUSED(reason);
#endif

	for (;;) {
		k_cpu_idle();
8004093c:	621000ef          	jal	ra,8004175c <k_cpu_idle>
80040940:	bff5                	j	8004093c <z_SysFatalErrorHandler+0x2c>
	if (k_is_in_isr() || z_is_thread_essential()) {
80040942:	3bb020ef          	jal	ra,800434fc <z_is_thread_essential>
80040946:	fd71                	bnez	a0,80040922 <z_SysFatalErrorHandler+0x12>
	printk("Fatal fault in thread %p! Aborting.\n", _current);
80040948:	80045437          	lui	s0,0x80045
8004094c:	1e840413          	addi	s0,s0,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
80040950:	440c                	lw	a1,8(s0)
80040952:	80044537          	lui	a0,0x80044
80040956:	7ec50513          	addi	a0,a0,2028 # 800447ec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800447ed>
8004095a:	5bd000ef          	jal	ra,80041716 <printk>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
8004095e:	4408                	lw	a0,8(s0)
80040960:	6bd020ef          	jal	ra,8004381c <z_impl_k_thread_abort>
80040964:	bfe1                	j	8004093c <z_SysFatalErrorHandler+0x2c>
		printk("Fatal fault in %s! Spinning...\n",
80040966:	800445b7          	lui	a1,0x80044
8004096a:	7b458593          	addi	a1,a1,1972 # 800447b4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800447b5>
8004096e:	b7c9                	j	80040930 <z_SysFatalErrorHandler+0x20>

80040970 <z_NanoFatalErrorHandler>:
{
80040970:	715d                	addi	sp,sp,-80
80040972:	c4a2                	sw	s0,72(sp)
80040974:	c2a6                	sw	s1,68(sp)
80040976:	c686                	sw	ra,76(sp)
	switch (reason) {
80040978:	4799                	li	a5,6
{
8004097a:	84aa                	mv	s1,a0
8004097c:	842e                	mv	s0,a1
	switch (reason) {
8004097e:	08a7e963          	bltu	a5,a0,80040a10 <z_NanoFatalErrorHandler+0xa0>
80040982:	80044737          	lui	a4,0x80044
80040986:	00251793          	slli	a5,a0,0x2
8004098a:	50870713          	addi	a4,a4,1288 # 80044508 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044509>
8004098e:	97ba                	add	a5,a5,a4
80040990:	439c                	lw	a5,0(a5)
80040992:	8782                	jr	a5
		printk("**** Kernel Allocation Failure! ****\n");
80040994:	80044537          	lui	a0,0x80044
80040998:	63850513          	addi	a0,a0,1592 # 80044638 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044639>
		printk("***** Kernel OOPS! *****\n");
8004099c:	57b000ef          	jal	ra,80041716 <printk>
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
800409a0:	331020ef          	jal	ra,800434d0 <z_impl_k_current_get>
	printk("Current thread ID = %p\n"
800409a4:	407c                	lw	a5,68(s0)
800409a6:	01042883          	lw	a7,16(s0)
800409aa:	00c42803          	lw	a6,12(s0)
800409ae:	d83e                	sw	a5,48(sp)
800409b0:	403c                	lw	a5,64(s0)
800409b2:	4058                	lw	a4,4(s0)
800409b4:	4014                	lw	a3,0(s0)
800409b6:	d63e                	sw	a5,44(sp)
800409b8:	5c5c                	lw	a5,60(s0)
800409ba:	4430                	lw	a2,72(s0)
800409bc:	85aa                	mv	a1,a0
800409be:	d43e                	sw	a5,40(sp)
800409c0:	5c1c                	lw	a5,56(s0)
800409c2:	80044537          	lui	a0,0x80044
800409c6:	6bc50513          	addi	a0,a0,1724 # 800446bc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800446bd>
800409ca:	d23e                	sw	a5,36(sp)
800409cc:	585c                	lw	a5,52(s0)
800409ce:	d03e                	sw	a5,32(sp)
800409d0:	581c                	lw	a5,48(s0)
800409d2:	ce3e                	sw	a5,28(sp)
800409d4:	545c                	lw	a5,44(s0)
800409d6:	cc3e                	sw	a5,24(sp)
800409d8:	541c                	lw	a5,40(s0)
800409da:	ca3e                	sw	a5,20(sp)
800409dc:	505c                	lw	a5,36(s0)
800409de:	c83e                	sw	a5,16(sp)
800409e0:	501c                	lw	a5,32(s0)
800409e2:	c63e                	sw	a5,12(sp)
800409e4:	4c5c                	lw	a5,28(s0)
800409e6:	c43e                	sw	a5,8(sp)
800409e8:	4c1c                	lw	a5,24(s0)
800409ea:	c23e                	sw	a5,4(sp)
800409ec:	485c                	lw	a5,20(s0)
800409ee:	c03e                	sw	a5,0(sp)
800409f0:	441c                	lw	a5,8(s0)
800409f2:	525000ef          	jal	ra,80041716 <printk>
	z_SysFatalErrorHandler(reason, esf);
800409f6:	85a2                	mv	a1,s0
800409f8:	8526                	mv	a0,s1
800409fa:	3f19                	jal	80040910 <z_SysFatalErrorHandler>
		printk("***** Kernel OOPS! *****\n");
800409fc:	80044537          	lui	a0,0x80044
80040a00:	66050513          	addi	a0,a0,1632 # 80044660 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044661>
80040a04:	bf61                	j	8004099c <z_NanoFatalErrorHandler+0x2c>
		printk("***** Kernel Panic! *****\n");
80040a06:	80044537          	lui	a0,0x80044
80040a0a:	67c50513          	addi	a0,a0,1660 # 8004467c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004467d>
80040a0e:	b779                	j	8004099c <z_NanoFatalErrorHandler+0x2c>
		printk("**** Unknown Fatal Error %d! ****\n", reason);
80040a10:	80044537          	lui	a0,0x80044
80040a14:	85a6                	mv	a1,s1
80040a16:	69850513          	addi	a0,a0,1688 # 80044698 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044699>
80040a1a:	4fd000ef          	jal	ra,80041716 <printk>
		break;
80040a1e:	b749                	j	800409a0 <z_NanoFatalErrorHandler+0x30>

80040a20 <_Fault>:
	}
}


FUNC_NORETURN void _Fault(const NANO_ESF *esf)
{
80040a20:	1141                	addi	sp,sp,-16
80040a22:	c422                	sw	s0,8(sp)
80040a24:	c606                	sw	ra,12(sp)
80040a26:	842a                	mv	s0,a0
	u32_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
80040a28:	34202673          	csrr	a2,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;
80040a2c:	0606                	slli	a2,a2,0x1
80040a2e:	8205                	srli	a2,a2,0x1
	switch (cause) {
80040a30:	4795                	li	a5,5
80040a32:	02c7e363          	bltu	a5,a2,80040a58 <_Fault+0x38>
80040a36:	80044737          	lui	a4,0x80044
80040a3a:	00261793          	slli	a5,a2,0x2
80040a3e:	52470713          	addi	a4,a4,1316 # 80044524 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044525>
80040a42:	97ba                	add	a5,a5,a4
80040a44:	438c                	lw	a1,0(a5)
	printk("Exception cause %s (%d)\n", cause_str(mcause), (int)mcause);
80040a46:	80044537          	lui	a0,0x80044
80040a4a:	54450513          	addi	a0,a0,1348 # 80044544 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044545>
80040a4e:	4c9000ef          	jal	ra,80041716 <printk>

	z_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, esf);
80040a52:	85a2                	mv	a1,s0
80040a54:	4501                	li	a0,0
80040a56:	3f29                	jal	80040970 <z_NanoFatalErrorHandler>
	mcause &= SOC_MCAUSE_EXP_MASK;
80040a58:	800445b7          	lui	a1,0x80044
80040a5c:	53c58593          	addi	a1,a1,1340 # 8004453c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004453d>
80040a60:	b7dd                	j	80040a46 <_Fault+0x26>

80040a62 <z_irq_spurious>:
#include <toolchain.h>
#include <kernel_structs.h>
#include <misc/printk.h>

void z_irq_spurious(void *unused)
{
80040a62:	1141                	addi	sp,sp,-16
80040a64:	c606                	sw	ra,12(sp)
	u32_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
80040a66:	342025f3          	csrr	a1,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;

	printk("Spurious interrupt detected! IRQ: %d\n", (int)mcause);
80040a6a:	80045537          	lui	a0,0x80045
	mcause &= SOC_MCAUSE_EXP_MASK;
80040a6e:	0586                	slli	a1,a1,0x1
	printk("Spurious interrupt detected! IRQ: %d\n", (int)mcause);
80040a70:	8185                	srli	a1,a1,0x1
80040a72:	81450513          	addi	a0,a0,-2028 # 80044814 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044815>
80040a76:	4a1000ef          	jal	ra,80041716 <printk>
		printk("PLIC interrupt line causing the IRQ: %d\n",
		       riscv_plic_get_irq());
	}
#endif

	z_NanoFatalErrorHandler(_NANO_ERR_SPURIOUS_INT, &_default_esf);
80040a7a:	800445b7          	lui	a1,0x80044
80040a7e:	56058593          	addi	a1,a1,1376 # 80044560 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044561>
80040a82:	4511                	li	a0,4
80040a84:	35f5                	jal	80040970 <z_NanoFatalErrorHandler>

80040a86 <z_irq_do_offload>:
 */
void z_irq_do_offload(void)
{
	irq_offload_routine_t tmp;

	if (!_offload_routine)
80040a86:	800457b7          	lui	a5,0x80045
80040a8a:	dc078793          	addi	a5,a5,-576 # 80044dc0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dc1>
80040a8e:	4398                	lw	a4,0(a5)
80040a90:	cb11                	beqz	a4,80040aa4 <z_irq_do_offload+0x1e>
		return;

	tmp = _offload_routine;
80040a92:	0007a303          	lw	t1,0(a5)
	_offload_routine = NULL;
80040a96:	0007a023          	sw	zero,0(a5)

	tmp((void *)offload_param);
80040a9a:	800457b7          	lui	a5,0x80045
80040a9e:	dc47a503          	lw	a0,-572(a5) # 80044dc4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dc5>
80040aa2:	8302                	jr	t1
}
80040aa4:	8082                	ret

80040aa6 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
80040aa6:	1141                	addi	sp,sp,-16
80040aa8:	c606                	sw	ra,12(sp)
	z_bss_zero();
80040aaa:	1c4010ef          	jal	ra,80041c6e <z_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
80040aae:	4c7000ef          	jal	ra,80041774 <soc_interrupt_init>
#endif
	z_cstart();
80040ab2:	20e010ef          	jal	ra,80041cc0 <z_cstart>

80040ab6 <z_new_thread>:

void z_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		 size_t stack_size, k_thread_entry_t thread_func,
		 void *arg1, void *arg2, void *arg3,
		 int priority, unsigned int options)
{
80040ab6:	7179                	addi	sp,sp,-48
80040ab8:	d422                	sw	s0,40(sp)
80040aba:	d226                	sw	s1,36(sp)
80040abc:	d04a                	sw	s2,32(sp)
80040abe:	ce4e                	sw	s3,28(sp)
80040ac0:	cc52                	sw	s4,24(sp)
80040ac2:	ca56                	sw	s5,20(sp)
80040ac4:	c85a                	sw	s6,16(sp)
80040ac6:	c65e                	sw	s7,12(sp)
80040ac8:	8b3e                	mv	s6,a5
80040aca:	d606                	sw	ra,44(sp)
80040acc:	c462                	sw	s8,8(sp)
	char *stack_memory = Z_THREAD_STACK_BUFFER(stack);
	Z_ASSERT_VALID_PRIO(priority, thread_func);
80040ace:	02800793          	li	a5,40
{
80040ad2:	84aa                	mv	s1,a0
80040ad4:	842e                	mv	s0,a1
80040ad6:	89b2                	mv	s3,a2
80040ad8:	8a36                	mv	s4,a3
80040ada:	8bba                	mv	s7,a4
80040adc:	8ac2                	mv	s5,a6
80040ade:	8946                	mv	s2,a7
	Z_ASSERT_VALID_PRIO(priority, thread_func);
80040ae0:	06f89463          	bne	a7,a5,80040b48 <z_new_thread+0x92>
80040ae4:	800427b7          	lui	a5,0x80042
80040ae8:	c4a78793          	addi	a5,a5,-950 # 80041c4a <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041c4b>
80040aec:	06f69463          	bne	a3,a5,80040b54 <z_new_thread+0x9e>
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
80040af0:	56c2                	lw	a3,48(sp)
80040af2:	85ca                	mv	a1,s2
80040af4:	8526                	mv	a0,s1
80040af6:	4611                	li	a2,4
80040af8:	281020ef          	jal	ra,80043578 <z_init_thread_base>

	z_new_thread_init(thread, stack_memory, stack_size, priority, options);

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)
		STACK_ROUND_DOWN(stack_memory +
80040afc:	fb098593          	addi	a1,s3,-80
80040b00:	95a2                	add	a1,a1,s0
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
80040b02:	6789                	lui	a5,0x2

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
80040b04:	0404ae23          	sw	zero,92(s1)
	thread->fn_abort = NULL;
80040b08:	0604a023          	sw	zero,96(s1)
		STACK_ROUND_DOWN(stack_memory +
80040b0c:	99c1                	andi	a1,a1,-16
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
80040b0e:	88078793          	addi	a5,a5,-1920 # 1880 <CONFIG_ISR_STACK_SIZE+0x1080>
80040b12:	c5fc                	sw	a5,76(a1)
	stack_init->mepc = (u32_t)z_thread_entry_wrapper;
80040b14:	800407b7          	lui	a5,0x80040

	thread->callee_saved.sp = (u32_t)stack_init;
}
80040b18:	50b2                	lw	ra,44(sp)
80040b1a:	5422                	lw	s0,40(sp)
	stack_init->mepc = (u32_t)z_thread_entry_wrapper;
80040b1c:	69078793          	addi	a5,a5,1680 # 80040690 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80040691>
	stack_init->a0 = (u32_t)thread_func;
80040b20:	0345a423          	sw	s4,40(a1)
	stack_init->a1 = (u32_t)arg1;
80040b24:	0375a623          	sw	s7,44(a1)
	stack_init->a2 = (u32_t)arg2;
80040b28:	0365a823          	sw	s6,48(a1)
	stack_init->a3 = (u32_t)arg3;
80040b2c:	0355aa23          	sw	s5,52(a1)
	stack_init->mepc = (u32_t)z_thread_entry_wrapper;
80040b30:	c5bc                	sw	a5,72(a1)
	thread->callee_saved.sp = (u32_t)stack_init;
80040b32:	d48c                	sw	a1,40(s1)
}
80040b34:	5902                	lw	s2,32(sp)
80040b36:	5492                	lw	s1,36(sp)
80040b38:	49f2                	lw	s3,28(sp)
80040b3a:	4a62                	lw	s4,24(sp)
80040b3c:	4ad2                	lw	s5,20(sp)
80040b3e:	4b42                	lw	s6,16(sp)
80040b40:	4bb2                	lw	s7,12(sp)
80040b42:	4c22                	lw	s8,8(sp)
80040b44:	6145                	addi	sp,sp,48
80040b46:	8082                	ret
	Z_ASSERT_VALID_PRIO(priority, thread_func);
80040b48:	01d88693          	addi	a3,a7,29
80040b4c:	04400793          	li	a5,68
80040b50:	fad7f0e3          	bgeu	a5,a3,80040af0 <z_new_thread+0x3a>
80040b54:	80045c37          	lui	s8,0x80045
80040b58:	800455b7          	lui	a1,0x80045
80040b5c:	80045537          	lui	a0,0x80045
80040b60:	83cc0613          	addi	a2,s8,-1988 # 8004483c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004483d>
80040b64:	46e1                	li	a3,24
80040b66:	86c58593          	addi	a1,a1,-1940 # 8004486c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004486d>
80040b6a:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80040b6e:	3a9000ef          	jal	ra,80041716 <printk>
80040b72:	80045537          	lui	a0,0x80045
80040b76:	85ca                	mv	a1,s2
80040b78:	568d                	li	a3,-29
80040b7a:	02700613          	li	a2,39
80040b7e:	91850513          	addi	a0,a0,-1768 # 80044918 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044919>
80040b82:	395000ef          	jal	ra,80041716 <printk>
80040b86:	45e1                	li	a1,24
80040b88:	83cc0513          	addi	a0,s8,-1988
80040b8c:	3a9000ef          	jal	ra,80041734 <assert_post_action>
80040b90:	b785                	j	80040af0 <z_new_thread+0x3a>

80040b92 <get_bit_ptr>:
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
	u32_t *bitarray = level <= p->max_inline_level ?
80040b92:	47b1                	li	a5,12
80040b94:	02f58733          	mul	a4,a1,a5
80040b98:	455c                	lw	a5,12(a0)
80040b9a:	97ba                	add	a5,a5,a4
80040b9c:	00b50703          	lb	a4,11(a0)
		&p->levels[level].bits : p->levels[level].bits_p;
80040ba0:	00b75363          	bge	a4,a1,80040ba6 <get_bit_ptr+0x14>
80040ba4:	439c                	lw	a5,0(a5)

	*word = &bitarray[bn / 32];
80040ba6:	02000713          	li	a4,32
80040baa:	02e64733          	div	a4,a2,a4

	return bn & 0x1f;
}
80040bae:	01f67513          	andi	a0,a2,31
	*word = &bitarray[bn / 32];
80040bb2:	070a                	slli	a4,a4,0x2
80040bb4:	97ba                	add	a5,a5,a4
80040bb6:	c29c                	sw	a5,0(a3)
}
80040bb8:	8082                	ret

80040bba <set_free_bit>:

static void set_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
80040bba:	1101                	addi	sp,sp,-32
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
80040bbc:	0074                	addi	a3,sp,12
{
80040bbe:	ce06                	sw	ra,28(sp)
	int bit = get_bit_ptr(p, level, bn, &word);
80040bc0:	3fc9                	jal	80040b92 <get_bit_ptr>

	*word |= (1<<bit);
80040bc2:	4732                	lw	a4,12(sp)
80040bc4:	4785                	li	a5,1
80040bc6:	00a79533          	sll	a0,a5,a0
80040bca:	431c                	lw	a5,0(a4)
}
80040bcc:	40f2                	lw	ra,28(sp)
	*word |= (1<<bit);
80040bce:	8fc9                	or	a5,a5,a0
80040bd0:	c31c                	sw	a5,0(a4)
}
80040bd2:	6105                	addi	sp,sp,32
80040bd4:	8082                	ret

80040bd6 <z_sys_mem_pool_base_init>:
}

void z_sys_mem_pool_base_init(struct sys_mem_pool_base *p)
{
	int i;
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
80040bd6:	415c                	lw	a5,4(a0)
80040bd8:	00855803          	lhu	a6,8(a0)
{
80040bdc:	1141                	addi	sp,sp,-16
80040bde:	c422                	sw	s0,8(sp)
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
80040be0:	02f80833          	mul	a6,a6,a5
{
80040be4:	842a                	mv	s0,a0
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
80040be6:	4108                	lw	a0,0(a0)

	p->max_inline_level = -1;

	for (i = 0; i < p->n_levels; i++) {
80040be8:	00a44883          	lbu	a7,10(s0)
	p->max_inline_level = -1;
80040bec:	577d                	li	a4,-1
{
80040bee:	c606                	sw	ra,12(sp)
80040bf0:	c226                	sw	s1,4(sp)
	p->max_inline_level = -1;
80040bf2:	00e405a3          	sb	a4,11(s0)
	for (i = 0; i < p->n_levels; i++) {
80040bf6:	4581                	li	a1,0
		int nblocks = buflen / sz;

		sys_dlist_init(&p->levels[i].free_list);
80040bf8:	4331                	li	t1,12
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
80040bfa:	9542                	add	a0,a0,a6

		if (nblocks < 32) {
80040bfc:	4e7d                	li	t3,31
			p->max_inline_level = i;
		} else {
			p->levels[i].bits_p = bits;
			bits += (nblocks + 31)/32;
80040bfe:	02000e93          	li	t4,32
	for (i = 0; i < p->n_levels; i++) {
80040c02:	0115cc63          	blt	a1,a7,80040c1a <z_sys_mem_pool_base_init+0x44>
		}

		sz = _ALIGN4(sz / 4);
	}

	for (i = 0; i < p->n_max; i++) {
80040c06:	4481                	li	s1,0
80040c08:	00845783          	lhu	a5,8(s0)
80040c0c:	04f4c163          	blt	s1,a5,80040c4e <z_sys_mem_pool_base_init+0x78>
		void *block = block_ptr(p, p->max_sz, i);

		sys_dlist_append(&p->levels[0].free_list, block);
		set_free_bit(p, 0, i);
	}
}
80040c10:	40b2                	lw	ra,12(sp)
80040c12:	4422                	lw	s0,8(sp)
80040c14:	4492                	lw	s1,4(sp)
80040c16:	0141                	addi	sp,sp,16
80040c18:	8082                	ret
		int nblocks = buflen / sz;
80040c1a:	02f85733          	divu	a4,a6,a5
		sys_dlist_init(&p->levels[i].free_list);
80040c1e:	4450                	lw	a2,12(s0)
80040c20:	026586b3          	mul	a3,a1,t1
80040c24:	96b2                	add	a3,a3,a2
80040c26:	00468613          	addi	a2,a3,4
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
80040c2a:	c2d0                	sw	a2,4(a3)
	list->tail = (sys_dnode_t *)list;
80040c2c:	c690                	sw	a2,8(a3)
		if (nblocks < 32) {
80040c2e:	00ee4963          	blt	t3,a4,80040c40 <z_sys_mem_pool_base_init+0x6a>
			p->max_inline_level = i;
80040c32:	00b405a3          	sb	a1,11(s0)
		sz = _ALIGN4(sz / 4);
80040c36:	8389                	srli	a5,a5,0x2
80040c38:	078d                	addi	a5,a5,3
80040c3a:	9bf1                	andi	a5,a5,-4
	for (i = 0; i < p->n_levels; i++) {
80040c3c:	0585                	addi	a1,a1,1
80040c3e:	b7d1                	j	80040c02 <z_sys_mem_pool_base_init+0x2c>
			bits += (nblocks + 31)/32;
80040c40:	077d                	addi	a4,a4,31
80040c42:	03d74733          	div	a4,a4,t4
			p->levels[i].bits_p = bits;
80040c46:	c288                	sw	a0,0(a3)
			bits += (nblocks + 31)/32;
80040c48:	070a                	slli	a4,a4,0x2
80040c4a:	953a                	add	a0,a0,a4
80040c4c:	b7ed                	j	80040c36 <z_sys_mem_pool_base_init+0x60>
	return (u8_t *)p->buf + lsz * block;
80040c4e:	405c                	lw	a5,4(s0)
		set_free_bit(p, 0, i);
80040c50:	8626                	mv	a2,s1
80040c52:	4581                	li	a1,0
	return (u8_t *)p->buf + lsz * block;
80040c54:	02f48733          	mul	a4,s1,a5
80040c58:	401c                	lw	a5,0(s0)
		set_free_bit(p, 0, i);
80040c5a:	8522                	mv	a0,s0
	for (i = 0; i < p->n_max; i++) {
80040c5c:	0485                	addi	s1,s1,1
	return (u8_t *)p->buf + lsz * block;
80040c5e:	97ba                	add	a5,a5,a4
		sys_dlist_append(&p->levels[0].free_list, block);
80040c60:	4458                	lw	a4,12(s0)
80040c62:	00470693          	addi	a3,a4,4
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
80040c66:	c394                	sw	a3,0(a5)
	node->prev = list->tail;
80040c68:	4714                	lw	a3,8(a4)
80040c6a:	c3d4                	sw	a3,4(a5)

	list->tail->next = node;
80040c6c:	4714                	lw	a3,8(a4)
80040c6e:	c29c                	sw	a5,0(a3)
	list->tail = node;
80040c70:	c71c                	sw	a5,8(a4)
		set_free_bit(p, 0, i);
80040c72:	37a1                	jal	80040bba <set_free_bit>
80040c74:	bf51                	j	80040c08 <z_sys_mem_pool_base_init+0x32>

80040c76 <set_child>:
}

static void set_child(struct rbnode *n, int side, void *val)
{
	CHECK(n);
	if (side != 0) {
80040c76:	c199                	beqz	a1,80040c7c <set_child+0x6>
		n->children[1] = val;
80040c78:	c150                	sw	a2,4(a0)
80040c7a:	8082                	ret
	} else {
		uintptr_t old = (uintptr_t) n->children[0];
		uintptr_t new = (uintptr_t) val;

		n->children[0] = (void *) (new | (old & 1UL));
80040c7c:	411c                	lw	a5,0(a0)
80040c7e:	8b85                	andi	a5,a5,1
80040c80:	8e5d                	or	a2,a2,a5
80040c82:	c110                	sw	a2,0(a0)
	}
}
80040c84:	8082                	ret

80040c86 <find_and_stack>:
static int find_and_stack(struct rbtree *tree, struct rbnode *node,
			  struct rbnode **stack)
{
	int sz = 0;

	stack[sz++] = tree->root;
80040c86:	411c                	lw	a5,0(a0)
{
80040c88:	1101                	addi	sp,sp,-32
80040c8a:	cc22                	sw	s0,24(sp)
80040c8c:	ca26                	sw	s1,20(sp)
80040c8e:	c84a                	sw	s2,16(sp)
80040c90:	c64e                	sw	s3,12(sp)
80040c92:	ce06                	sw	ra,28(sp)
80040c94:	89aa                	mv	s3,a0
80040c96:	892e                	mv	s2,a1
	stack[sz++] = tree->root;
80040c98:	c21c                	sw	a5,0(a2)

	while (stack[sz - 1] != node) {
80040c9a:	8432                	mv	s0,a2
	stack[sz++] = tree->root;
80040c9c:	4485                	li	s1,1
	while (stack[sz - 1] != node) {
80040c9e:	400c                	lw	a1,0(s0)
80040ca0:	01259a63          	bne	a1,s2,80040cb4 <find_and_stack+0x2e>
			break;
		}
	}

	return sz;
}
80040ca4:	40f2                	lw	ra,28(sp)
80040ca6:	4462                	lw	s0,24(sp)
80040ca8:	8526                	mv	a0,s1
80040caa:	4942                	lw	s2,16(sp)
80040cac:	44d2                	lw	s1,20(sp)
80040cae:	49b2                	lw	s3,12(sp)
80040cb0:	6105                	addi	sp,sp,32
80040cb2:	8082                	ret
		int side = tree->lessthan_fn(node, stack[sz - 1]) ? 0 : 1;
80040cb4:	0049a783          	lw	a5,4(s3)
80040cb8:	854a                	mv	a0,s2
80040cba:	9782                	jalr	a5
		struct rbnode *ch = get_child(stack[sz - 1], side);
80040cbc:	401c                	lw	a5,0(s0)
	if (side != 0) {
80040cbe:	e519                	bnez	a0,80040ccc <find_and_stack+0x46>
		return n->children[1];
80040cc0:	43dc                	lw	a5,4(a5)
		if (ch != NULL) {
80040cc2:	0411                	addi	s0,s0,4
80040cc4:	d3e5                	beqz	a5,80040ca4 <find_and_stack+0x1e>
			stack[sz++] = ch;
80040cc6:	0485                	addi	s1,s1,1
80040cc8:	c01c                	sw	a5,0(s0)
80040cca:	bfd1                	j	80040c9e <find_and_stack+0x18>
	uintptr_t l = (uintptr_t) n->children[0];
80040ccc:	439c                	lw	a5,0(a5)
	l &= ~1UL;
80040cce:	9bf9                	andi	a5,a5,-2
80040cd0:	bfcd                	j	80040cc2 <find_and_stack+0x3c>

80040cd2 <rotate>:
 */
static void rotate(struct rbnode **stack, int stacksz)
{
	CHECK(stacksz >= 2);

	struct rbnode *parent = stack[stacksz - 2];
80040cd2:	00259793          	slli	a5,a1,0x2
{
80040cd6:	7179                	addi	sp,sp,-48
	struct rbnode *parent = stack[stacksz - 2];
80040cd8:	17e1                	addi	a5,a5,-8
{
80040cda:	c85a                	sw	s6,16(sp)
	struct rbnode *parent = stack[stacksz - 2];
80040cdc:	00f50b33          	add	s6,a0,a5
{
80040ce0:	d04a                	sw	s2,32(sp)
	struct rbnode *parent = stack[stacksz - 2];
80040ce2:	000b2903          	lw	s2,0(s6)
	struct rbnode *child = stack[stacksz - 1];
80040ce6:	0791                	addi	a5,a5,4
{
80040ce8:	d226                	sw	s1,36(sp)
	struct rbnode *child = stack[stacksz - 1];
80040cea:	00f504b3          	add	s1,a0,a5
{
80040cee:	d422                	sw	s0,40(sp)
	int side = get_side(parent, child);
80040cf0:	00492783          	lw	a5,4(s2)
	struct rbnode *child = stack[stacksz - 1];
80040cf4:	4080                	lw	s0,0(s1)
{
80040cf6:	cc52                	sw	s4,24(sp)
80040cf8:	c65e                	sw	s7,12(sp)
	return get_child(parent, 1) == child ? 1 : 0;
80040cfa:	40f40a33          	sub	s4,s0,a5
{
80040cfe:	d606                	sw	ra,44(sp)
80040d00:	ce4e                	sw	s3,28(sp)
80040d02:	ca56                	sw	s5,20(sp)
	return get_child(parent, 1) == child ? 1 : 0;
80040d04:	001a3b93          	seqz	s7,s4
	if (side != 0) {
80040d08:	06f41163          	bne	s0,a5,80040d6a <rotate+0x98>
		return n->children[1];
80040d0c:	00442a83          	lw	s5,4(s0)
	struct rbnode *a = get_child(child, side);
	struct rbnode *b = get_child(child, side == 0 ? 1 : 0);
80040d10:	01403a33          	snez	s4,s4
	if (side != 0) {
80040d14:	06f40063          	beq	s0,a5,80040d74 <rotate+0xa2>
		return n->children[1];
80040d18:	00442983          	lw	s3,4(s0)

	if (stacksz >= 3) {
80040d1c:	4789                	li	a5,2
80040d1e:	00b7db63          	bge	a5,a1,80040d34 <rotate+0x62>
		struct rbnode *grandparent = stack[stacksz - 3];
80040d22:	ffcb2503          	lw	a0,-4(s6)

		set_child(grandparent, get_side(grandparent, parent), child);
80040d26:	8622                	mv	a2,s0
	return get_child(parent, 1) == child ? 1 : 0;
80040d28:	414c                	lw	a1,4(a0)
80040d2a:	412585b3          	sub	a1,a1,s2
		set_child(grandparent, get_side(grandparent, parent), child);
80040d2e:	0015b593          	seqz	a1,a1
80040d32:	3791                	jal	80040c76 <set_child>
	}

	set_child(child, side, a);
80040d34:	8656                	mv	a2,s5
80040d36:	85de                	mv	a1,s7
80040d38:	8522                	mv	a0,s0
80040d3a:	3f35                	jal	80040c76 <set_child>
	set_child(child, side == 0 ? 1 : 0, parent);
80040d3c:	864a                	mv	a2,s2
80040d3e:	85d2                	mv	a1,s4
80040d40:	8522                	mv	a0,s0
80040d42:	3f15                	jal	80040c76 <set_child>
	set_child(parent, side, b);
80040d44:	864e                	mv	a2,s3
80040d46:	85de                	mv	a1,s7
80040d48:	854a                	mv	a0,s2
80040d4a:	3735                	jal	80040c76 <set_child>
	stack[stacksz - 2] = child;
	stack[stacksz - 1] = parent;
}
80040d4c:	50b2                	lw	ra,44(sp)
	stack[stacksz - 2] = child;
80040d4e:	008b2023          	sw	s0,0(s6)
}
80040d52:	5422                	lw	s0,40(sp)
	stack[stacksz - 1] = parent;
80040d54:	0124a023          	sw	s2,0(s1)
}
80040d58:	49f2                	lw	s3,28(sp)
80040d5a:	5492                	lw	s1,36(sp)
80040d5c:	5902                	lw	s2,32(sp)
80040d5e:	4a62                	lw	s4,24(sp)
80040d60:	4ad2                	lw	s5,20(sp)
80040d62:	4b42                	lw	s6,16(sp)
80040d64:	4bb2                	lw	s7,12(sp)
80040d66:	6145                	addi	sp,sp,48
80040d68:	8082                	ret
	uintptr_t l = (uintptr_t) n->children[0];
80040d6a:	00042a83          	lw	s5,0(s0)
	l &= ~1UL;
80040d6e:	ffeafa93          	andi	s5,s5,-2
80040d72:	bf79                	j	80040d10 <rotate+0x3e>
	uintptr_t l = (uintptr_t) n->children[0];
80040d74:	00042983          	lw	s3,0(s0)
	l &= ~1UL;
80040d78:	ffe9f993          	andi	s3,s3,-2
80040d7c:	b745                	j	80040d1c <rotate+0x4a>

80040d7e <stack_left_limb>:
 * or the root, so is_left must be false.
 */
static inline struct rbnode *stack_left_limb(struct rbnode *n,
					     struct _rb_foreach *f)
{
	f->top++;
80040d7e:	459c                	lw	a5,8(a1)
	f->stack[f->top] = n;
80040d80:	4198                	lw	a4,0(a1)
	f->top++;
80040d82:	0785                	addi	a5,a5,1
	f->stack[f->top] = n;
80040d84:	00279693          	slli	a3,a5,0x2
	f->top++;
80040d88:	c59c                	sw	a5,8(a1)
	f->stack[f->top] = n;
80040d8a:	9736                	add	a4,a4,a3
80040d8c:	c308                	sw	a0,0(a4)
	f->is_left[f->top] = 0;
80040d8e:	41d8                	lw	a4,4(a1)

	while ((n = get_child(n, 0)) != NULL) {
		f->top++;
		f->stack[f->top] = n;
		f->is_left[f->top] = 1;
80040d90:	4685                	li	a3,1
	f->is_left[f->top] = 0;
80040d92:	97ba                	add	a5,a5,a4
80040d94:	00078023          	sb	zero,0(a5)
	uintptr_t l = (uintptr_t) n->children[0];
80040d98:	4108                	lw	a0,0(a0)
	l &= ~1UL;
80040d9a:	459c                	lw	a5,8(a1)
80040d9c:	4198                	lw	a4,0(a1)
80040d9e:	9979                	andi	a0,a0,-2
	while ((n = get_child(n, 0)) != NULL) {
80040da0:	e509                	bnez	a0,80040daa <stack_left_limb+0x2c>
	}

	return f->stack[f->top];
80040da2:	078a                	slli	a5,a5,0x2
80040da4:	97ba                	add	a5,a5,a4
}
80040da6:	4388                	lw	a0,0(a5)
80040da8:	8082                	ret
		f->top++;
80040daa:	0785                	addi	a5,a5,1
		f->stack[f->top] = n;
80040dac:	00279613          	slli	a2,a5,0x2
		f->top++;
80040db0:	c59c                	sw	a5,8(a1)
		f->stack[f->top] = n;
80040db2:	9732                	add	a4,a4,a2
80040db4:	c308                	sw	a0,0(a4)
		f->is_left[f->top] = 1;
80040db6:	41d8                	lw	a4,4(a1)
80040db8:	97ba                	add	a5,a5,a4
80040dba:	00d78023          	sb	a3,0(a5)
80040dbe:	bfe9                	j	80040d98 <stack_left_limb+0x1a>

80040dc0 <fix_missing_black.part.2>:
static void fix_missing_black(struct rbnode **stack, int stacksz,
80040dc0:	7179                	addi	sp,sp,-48
80040dc2:	c65e                	sw	s7,12(sp)
		struct rbnode *n = stack[stacksz - 1];
80040dc4:	40000bb7          	lui	s7,0x40000
static void fix_missing_black(struct rbnode **stack, int stacksz,
80040dc8:	ce4e                	sw	s3,28(sp)
80040dca:	c85a                	sw	s6,16(sp)
80040dcc:	c462                	sw	s8,8(sp)
80040dce:	c06a                	sw	s10,0(sp)
80040dd0:	d606                	sw	ra,44(sp)
80040dd2:	d422                	sw	s0,40(sp)
80040dd4:	d226                	sw	s1,36(sp)
80040dd6:	d04a                	sw	s2,32(sp)
80040dd8:	cc52                	sw	s4,24(sp)
80040dda:	ca56                	sw	s5,20(sp)
80040ddc:	c266                	sw	s9,4(sp)
80040dde:	8d2a                	mv	s10,a0
80040de0:	89ae                	mv	s3,a1
80040de2:	8b32                	mv	s6,a2
	while (stacksz > 1) {
80040de4:	4c05                	li	s8,1
		struct rbnode *n = stack[stacksz - 1];
80040de6:	1bfd                	addi	s7,s7,-1
	while (stacksz > 1) {
80040de8:	0b3c5063          	bge	s8,s3,80040e88 <fix_missing_black.part.2+0xc8>
		struct rbnode *n = stack[stacksz - 1];
80040dec:	01798a33          	add	s4,s3,s7
80040df0:	0a0a                	slli	s4,s4,0x2
80040df2:	9a6a                	add	s4,s4,s10
		struct rbnode *parent = stack[stacksz - 2];
80040df4:	ffca2483          	lw	s1,-4(s4)
		struct rbnode *n = stack[stacksz - 1];
80040df8:	000a2903          	lw	s2,0(s4)
		int n_side = get_side(parent, n);
80040dfc:	0044ac83          	lw	s9,4(s1)
	return get_child(parent, 1) == child ? 1 : 0;
80040e00:	41990ab3          	sub	s5,s2,s9
80040e04:	001aba93          	seqz	s5,s5
	if (side != 0) {
80040e08:	8466                	mv	s0,s9
80040e0a:	01991463          	bne	s2,s9,80040e12 <fix_missing_black.part.2+0x52>
	uintptr_t l = (uintptr_t) n->children[0];
80040e0e:	4080                	lw	s0,0(s1)
	l &= ~1UL;
80040e10:	9879                	andi	s0,s0,-2
	return ((uintptr_t)n->children[0]) & 1UL;
80040e12:	401c                	lw	a5,0(s0)
80040e14:	8b85                	andi	a5,a5,1
		if (!is_black(sib)) {
80040e16:	e78d                	bnez	a5,80040e40 <fix_missing_black.part.2+0x80>
			rotate(stack, stacksz);
80040e18:	85ce                	mv	a1,s3
			stack[stacksz - 1] = sib;
80040e1a:	008a2023          	sw	s0,0(s4)
			rotate(stack, stacksz);
80040e1e:	856a                	mv	a0,s10
80040e20:	3d4d                	jal	80040cd2 <rotate>
	*p = (*p & ~1UL) | (uint8_t)color;
80040e22:	409c                	lw	a5,0(s1)
			stack[stacksz++] = n;
80040e24:	0985                	addi	s3,s3,1
	*p = (*p & ~1UL) | (uint8_t)color;
80040e26:	9bf9                	andi	a5,a5,-2
80040e28:	c09c                	sw	a5,0(s1)
80040e2a:	401c                	lw	a5,0(s0)
			parent = stack[stacksz - 2];
80040e2c:	000a2483          	lw	s1,0(s4)
	*p = (*p & ~1UL) | (uint8_t)color;
80040e30:	0017e793          	ori	a5,a5,1
80040e34:	c01c                	sw	a5,0(s0)
			stack[stacksz++] = n;
80040e36:	012a2223          	sw	s2,4(s4)
	if (side != 0) {
80040e3a:	05990163          	beq	s2,s9,80040e7c <fix_missing_black.part.2+0xbc>
		return n->children[1];
80040e3e:	40c0                	lw	s0,4(s1)
	uintptr_t l = (uintptr_t) n->children[0];
80040e40:	00042a03          	lw	s4,0(s0)
		return n->children[1];
80040e44:	4058                	lw	a4,4(s0)
	l &= ~1UL;
80040e46:	ffea7a13          	andi	s4,s4,-2
		if ((c0 == NULL || is_black(c0)) && (c1 == NULL ||
80040e4a:	000a0663          	beqz	s4,80040e56 <fix_missing_black.part.2+0x96>
	return ((uintptr_t)n->children[0]) & 1UL;
80040e4e:	000a2783          	lw	a5,0(s4)
80040e52:	8b85                	andi	a5,a5,1
		if ((c0 == NULL || is_black(c0)) && (c1 == NULL ||
80040e54:	cbdd                	beqz	a5,80040f0a <fix_missing_black.part.2+0x14a>
80040e56:	c701                	beqz	a4,80040e5e <fix_missing_black.part.2+0x9e>
	return ((uintptr_t)n->children[0]) & 1UL;
80040e58:	431c                	lw	a5,0(a4)
80040e5a:	8b85                	andi	a5,a5,1
		if ((c0 == NULL || is_black(c0)) && (c1 == NULL ||
80040e5c:	c7b9                	beqz	a5,80040eaa <fix_missing_black.part.2+0xea>
			if (n == null_node) {
80040e5e:	01691663          	bne	s2,s6,80040e6a <fix_missing_black.part.2+0xaa>
				set_child(parent, n_side, NULL);
80040e62:	4601                	li	a2,0
80040e64:	85d6                	mv	a1,s5
80040e66:	8526                	mv	a0,s1
80040e68:	3539                	jal	80040c76 <set_child>
	*p = (*p & ~1UL) | (uint8_t)color;
80040e6a:	401c                	lw	a5,0(s0)
80040e6c:	9bf9                	andi	a5,a5,-2
80040e6e:	c01c                	sw	a5,0(s0)
	return ((uintptr_t)n->children[0]) & 1UL;
80040e70:	409c                	lw	a5,0(s1)
80040e72:	0017f713          	andi	a4,a5,1
			if (is_black(parent)) {
80040e76:	c711                	beqz	a4,80040e82 <fix_missing_black.part.2+0xc2>
				stacksz--;
80040e78:	19fd                	addi	s3,s3,-1
				continue;
80040e7a:	b7bd                	j	80040de8 <fix_missing_black.part.2+0x28>
	uintptr_t l = (uintptr_t) n->children[0];
80040e7c:	4080                	lw	s0,0(s1)
	l &= ~1UL;
80040e7e:	9879                	andi	s0,s0,-2
80040e80:	b7c1                	j	80040e40 <fix_missing_black.part.2+0x80>
	*p = (*p & ~1UL) | (uint8_t)color;
80040e82:	0017e793          	ori	a5,a5,1
80040e86:	c09c                	sw	a5,0(s1)
}
80040e88:	50b2                	lw	ra,44(sp)
80040e8a:	5422                	lw	s0,40(sp)
80040e8c:	5492                	lw	s1,36(sp)
80040e8e:	5902                	lw	s2,32(sp)
80040e90:	49f2                	lw	s3,28(sp)
80040e92:	4a62                	lw	s4,24(sp)
80040e94:	4ad2                	lw	s5,20(sp)
80040e96:	4b42                	lw	s6,16(sp)
80040e98:	4bb2                	lw	s7,12(sp)
80040e9a:	4c22                	lw	s8,8(sp)
80040e9c:	4c92                	lw	s9,4(sp)
80040e9e:	4d02                	lw	s10,0(sp)
80040ea0:	6145                	addi	sp,sp,48
80040ea2:	8082                	ret
	uintptr_t l = (uintptr_t) n->children[0];
80040ea4:	401c                	lw	a5,0(s0)
	l &= ~1UL;
80040ea6:	9bf9                	andi	a5,a5,-2
80040ea8:	a05d                	j	80040f4e <fix_missing_black.part.2+0x18e>
	return (struct rbnode *) l;
80040eaa:	87d2                	mv	a5,s4
	if (side != 0) {
80040eac:	07990363          	beq	s2,s9,80040f12 <fix_missing_black.part.2+0x152>
		return n->children[1];
80040eb0:	87ba                	mv	a5,a4
	return ((uintptr_t)n->children[0]) & 1UL;
80040eb2:	4394                	lw	a3,0(a5)
80040eb4:	8a85                	andi	a3,a3,1
		if (!(outer != NULL && is_red(outer))) {
80040eb6:	eeb9                	bnez	a3,80040f14 <fix_missing_black.part.2+0x154>
	return ((uintptr_t)n->children[0]) & 1UL;
80040eb8:	4098                	lw	a4,0(s1)
	*p = (*p & ~1UL) | (uint8_t)color;
80040eba:	4014                	lw	a3,0(s0)
		rotate(stack, stacksz);
80040ebc:	85ce                	mv	a1,s3
	return ((uintptr_t)n->children[0]) & 1UL;
80040ebe:	8b05                	andi	a4,a4,1
	*p = (*p & ~1UL) | (uint8_t)color;
80040ec0:	9af9                	andi	a3,a3,-2
80040ec2:	8f55                	or	a4,a4,a3
80040ec4:	c018                	sw	a4,0(s0)
80040ec6:	4098                	lw	a4,0(s1)
		rotate(stack, stacksz);
80040ec8:	856a                	mv	a0,s10
	*p = (*p & ~1UL) | (uint8_t)color;
80040eca:	00176713          	ori	a4,a4,1
80040ece:	c098                	sw	a4,0(s1)
80040ed0:	4398                	lw	a4,0(a5)
80040ed2:	00176713          	ori	a4,a4,1
80040ed6:	c398                	sw	a4,0(a5)
		stack[stacksz - 1] = sib;
80040ed8:	00299793          	slli	a5,s3,0x2
80040edc:	97ea                	add	a5,a5,s10
80040ede:	fe87ae23          	sw	s0,-4(a5)
		rotate(stack, stacksz);
80040ee2:	3bc5                	jal	80040cd2 <rotate>
		if (n == null_node) {
80040ee4:	fb6912e3          	bne	s2,s6,80040e88 <fix_missing_black.part.2+0xc8>
}
80040ee8:	5422                	lw	s0,40(sp)
80040eea:	50b2                	lw	ra,44(sp)
80040eec:	5902                	lw	s2,32(sp)
80040eee:	49f2                	lw	s3,28(sp)
80040ef0:	4a62                	lw	s4,24(sp)
80040ef2:	4b42                	lw	s6,16(sp)
80040ef4:	4bb2                	lw	s7,12(sp)
80040ef6:	4c22                	lw	s8,8(sp)
80040ef8:	4c92                	lw	s9,4(sp)
80040efa:	4d02                	lw	s10,0(sp)
			set_child(parent, n_side, NULL);
80040efc:	85d6                	mv	a1,s5
80040efe:	8526                	mv	a0,s1
}
80040f00:	4ad2                	lw	s5,20(sp)
80040f02:	5492                	lw	s1,36(sp)
			set_child(parent, n_side, NULL);
80040f04:	4601                	li	a2,0
}
80040f06:	6145                	addi	sp,sp,48
			set_child(parent, n_side, NULL);
80040f08:	b3bd                	j	80040c76 <set_child>
	return (struct rbnode *) l;
80040f0a:	87d2                	mv	a5,s4
	if (side != 0) {
80040f0c:	fb9903e3          	beq	s2,s9,80040eb2 <fix_missing_black.part.2+0xf2>
		return n->children[1];
80040f10:	87ba                	mv	a5,a4
		if (!(outer != NULL && is_red(outer))) {
80040f12:	f3c5                	bnez	a5,80040eb2 <fix_missing_black.part.2+0xf2>
	if (side != 0) {
80040f14:	01991363          	bne	s2,s9,80040f1a <fix_missing_black.part.2+0x15a>
80040f18:	8a3a                	mv	s4,a4
			stack[stacksz - 1] = sib;
80040f1a:	00299b93          	slli	s7,s3,0x2
80040f1e:	1bf1                	addi	s7,s7,-4
80040f20:	9bea                	add	s7,s7,s10
80040f22:	008ba023          	sw	s0,0(s7) # 40000000 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3ff0bdc0>
			stack[stacksz++] = inner;
80040f26:	014ba223          	sw	s4,4(s7)
			rotate(stack, stacksz);
80040f2a:	00198593          	addi	a1,s3,1
80040f2e:	856a                	mv	a0,s10
80040f30:	334d                	jal	80040cd2 <rotate>
	*p = (*p & ~1UL) | (uint8_t)color;
80040f32:	401c                	lw	a5,0(s0)
80040f34:	9bf9                	andi	a5,a5,-2
80040f36:	c01c                	sw	a5,0(s0)
80040f38:	000a2783          	lw	a5,0(s4)
			sib = stack[stacksz - 2];
80040f3c:	000ba403          	lw	s0,0(s7)
	*p = (*p & ~1UL) | (uint8_t)color;
80040f40:	0017e793          	ori	a5,a5,1
80040f44:	00fa2023          	sw	a5,0(s4)
	if (side != 0) {
80040f48:	f5990ee3          	beq	s2,s9,80040ea4 <fix_missing_black.part.2+0xe4>
		return n->children[1];
80040f4c:	405c                	lw	a5,4(s0)
			stack[stacksz - 2] = n;
80040f4e:	012ba023          	sw	s2,0(s7)
			stacksz--;
80040f52:	b79d                	j	80040eb8 <fix_missing_black.part.2+0xf8>

80040f54 <z_rb_get_minmax>:
	for (n = tree->root; n != NULL && get_child(n, side) != NULL;
80040f54:	4108                	lw	a0,0(a0)
80040f56:	c501                	beqz	a0,80040f5e <z_rb_get_minmax+0xa>
	if (side != 0) {
80040f58:	c591                	beqz	a1,80040f64 <z_rb_get_minmax+0x10>
		return n->children[1];
80040f5a:	415c                	lw	a5,4(a0)
	for (n = tree->root; n != NULL && get_child(n, side) != NULL;
80040f5c:	e391                	bnez	a5,80040f60 <z_rb_get_minmax+0xc>
}
80040f5e:	8082                	ret
80040f60:	853e                	mv	a0,a5
80040f62:	bfd5                	j	80040f56 <z_rb_get_minmax+0x2>
	uintptr_t l = (uintptr_t) n->children[0];
80040f64:	411c                	lw	a5,0(a0)
	l &= ~1UL;
80040f66:	9bf9                	andi	a5,a5,-2
80040f68:	bfd5                	j	80040f5c <z_rb_get_minmax+0x8>

80040f6a <rb_insert>:
{
80040f6a:	7179                	addi	sp,sp,-48
80040f6c:	d422                	sw	s0,40(sp)
80040f6e:	d226                	sw	s1,36(sp)
80040f70:	ce4e                	sw	s3,28(sp)
80040f72:	d606                	sw	ra,44(sp)
80040f74:	d04a                	sw	s2,32(sp)
80040f76:	cc52                	sw	s4,24(sp)
80040f78:	ca56                	sw	s5,20(sp)
80040f7a:	c85a                	sw	s6,16(sp)
80040f7c:	c65e                	sw	s7,12(sp)
80040f7e:	1800                	addi	s0,sp,48
		n->children[0] = (void *) (new | (old & 1UL));
80040f80:	419c                	lw	a5,0(a1)
		n->children[1] = val;
80040f82:	0005a223          	sw	zero,4(a1)
{
80040f86:	89aa                	mv	s3,a0
		n->children[0] = (void *) (new | (old & 1UL));
80040f88:	8b85                	andi	a5,a5,1
80040f8a:	c19c                	sw	a5,0(a1)
	if (tree->root == NULL) {
80040f8c:	411c                	lw	a5,0(a0)
{
80040f8e:	84ae                	mv	s1,a1
	if (tree->root == NULL) {
80040f90:	e795                	bnez	a5,80040fbc <rb_insert+0x52>
		tree->root = node;
80040f92:	00b9a023          	sw	a1,0(s3)
		tree->max_depth = 1;
80040f96:	4785                	li	a5,1
80040f98:	c51c                	sw	a5,8(a0)
	*p = (*p & ~1UL) | (uint8_t)color;
80040f9a:	419c                	lw	a5,0(a1)
80040f9c:	0017e793          	ori	a5,a5,1
80040fa0:	c19c                	sw	a5,0(a1)
}
80040fa2:	fd040113          	addi	sp,s0,-48
80040fa6:	50b2                	lw	ra,44(sp)
80040fa8:	5422                	lw	s0,40(sp)
80040faa:	5492                	lw	s1,36(sp)
80040fac:	5902                	lw	s2,32(sp)
80040fae:	49f2                	lw	s3,28(sp)
80040fb0:	4a62                	lw	s4,24(sp)
80040fb2:	4ad2                	lw	s5,20(sp)
80040fb4:	4b42                	lw	s6,16(sp)
80040fb6:	4bb2                	lw	s7,12(sp)
80040fb8:	6145                	addi	sp,sp,48
80040fba:	8082                	ret
	struct rbnode *stack[tree->max_depth + 1];
80040fbc:	451c                	lw	a5,8(a0)
80040fbe:	8a8a                	mv	s5,sp
80040fc0:	078a                	slli	a5,a5,0x2
80040fc2:	07cd                	addi	a5,a5,19
80040fc4:	9bc1                	andi	a5,a5,-16
80040fc6:	40f10133          	sub	sp,sp,a5
80040fca:	8a0a                	mv	s4,sp
	int stacksz = find_and_stack(tree, node, stack);
80040fcc:	8652                	mv	a2,s4
80040fce:	3965                	jal	80040c86 <find_and_stack>
80040fd0:	00251793          	slli	a5,a0,0x2
80040fd4:	00fa0933          	add	s2,s4,a5
	struct rbnode *parent = stack[stacksz - 1];
80040fd8:	ffc92b83          	lw	s7,-4(s2)
	int side = tree->lessthan_fn(node, parent) ? 0 : 1;
80040fdc:	0049a783          	lw	a5,4(s3)
	int stacksz = find_and_stack(tree, node, stack);
80040fe0:	8b2a                	mv	s6,a0
	int side = tree->lessthan_fn(node, parent) ? 0 : 1;
80040fe2:	85de                	mv	a1,s7
80040fe4:	8526                	mv	a0,s1
80040fe6:	9782                	jalr	a5
80040fe8:	00154593          	xori	a1,a0,1
	set_child(parent, side, node);
80040fec:	8626                	mv	a2,s1
80040fee:	855e                	mv	a0,s7
80040ff0:	0ff5f593          	andi	a1,a1,255
80040ff4:	3149                	jal	80040c76 <set_child>
	*p = (*p & ~1UL) | (uint8_t)color;
80040ff6:	409c                	lw	a5,0(s1)
	stack[stacksz++] = node;
80040ff8:	0b05                	addi	s6,s6,1
80040ffa:	00992023          	sw	s1,0(s2)
	*p = (*p & ~1UL) | (uint8_t)color;
80040ffe:	9bf9                	andi	a5,a5,-2
80041000:	c09c                	sw	a5,0(s1)
	stack[stacksz++] = node;
80041002:	8bda                	mv	s7,s6
80041004:	87ca                	mv	a5,s2
	while (stacksz > 1) {
80041006:	4805                	li	a6,1
80041008:	01784863          	blt	a6,s7,80041018 <rb_insert+0xae>
	set_color(stack[0], BLACK);
8004100c:	000a2703          	lw	a4,0(s4)
	*p = (*p & ~1UL) | (uint8_t)color;
80041010:	431c                	lw	a5,0(a4)
80041012:	0017e793          	ori	a5,a5,1
80041016:	a059                	j	8004109c <rb_insert+0x132>
		struct rbnode *parent = stack[stacksz - 2];
80041018:	ffc7a603          	lw	a2,-4(a5)
	return ((uintptr_t)n->children[0]) & 1UL;
8004101c:	ffc78913          	addi	s2,a5,-4
80041020:	4218                	lw	a4,0(a2)
80041022:	8b05                	andi	a4,a4,1
		if (is_black(parent)) {
80041024:	ef2d                	bnez	a4,8004109e <rb_insert+0x134>
		struct rbnode *grandparent = stack[stacksz - 3];
80041026:	ff87a583          	lw	a1,-8(a5)
		int side = get_side(grandparent, parent);
8004102a:	ff878493          	addi	s1,a5,-8
8004102e:	41d8                	lw	a4,4(a1)
	if (side != 0) {
80041030:	86ba                	mv	a3,a4
80041032:	00e61463          	bne	a2,a4,8004103a <rb_insert+0xd0>
	uintptr_t l = (uintptr_t) n->children[0];
80041036:	4194                	lw	a3,0(a1)
	l &= ~1UL;
80041038:	9af9                	andi	a3,a3,-2
		if ((aunt != NULL) && is_red(aunt)) {
8004103a:	c295                	beqz	a3,8004105e <rb_insert+0xf4>
	return ((uintptr_t)n->children[0]) & 1UL;
8004103c:	4288                	lw	a0,0(a3)
8004103e:	87a6                	mv	a5,s1
80041040:	8905                	andi	a0,a0,1
		if ((aunt != NULL) && is_red(aunt)) {
80041042:	ed11                	bnez	a0,8004105e <rb_insert+0xf4>
	*p = (*p & ~1UL) | (uint8_t)color;
80041044:	4198                	lw	a4,0(a1)
			stacksz -= 2;
80041046:	1bf9                	addi	s7,s7,-2
	*p = (*p & ~1UL) | (uint8_t)color;
80041048:	9b79                	andi	a4,a4,-2
8004104a:	c198                	sw	a4,0(a1)
8004104c:	4218                	lw	a4,0(a2)
8004104e:	00176713          	ori	a4,a4,1
80041052:	c218                	sw	a4,0(a2)
80041054:	4298                	lw	a4,0(a3)
80041056:	00176713          	ori	a4,a4,1
8004105a:	c298                	sw	a4,0(a3)
			continue;
8004105c:	b775                	j	80041008 <rb_insert+0x9e>
		struct rbnode *node = stack[stacksz - 1];
8004105e:	002b9793          	slli	a5,s7,0x2
80041062:	97d2                	add	a5,a5,s4
	return get_child(parent, 1) == child ? 1 : 0;
80041064:	ffc7a783          	lw	a5,-4(a5)
80041068:	4254                	lw	a3,4(a2)
8004106a:	40e60733          	sub	a4,a2,a4
		if (parent_side != side) {
8004106e:	00173713          	seqz	a4,a4
	return get_child(parent, 1) == child ? 1 : 0;
80041072:	8f95                	sub	a5,a5,a3
		if (parent_side != side) {
80041074:	0017b793          	seqz	a5,a5
80041078:	00f70563          	beq	a4,a5,80041082 <rb_insert+0x118>
			rotate(stack, stacksz);
8004107c:	85de                	mv	a1,s7
8004107e:	8552                	mv	a0,s4
80041080:	3989                	jal	80040cd2 <rotate>
		rotate(stack, stacksz - 1);
80041082:	fffb8593          	addi	a1,s7,-1
80041086:	8552                	mv	a0,s4
80041088:	31a9                	jal	80040cd2 <rotate>
		set_color(stack[stacksz - 3], BLACK);
8004108a:	4098                	lw	a4,0(s1)
	*p = (*p & ~1UL) | (uint8_t)color;
8004108c:	431c                	lw	a5,0(a4)
8004108e:	0017e793          	ori	a5,a5,1
80041092:	c31c                	sw	a5,0(a4)
		set_color(stack[stacksz - 2], RED);
80041094:	00092703          	lw	a4,0(s2)
	*p = (*p & ~1UL) | (uint8_t)color;
80041098:	431c                	lw	a5,0(a4)
8004109a:	9bf9                	andi	a5,a5,-2
8004109c:	c31c                	sw	a5,0(a4)
	if (stacksz > tree->max_depth) {
8004109e:	0089a783          	lw	a5,8(s3)
800410a2:	0167d463          	bge	a5,s6,800410aa <rb_insert+0x140>
		tree->max_depth = stacksz;
800410a6:	0169a423          	sw	s6,8(s3)
	tree->root = stack[0];
800410aa:	000a2783          	lw	a5,0(s4)
800410ae:	00f9a023          	sw	a5,0(s3)
	CHECK(is_black(tree->root));
800410b2:	8156                	mv	sp,s5
800410b4:	b5fd                	j	80040fa2 <rb_insert+0x38>

800410b6 <rb_remove>:
{
800410b6:	7179                	addi	sp,sp,-48
800410b8:	d422                	sw	s0,40(sp)
800410ba:	d226                	sw	s1,36(sp)
800410bc:	cc52                	sw	s4,24(sp)
800410be:	c85a                	sw	s6,16(sp)
800410c0:	c65e                	sw	s7,12(sp)
800410c2:	c462                	sw	s8,8(sp)
800410c4:	d606                	sw	ra,44(sp)
800410c6:	d04a                	sw	s2,32(sp)
800410c8:	ce4e                	sw	s3,28(sp)
800410ca:	ca56                	sw	s5,20(sp)
800410cc:	c266                	sw	s9,4(sp)
800410ce:	1800                	addi	s0,sp,48
	struct rbnode *stack[tree->max_depth + 1];
800410d0:	451c                	lw	a5,8(a0)
{
800410d2:	8b8a                	mv	s7,sp
800410d4:	8b2a                	mv	s6,a0
	struct rbnode *stack[tree->max_depth + 1];
800410d6:	078a                	slli	a5,a5,0x2
800410d8:	07cd                	addi	a5,a5,19
800410da:	9bc1                	andi	a5,a5,-16
800410dc:	40f10133          	sub	sp,sp,a5
800410e0:	8a0a                	mv	s4,sp
	int stacksz = find_and_stack(tree, node, stack);
800410e2:	8652                	mv	a2,s4
{
800410e4:	84ae                	mv	s1,a1
	int stacksz = find_and_stack(tree, node, stack);
800410e6:	3645                	jal	80040c86 <find_and_stack>
	if (node != stack[stacksz - 1]) {
800410e8:	00251c13          	slli	s8,a0,0x2
800410ec:	9c52                	add	s8,s8,s4
800410ee:	ffcc2783          	lw	a5,-4(s8)
800410f2:	0c979463          	bne	a5,s1,800411ba <rb_remove+0x104>
	uintptr_t l = (uintptr_t) n->children[0];
800410f6:	0004a903          	lw	s2,0(s1)
800410fa:	89aa                	mv	s3,a0
	l &= ~1UL;
800410fc:	ffe97913          	andi	s2,s2,-2
	if (get_child(node, 0) != NULL && get_child(node, 1) != NULL) {
80041100:	08090963          	beqz	s2,80041192 <rb_remove+0xdc>
80041104:	40dc                	lw	a5,4(s1)
80041106:	c7d1                	beqz	a5,80041192 <rb_remove+0xdc>
		hiparent = stacksz > 1 ? stack[stacksz - 2] : NULL;
80041108:	4785                	li	a5,1
8004110a:	4501                	li	a0,0
8004110c:	0137d463          	bge	a5,s3,80041114 <rb_remove+0x5e>
80041110:	ff8c2503          	lw	a0,-8(s8)
		stack[stacksz++] = node2;
80041114:	012c2023          	sw	s2,0(s8)
80041118:	00198713          	addi	a4,s3,1
		return n->children[1];
8004111c:	00492783          	lw	a5,4(s2)
80041120:	00271a93          	slli	s5,a4,0x2
80041124:	89ba                	mv	s3,a4
			stack[stacksz++] = node2;
80041126:	9ad2                	add	s5,s5,s4
		while (get_child(node2, 1)) {
80041128:	ebcd                	bnez	a5,800411da <rb_remove+0x124>
		loparent = stack[stacksz - 2];
8004112a:	ff8aac83          	lw	s9,-8(s5)
		if (hiparent != NULL) {
8004112e:	c95d                	beqz	a0,800411e4 <rb_remove+0x12e>
	return get_child(parent, 1) == child ? 1 : 0;
80041130:	414c                	lw	a1,4(a0)
			set_child(hiparent, get_side(hiparent, node), node2);
80041132:	864a                	mv	a2,s2
	return get_child(parent, 1) == child ? 1 : 0;
80041134:	8d85                	sub	a1,a1,s1
			set_child(hiparent, get_side(hiparent, node), node2);
80041136:	0015b593          	seqz	a1,a1
8004113a:	3e35                	jal	80040c76 <set_child>
		if (loparent == node) {
8004113c:	0b949763          	bne	s1,s9,800411ea <rb_remove+0x134>
	uintptr_t l = (uintptr_t) n->children[0];
80041140:	00092703          	lw	a4,0(s2)
		n->children[0] = (void *) (new | (old & 1UL));
80041144:	409c                	lw	a5,0(s1)
	l &= ~1UL;
80041146:	9b79                	andi	a4,a4,-2
		n->children[0] = (void *) (new | (old & 1UL));
80041148:	8b85                	andi	a5,a5,1
8004114a:	8fd9                	or	a5,a5,a4
8004114c:	c09c                	sw	a5,0(s1)
8004114e:	00092783          	lw	a5,0(s2)
80041152:	8b85                	andi	a5,a5,1
80041154:	8fc5                	or	a5,a5,s1
80041156:	00f92023          	sw	a5,0(s2)
		return n->children[1];
8004115a:	40dc                	lw	a5,4(s1)
		n->children[1] = val;
8004115c:	00f92223          	sw	a5,4(s2)
		stack[stacksz0 - 1] = stack[stacksz - 1];
80041160:	ffcaa703          	lw	a4,-4(s5)
		tmp = stack[stacksz0 - 1];
80041164:	ffcc2783          	lw	a5,-4(s8)
		n->children[1] = val;
80041168:	0004a223          	sw	zero,4(s1)
		stack[stacksz0 - 1] = stack[stacksz - 1];
8004116c:	feec2e23          	sw	a4,-4(s8)
		stack[stacksz - 1] = tmp;
80041170:	fefaae23          	sw	a5,-4(s5)
	return ((uintptr_t)n->children[0]) & 1UL;
80041174:	4094                	lw	a3,0(s1)
80041176:	00092703          	lw	a4,0(s2)
	*p = (*p & ~1UL) | (uint8_t)color;
8004117a:	ffe6f793          	andi	a5,a3,-2
	return ((uintptr_t)n->children[0]) & 1UL;
8004117e:	8b05                	andi	a4,a4,1
	*p = (*p & ~1UL) | (uint8_t)color;
80041180:	8f5d                	or	a4,a4,a5
80041182:	c098                	sw	a4,0(s1)
80041184:	00092783          	lw	a5,0(s2)
	return ((uintptr_t)n->children[0]) & 1UL;
80041188:	8a85                	andi	a3,a3,1
	*p = (*p & ~1UL) | (uint8_t)color;
8004118a:	9bf9                	andi	a5,a5,-2
8004118c:	8fd5                	or	a5,a5,a3
8004118e:	00f92023          	sw	a5,0(s2)
	uintptr_t l = (uintptr_t) n->children[0];
80041192:	409c                	lw	a5,0(s1)
	l &= ~1UL;
80041194:	ffe7f913          	andi	s2,a5,-2
	if (child == NULL) {
80041198:	00091463          	bnez	s2,800411a0 <rb_remove+0xea>
		return n->children[1];
8004119c:	0044a903          	lw	s2,4(s1)
	if (stacksz < 2) {
800411a0:	4705                	li	a4,1
800411a2:	07374e63          	blt	a4,s3,8004121e <rb_remove+0x168>
		tree->root = child;
800411a6:	012b2023          	sw	s2,0(s6)
		if (child != NULL) {
800411aa:	06090763          	beqz	s2,80041218 <rb_remove+0x162>
	*p = (*p & ~1UL) | (uint8_t)color;
800411ae:	00092783          	lw	a5,0(s2)
800411b2:	0017e793          	ori	a5,a5,1
800411b6:	00f92023          	sw	a5,0(s2)
800411ba:	815e                	mv	sp,s7
}
800411bc:	fd040113          	addi	sp,s0,-48
800411c0:	50b2                	lw	ra,44(sp)
800411c2:	5422                	lw	s0,40(sp)
800411c4:	5492                	lw	s1,36(sp)
800411c6:	5902                	lw	s2,32(sp)
800411c8:	49f2                	lw	s3,28(sp)
800411ca:	4a62                	lw	s4,24(sp)
800411cc:	4ad2                	lw	s5,20(sp)
800411ce:	4b42                	lw	s6,16(sp)
800411d0:	4bb2                	lw	s7,12(sp)
800411d2:	4c22                	lw	s8,8(sp)
800411d4:	4c92                	lw	s9,4(sp)
800411d6:	6145                	addi	sp,sp,48
800411d8:	8082                	ret
			stack[stacksz++] = node2;
800411da:	00faa023          	sw	a5,0(s5)
800411de:	0705                	addi	a4,a4,1
800411e0:	893e                	mv	s2,a5
800411e2:	bf2d                	j	8004111c <rb_remove+0x66>
			tree->root = node2;
800411e4:	012b2023          	sw	s2,0(s6)
800411e8:	bf91                	j	8004113c <rb_remove+0x86>
	return get_child(parent, 1) == child ? 1 : 0;
800411ea:	004ca583          	lw	a1,4(s9)
			set_child(loparent, get_side(loparent, node2), node);
800411ee:	8626                	mv	a2,s1
800411f0:	8566                	mv	a0,s9
	return get_child(parent, 1) == child ? 1 : 0;
800411f2:	412585b3          	sub	a1,a1,s2
			set_child(loparent, get_side(loparent, node2), node);
800411f6:	0015b593          	seqz	a1,a1
800411fa:	3cb5                	jal	80040c76 <set_child>
	uintptr_t l = (uintptr_t) n->children[0];
800411fc:	4098                	lw	a4,0(s1)
800411fe:	00092683          	lw	a3,0(s2)
		n->children[0] = (void *) (new | (old & 1UL));
80041202:	00177793          	andi	a5,a4,1
	l &= ~1UL;
80041206:	9af9                	andi	a3,a3,-2
		n->children[0] = (void *) (new | (old & 1UL));
80041208:	8fd5                	or	a5,a5,a3
8004120a:	c09c                	sw	a5,0(s1)
8004120c:	00092783          	lw	a5,0(s2)
	l &= ~1UL;
80041210:	9b79                	andi	a4,a4,-2
		n->children[0] = (void *) (new | (old & 1UL));
80041212:	8b85                	andi	a5,a5,1
80041214:	8fd9                	or	a5,a5,a4
80041216:	b781                	j	80041156 <rb_remove+0xa0>
			tree->max_depth = 0;
80041218:	000b2423          	sw	zero,8(s6)
8004121c:	bf79                	j	800411ba <rb_remove+0x104>
	struct rbnode *parent = stack[stacksz - 2];
8004121e:	00299a93          	slli	s5,s3,0x2
80041222:	9ad2                	add	s5,s5,s4
80041224:	ff8aa503          	lw	a0,-8(s5)
	if (child == NULL) {
80041228:	02091063          	bnez	s2,80041248 <rb_remove+0x192>
	return ((uintptr_t)n->children[0]) & 1UL;
8004122c:	8b85                	andi	a5,a5,1
8004122e:	8626                	mv	a2,s1
		if (is_black(node)) {
80041230:	e3b9                	bnez	a5,80041276 <rb_remove+0x1c0>
	return get_child(parent, 1) == child ? 1 : 0;
80041232:	414c                	lw	a1,4(a0)
			set_child(parent, get_side(parent, node), NULL);
80041234:	4601                	li	a2,0
	return get_child(parent, 1) == child ? 1 : 0;
80041236:	8d85                	sub	a1,a1,s1
			set_child(parent, get_side(parent, node), NULL);
80041238:	0015b593          	seqz	a1,a1
8004123c:	3c2d                	jal	80040c76 <set_child>
	tree->root = stack[0];
8004123e:	000a2783          	lw	a5,0(s4)
80041242:	00fb2023          	sw	a5,0(s6)
80041246:	bf95                	j	800411ba <rb_remove+0x104>
	return get_child(parent, 1) == child ? 1 : 0;
80041248:	414c                	lw	a1,4(a0)
		set_child(parent, get_side(parent, node), child);
8004124a:	864a                	mv	a2,s2
	return get_child(parent, 1) == child ? 1 : 0;
8004124c:	8d85                	sub	a1,a1,s1
		set_child(parent, get_side(parent, node), child);
8004124e:	0015b593          	seqz	a1,a1
80041252:	3415                	jal	80040c76 <set_child>
	return ((uintptr_t)n->children[0]) & 1UL;
80041254:	409c                	lw	a5,0(s1)
80041256:	8b85                	andi	a5,a5,1
		if (is_red(node) || is_red(child)) {
80041258:	c789                	beqz	a5,80041262 <rb_remove+0x1ac>
	return ((uintptr_t)n->children[0]) & 1UL;
8004125a:	00092783          	lw	a5,0(s2)
8004125e:	8b85                	andi	a5,a5,1
		if (is_red(node) || is_red(child)) {
80041260:	eb81                	bnez	a5,80041270 <rb_remove+0x1ba>
	*p = (*p & ~1UL) | (uint8_t)color;
80041262:	00092783          	lw	a5,0(s2)
80041266:	0017e793          	ori	a5,a5,1
8004126a:	00f92023          	sw	a5,0(s2)
8004126e:	bfc1                	j	8004123e <rb_remove+0x188>
			stack[stacksz - 1] = child;
80041270:	ff2aae23          	sw	s2,-4(s5)
	while (stacksz > 1) {
80041274:	4601                	li	a2,0
80041276:	85ce                	mv	a1,s3
80041278:	8552                	mv	a0,s4
8004127a:	3699                	jal	80040dc0 <fix_missing_black.part.2>
8004127c:	b7c9                	j	8004123e <rb_remove+0x188>

8004127e <z_rb_foreach_next>:
 */
struct rbnode *z_rb_foreach_next(struct rbtree *tree, struct _rb_foreach *f)
{
	struct rbnode *n;

	if (tree->root == NULL) {
8004127e:	4108                	lw	a0,0(a0)
{
80041280:	87ae                	mv	a5,a1
	if (tree->root == NULL) {
80041282:	e119                	bnez	a0,80041288 <z_rb_foreach_next+0xa>
		return NULL;
80041284:	4501                	li	a0,0
80041286:	8082                	ret
	}

	/* Initialization condition, pick the leftmost child of the
	 * root as our first node, initializing the stack on the way.
	 */
	if (f->top == -1) {
80041288:	4594                	lw	a3,8(a1)
8004128a:	577d                	li	a4,-1
8004128c:	00e69363          	bne	a3,a4,80041292 <z_rb_foreach_next+0x14>
	/* The next child from a given node is the leftmost child of
	 * it's right subtree if it has a right child
	 */
	n = get_child(f->stack[f->top], 1);
	if (n != NULL) {
		return stack_left_limb(n, f);
80041290:	b4fd                	j	80040d7e <stack_left_limb>
	n = get_child(f->stack[f->top], 1);
80041292:	4190                	lw	a2,0(a1)
80041294:	00269713          	slli	a4,a3,0x2
80041298:	9732                	add	a4,a4,a2
		return n->children[1];
8004129a:	4308                	lw	a0,0(a4)
8004129c:	4148                	lw	a0,4(a0)
	if (n != NULL) {
8004129e:	f96d                	bnez	a0,80041290 <z_rb_foreach_next+0x12>
	/* Otherwise if the node is a left child of its parent, the
	 * next node is the parent (note that the root is stacked
	 * above with is_left set to 0, so this condition still works
	 * even if node has no parent).
	 */
	if (f->is_left[f->top] != 0) {
800412a0:	41cc                	lw	a1,4(a1)
800412a2:	00d58533          	add	a0,a1,a3
800412a6:	00054503          	lbu	a0,0(a0)
800412aa:	c519                	beqz	a0,800412b8 <z_rb_foreach_next+0x3a>
		return f->stack[--f->top];
800412ac:	16fd                	addi	a3,a3,-1
800412ae:	c794                	sw	a3,8(a5)
800412b0:	ffc72503          	lw	a0,-4(a4)
800412b4:	8082                	ret
	/* If we had no left tree and are a right child then our
	 * parent was already walked, so walk up the stack looking for
	 * a left child (whose parent is unwalked, and thus next).
	 */
	while ((f->top > 0) && (f->is_left[f->top] == 0)) {
		f->top--;
800412b6:	c798                	sw	a4,8(a5)
	while ((f->top > 0) && (f->is_left[f->top] == 0)) {
800412b8:	4794                	lw	a3,8(a5)
800412ba:	fff68713          	addi	a4,a3,-1
800412be:	00d05663          	blez	a3,800412ca <z_rb_foreach_next+0x4c>
800412c2:	96ae                	add	a3,a3,a1
800412c4:	0006c683          	lbu	a3,0(a3)
800412c8:	d6fd                	beqz	a3,800412b6 <z_rb_foreach_next+0x38>
	}

	f->top--;
800412ca:	c798                	sw	a4,8(a5)
	return f->top >= 0 ? f->stack[f->top] : NULL;
800412cc:	fa074ce3          	bltz	a4,80041284 <z_rb_foreach_next+0x6>
800412d0:	070a                	slli	a4,a4,0x2
800412d2:	9732                	add	a4,a4,a2
800412d4:	4308                	lw	a0,0(a4)
}
800412d6:	8082                	ret

800412d8 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
800412d8:	1141                	addi	sp,sp,-16
800412da:	87aa                	mv	a5,a0
800412dc:	852e                	mv	a0,a1
800412de:	85b2                	mv	a1,a2
	entry(p1, p2, p3);
800412e0:	8636                	mv	a2,a3
{
800412e2:	c606                	sw	ra,12(sp)
	entry(p1, p2, p3);
800412e4:	9782                	jalr	a5
800412e6:	1ea020ef          	jal	ra,800434d0 <z_impl_k_current_get>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
800412ea:	532020ef          	jal	ra,8004381c <z_impl_k_thread_abort>

800412ee <z_arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
800412ee:	4501                	li	a0,0
800412f0:	8082                	ret

800412f2 <print_err>:
{
	return _char_out;
}

static void print_err(out_func_t out, void *ctx)
{
800412f2:	1141                	addi	sp,sp,-16
800412f4:	c422                	sw	s0,8(sp)
800412f6:	842a                	mv	s0,a0
	out('E', ctx);
800412f8:	04500513          	li	a0,69
{
800412fc:	c606                	sw	ra,12(sp)
800412fe:	c226                	sw	s1,4(sp)
80041300:	84ae                	mv	s1,a1
	out('E', ctx);
80041302:	9402                	jalr	s0
	out('R', ctx);
80041304:	85a6                	mv	a1,s1
80041306:	05200513          	li	a0,82
8004130a:	9402                	jalr	s0
	out('R', ctx);
8004130c:	8322                	mv	t1,s0
}
8004130e:	4422                	lw	s0,8(sp)
80041310:	40b2                	lw	ra,12(sp)
	out('R', ctx);
80041312:	85a6                	mv	a1,s1
}
80041314:	4492                	lw	s1,4(sp)
	out('R', ctx);
80041316:	05200513          	li	a0,82
}
8004131a:	0141                	addi	sp,sp,16
	out('R', ctx);
8004131c:	8302                	jr	t1

8004131e <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
8004131e:	419c                	lw	a5,0(a1)
80041320:	0785                	addi	a5,a5,1
80041322:	c19c                	sw	a5,0(a1)
	return _char_out(c);
80041324:	800457b7          	lui	a5,0x80045
80041328:	d4c7a303          	lw	t1,-692(a5) # 80044d4c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d4d>
8004132c:	8302                	jr	t1

8004132e <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
8004132e:	715d                	addi	sp,sp,-80
80041330:	c4a2                	sw	s0,72(sp)
80041332:	de4e                	sw	s3,60(sp)
80041334:	dc52                	sw	s4,56(sp)
80041336:	da56                	sw	s5,52(sp)
80041338:	d85a                	sw	s6,48(sp)
8004133a:	c686                	sw	ra,76(sp)
8004133c:	c2a6                	sw	s1,68(sp)
8004133e:	c0ca                	sw	s2,64(sp)
80041340:	d65e                	sw	s7,44(sp)
80041342:	d462                	sw	s8,40(sp)
80041344:	d266                	sw	s9,36(sp)
80041346:	d06a                	sw	s10,32(sp)
80041348:	ce6e                	sw	s11,28(sp)
8004134a:	8a2a                	mv	s4,a0
8004134c:	8aae                	mv	s5,a1
8004134e:	89b2                	mv	s3,a2
80041350:	8b36                	mv	s6,a3
80041352:	4405                	li	s0,1
80041354:	00e05363          	blez	a4,8004135a <_printk_dec_ulong+0x2c>
80041358:	843a                	mv	s0,a4
8004135a:	4785                	li	a5,1
8004135c:	02000c13          	li	s8,32
80041360:	00fb1463          	bne	s6,a5,80041368 <_printk_dec_ulong+0x3a>
80041364:	03000c13          	li	s8,48
80041368:	3b9ad4b7          	lui	s1,0x3b9ad
8004136c:	4905                	li	s2,1
8004136e:	4ca9                	li	s9,10
80041370:	4701                	li	a4,0
80041372:	9ff48493          	addi	s1,s1,-1537 # 3b9ac9ff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3b8b87bf>
		if (found_largest_digit != 0 || remainder > pos) {
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
			digits++;
		} else if (remaining <= min_width
				&& padding < PAD_SPACE_AFTER) {
80041376:	4d89                	li	s11,2
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= (pos + 1);
		pos /= 10;
80041378:	4d29                	li	s10,10
		if (found_largest_digit != 0 || remainder > pos) {
8004137a:	00148b93          	addi	s7,s1,1
8004137e:	e319                	bnez	a4,80041384 <_printk_dec_ulong+0x56>
80041380:	0534fa63          	bgeu	s1,s3,800413d4 <_printk_dec_ulong+0xa6>
			out((int)((remainder / (pos + 1)) + 48), ctx);
80041384:	0379d533          	divu	a0,s3,s7
80041388:	85d6                	mv	a1,s5
			digits++;
8004138a:	0905                	addi	s2,s2,1
			out((int)((remainder / (pos + 1)) + 48), ctx);
8004138c:	03050513          	addi	a0,a0,48
80041390:	9a02                	jalr	s4
			found_largest_digit = 1;
80041392:	4705                	li	a4,1
		remaining--;
80041394:	1cfd                	addi	s9,s9,-1
	while (pos >= 9) {
80041396:	4785                	li	a5,1
		remainder %= (pos + 1);
80041398:	0379f9b3          	remu	s3,s3,s7
		pos /= 10;
8004139c:	03a4d4b3          	divu	s1,s1,s10
	while (pos >= 9) {
800413a0:	fcfc9de3          	bne	s9,a5,8004137a <_printk_dec_ulong+0x4c>
	}
	out((int)(remainder + 48), ctx);
800413a4:	85d6                	mv	a1,s5
800413a6:	03098513          	addi	a0,s3,48
800413aa:	9a02                	jalr	s4

	if (padding == PAD_SPACE_AFTER) {
800413ac:	478d                	li	a5,3
		remaining = min_width - digits;
800413ae:	41240433          	sub	s0,s0,s2
	if (padding == PAD_SPACE_AFTER) {
800413b2:	04fb0163          	beq	s6,a5,800413f4 <_printk_dec_ulong+0xc6>
		while (remaining-- > 0) {
			out(' ', ctx);
		}
	}
}
800413b6:	40b6                	lw	ra,76(sp)
800413b8:	4426                	lw	s0,72(sp)
800413ba:	4496                	lw	s1,68(sp)
800413bc:	4906                	lw	s2,64(sp)
800413be:	59f2                	lw	s3,60(sp)
800413c0:	5a62                	lw	s4,56(sp)
800413c2:	5ad2                	lw	s5,52(sp)
800413c4:	5b42                	lw	s6,48(sp)
800413c6:	5bb2                	lw	s7,44(sp)
800413c8:	5c22                	lw	s8,40(sp)
800413ca:	5c92                	lw	s9,36(sp)
800413cc:	5d02                	lw	s10,32(sp)
800413ce:	4df2                	lw	s11,28(sp)
800413d0:	6161                	addi	sp,sp,80
800413d2:	8082                	ret
		} else if (remaining <= min_width
800413d4:	fd9440e3          	blt	s0,s9,80041394 <_printk_dec_ulong+0x66>
				&& padding < PAD_SPACE_AFTER) {
800413d8:	fb6deee3          	bltu	s11,s6,80041394 <_printk_dec_ulong+0x66>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
800413dc:	85d6                	mv	a1,s5
800413de:	8562                	mv	a0,s8
800413e0:	c63a                	sw	a4,12(sp)
800413e2:	9a02                	jalr	s4
			digits++;
800413e4:	0905                	addi	s2,s2,1
800413e6:	4732                	lw	a4,12(sp)
800413e8:	b775                	j	80041394 <_printk_dec_ulong+0x66>
			out(' ', ctx);
800413ea:	85d6                	mv	a1,s5
800413ec:	02000513          	li	a0,32
800413f0:	9a02                	jalr	s4
800413f2:	147d                	addi	s0,s0,-1
		while (remaining-- > 0) {
800413f4:	fe804be3          	bgtz	s0,800413ea <_printk_dec_ulong+0xbc>
800413f8:	bf7d                	j	800413b6 <_printk_dec_ulong+0x88>

800413fa <__printk_hook_install>:
	_char_out = fn;
800413fa:	800457b7          	lui	a5,0x80045
800413fe:	d4a7a623          	sw	a0,-692(a5) # 80044d4c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d4d>
}
80041402:	8082                	ret

80041404 <z_vprintk>:
{
80041404:	715d                	addi	sp,sp,-80
80041406:	c4a2                	sw	s0,72(sp)
80041408:	c2a6                	sw	s1,68(sp)
8004140a:	c0ca                	sw	s2,64(sp)
8004140c:	de4e                	sw	s3,60(sp)
8004140e:	dc52                	sw	s4,56(sp)
80041410:	da56                	sw	s5,52(sp)
80041412:	d266                	sw	s9,36(sp)
80041414:	d06a                	sw	s10,32(sp)
80041416:	ce6e                	sw	s11,28(sp)
80041418:	c686                	sw	ra,76(sp)
8004141a:	d85a                	sw	s6,48(sp)
8004141c:	d65e                	sw	s7,44(sp)
8004141e:	d462                	sw	s8,40(sp)
80041420:	842a                	mv	s0,a0
80041422:	84ae                	mv	s1,a1
80041424:	8ab2                	mv	s5,a2
80041426:	8d36                	mv	s10,a3
	int long_ctr = 0;
80041428:	4a01                	li	s4,0
	int min_width = -1;
8004142a:	597d                	li	s2,-1
	enum pad_type padding = PAD_NONE;
8004142c:	4981                	li	s3,0
	int might_format = 0; /* 1 if encountered a '%' */
8004142e:	4c81                	li	s9,0
					if (lld > INT32_MAX ||
80041430:	80000db7          	lui	s11,0x80000
	while (*fmt) {
80041434:	000ac503          	lbu	a0,0(s5)
80041438:	e105                	bnez	a0,80041458 <z_vprintk+0x54>
}
8004143a:	40b6                	lw	ra,76(sp)
8004143c:	4426                	lw	s0,72(sp)
8004143e:	4496                	lw	s1,68(sp)
80041440:	4906                	lw	s2,64(sp)
80041442:	59f2                	lw	s3,60(sp)
80041444:	5a62                	lw	s4,56(sp)
80041446:	5ad2                	lw	s5,52(sp)
80041448:	5b42                	lw	s6,48(sp)
8004144a:	5bb2                	lw	s7,44(sp)
8004144c:	5c22                	lw	s8,40(sp)
8004144e:	5c92                	lw	s9,36(sp)
80041450:	5d02                	lw	s10,32(sp)
80041452:	4df2                	lw	s11,28(sp)
80041454:	6161                	addi	sp,sp,80
80041456:	8082                	ret
		if (!might_format) {
80041458:	000c9a63          	bnez	s9,8004146c <z_vprintk+0x68>
			if (*fmt != '%') {
8004145c:	02500693          	li	a3,37
80041460:	28d50463          	beq	a0,a3,800416e8 <z_vprintk+0x2e4>
				out((int)*fmt, ctx);
80041464:	85a6                	mv	a1,s1
80041466:	9402                	jalr	s0
		++fmt;
80041468:	0a85                	addi	s5,s5,1
8004146a:	b7e9                	j	80041434 <z_vprintk+0x30>
			switch (*fmt) {
8004146c:	06400693          	li	a3,100
80041470:	0ed50a63          	beq	a0,a3,80041564 <z_vprintk+0x160>
80041474:	04a6eb63          	bltu	a3,a0,800414ca <z_vprintk+0xc6>
80041478:	03900693          	li	a3,57
8004147c:	02a6e763          	bltu	a3,a0,800414aa <z_vprintk+0xa6>
80041480:	03100693          	li	a3,49
80041484:	0cd57563          	bgeu	a0,a3,8004154e <z_vprintk+0x14a>
80041488:	02d00693          	li	a3,45
8004148c:	26d50363          	beq	a0,a3,800416f2 <z_vprintk+0x2ee>
80041490:	03000793          	li	a5,48
80041494:	0af50363          	beq	a0,a5,8004153a <z_vprintk+0x136>
80041498:	02500713          	li	a4,37
8004149c:	00e51f63          	bne	a0,a4,800414ba <z_vprintk+0xb6>
				out((int)'%', ctx);
800414a0:	85a6                	mv	a1,s1
800414a2:	02500513          	li	a0,37
				out((int)*fmt, ctx);
800414a6:	9402                	jalr	s0
				break;
800414a8:	aa01                	j	800415b8 <z_vprintk+0x1b4>
			switch (*fmt) {
800414aa:	05800693          	li	a3,88
800414ae:	14d50a63          	beq	a0,a3,80041602 <z_vprintk+0x1fe>
800414b2:	06300713          	li	a4,99
800414b6:	22e50263          	beq	a0,a4,800416da <z_vprintk+0x2d6>
				out((int)'%', ctx);
800414ba:	85a6                	mv	a1,s1
800414bc:	02500513          	li	a0,37
800414c0:	9402                	jalr	s0
				out((int)*fmt, ctx);
800414c2:	85a6                	mv	a1,s1
800414c4:	000ac503          	lbu	a0,0(s5)
800414c8:	bff9                	j	800414a6 <z_vprintk+0xa2>
			switch (*fmt) {
800414ca:	07000693          	li	a3,112
800414ce:	12d50063          	beq	a0,a3,800415ee <z_vprintk+0x1ea>
800414d2:	00a6ef63          	bltu	a3,a0,800414f0 <z_vprintk+0xec>
800414d6:	06900693          	li	a3,105
800414da:	08d50563          	beq	a0,a3,80041564 <z_vprintk+0x160>
800414de:	06c00693          	li	a3,108
800414e2:	06d50f63          	beq	a0,a3,80041560 <z_vprintk+0x15c>
800414e6:	06800693          	li	a3,104
800414ea:	f6d50fe3          	beq	a0,a3,80041468 <z_vprintk+0x64>
800414ee:	b7f1                	j	800414ba <z_vprintk+0xb6>
800414f0:	07500693          	li	a3,117
800414f4:	0cd50463          	beq	a0,a3,800415bc <z_vprintk+0x1b8>
800414f8:	02a6ea63          	bltu	a3,a0,8004152c <z_vprintk+0x128>
800414fc:	07300713          	li	a4,115
80041500:	fae51de3          	bne	a0,a4,800414ba <z_vprintk+0xb6>
				char *s = va_arg(ap, char *);
80041504:	000d2c03          	lw	s8,0(s10)
80041508:	004d0b13          	addi	s6,s10,4
8004150c:	8be2                	mv	s7,s8
				while (*s)
8004150e:	000bc503          	lbu	a0,0(s7)
80041512:	1a051a63          	bnez	a0,800416c6 <z_vprintk+0x2c2>
				if (padding == PAD_SPACE_AFTER) {
80041516:	478d                	li	a5,3
80041518:	00f99863          	bne	s3,a5,80041528 <z_vprintk+0x124>
					int remaining = min_width - (s - start);
8004151c:	418b8bb3          	sub	s7,s7,s8
80041520:	41790bb3          	sub	s7,s2,s7
					while (remaining-- > 0) {
80041524:	1b704563          	bgtz	s7,800416ce <z_vprintk+0x2ca>
				char *s = va_arg(ap, char *);
80041528:	8d5a                	mv	s10,s6
8004152a:	a079                	j	800415b8 <z_vprintk+0x1b4>
			switch (*fmt) {
8004152c:	07800693          	li	a3,120
80041530:	0cd50963          	beq	a0,a3,80041602 <z_vprintk+0x1fe>
80041534:	07a00693          	li	a3,122
80041538:	bf4d                	j	800414ea <z_vprintk+0xe6>
				if (min_width < 0 && padding == PAD_NONE) {
8004153a:	00095c63          	bgez	s2,80041552 <z_vprintk+0x14e>
8004153e:	1a098c63          	beqz	s3,800416f6 <z_vprintk+0x2f2>
					min_width = *fmt - '0';
80041542:	fd050913          	addi	s2,a0,-48
				if (padding == PAD_NONE) {
80041546:	f20991e3          	bnez	s3,80041468 <z_vprintk+0x64>
					padding = PAD_SPACE_BEFORE;
8004154a:	4989                	li	s3,2
8004154c:	bf31                	j	80041468 <z_vprintk+0x64>
				if (min_width < 0) {
8004154e:	fe094ae3          	bltz	s2,80041542 <z_vprintk+0x13e>
					min_width = 10 * min_width + *fmt - '0';
80041552:	46a9                	li	a3,10
80041554:	02d90933          	mul	s2,s2,a3
80041558:	fd090913          	addi	s2,s2,-48
8004155c:	992a                	add	s2,s2,a0
8004155e:	b7e5                	j	80041546 <z_vprintk+0x142>
				long_ctr++;
80041560:	0a05                	addi	s4,s4,1
80041562:	b719                	j	80041468 <z_vprintk+0x64>
				if (long_ctr == 0) {
80041564:	020a1663          	bnez	s4,80041590 <z_vprintk+0x18c>
					long ld = va_arg(ap, long);
80041568:	000d2603          	lw	a2,0(s10)
8004156c:	0d11                	addi	s10,s10,4
				if (d < 0) {
8004156e:	00065b63          	bgez	a2,80041584 <z_vprintk+0x180>
					out((int)'-', ctx);
80041572:	85a6                	mv	a1,s1
80041574:	02d00513          	li	a0,45
80041578:	c032                	sw	a2,0(sp)
8004157a:	9402                	jalr	s0
					d = -d;
8004157c:	4602                	lw	a2,0(sp)
					min_width--;
8004157e:	197d                	addi	s2,s2,-1
					d = -d;
80041580:	40c00633          	neg	a2,a2
				_printk_dec_ulong(out, ctx, u, padding,
80041584:	874a                	mv	a4,s2
80041586:	86ce                	mv	a3,s3
80041588:	85a6                	mv	a1,s1
8004158a:	8522                	mv	a0,s0
8004158c:	334d                	jal	8004132e <_printk_dec_ulong>
				break;
8004158e:	a02d                	j	800415b8 <z_vprintk+0x1b4>
				} else if (long_ctr == 1) {
80041590:	4705                	li	a4,1
80041592:	fcea0be3          	beq	s4,a4,80041568 <z_vprintk+0x164>
					long long lld = va_arg(ap, long long);
80041596:	007d0793          	addi	a5,s10,7
8004159a:	ff87f713          	andi	a4,a5,-8
8004159e:	4310                	lw	a2,0(a4)
800415a0:	4354                	lw	a3,4(a4)
800415a2:	00870d13          	addi	s10,a4,8
					if (lld > INT32_MAX ||
800415a6:	01b60733          	add	a4,a2,s11
800415aa:	00c73733          	sltu	a4,a4,a2
800415ae:	9736                	add	a4,a4,a3
800415b0:	df5d                	beqz	a4,8004156e <z_vprintk+0x16a>
						print_err(out, ctx);
800415b2:	85a6                	mv	a1,s1
800415b4:	8522                	mv	a0,s0
800415b6:	3b35                	jal	800412f2 <print_err>
			might_format = 0;
800415b8:	4c81                	li	s9,0
800415ba:	b57d                	j	80041468 <z_vprintk+0x64>
				if (long_ctr == 0) {
800415bc:	000a1663          	bnez	s4,800415c8 <z_vprintk+0x1c4>
					long lu = va_arg(ap, unsigned long);
800415c0:	000d2603          	lw	a2,0(s10)
800415c4:	0d11                	addi	s10,s10,4
800415c6:	bf7d                	j	80041584 <z_vprintk+0x180>
				} else if (long_ctr == 1) {
800415c8:	4705                	li	a4,1
800415ca:	feea0be3          	beq	s4,a4,800415c0 <z_vprintk+0x1bc>
					unsigned long long llu =
800415ce:	007d0793          	addi	a5,s10,7
800415d2:	ff87f713          	andi	a4,a5,-8
800415d6:	00870d13          	addi	s10,a4,8
800415da:	4310                	lw	a2,0(a4)
800415dc:	4358                	lw	a4,4(a4)
					if (llu > INT32_MAX) {
800415de:	fb71                	bnez	a4,800415b2 <z_vprintk+0x1ae>
800415e0:	800007b7          	lui	a5,0x80000
800415e4:	fff7c793          	not	a5,a5
800415e8:	f8c7fee3          	bgeu	a5,a2,80041584 <z_vprintk+0x180>
800415ec:	b7d9                	j	800415b2 <z_vprintk+0x1ae>
				  out('0', ctx);
800415ee:	85a6                	mv	a1,s1
800415f0:	03000513          	li	a0,48
800415f4:	9402                	jalr	s0
				  out('x', ctx);
800415f6:	85a6                	mv	a1,s1
800415f8:	07800513          	li	a0,120
800415fc:	9402                	jalr	s0
				  min_width = 8;
800415fe:	4921                	li	s2,8
				  padding = PAD_ZERO_BEFORE;
80041600:	4985                	li	s3,1
				if (long_ctr < 2) {
80041602:	4685                	li	a3,1
80041604:	0746c663          	blt	a3,s4,80041670 <z_vprintk+0x26c>
					x = va_arg(ap, unsigned long);
80041608:	000d2783          	lw	a5,0(s10)
8004160c:	c402                	sw	zero,8(sp)
8004160e:	0d11                	addi	s10,s10,4
80041610:	c23e                	sw	a5,4(sp)
	int remaining = 16; /* 16 digits max */
80041612:	4c41                	li	s8,16
	int digits = 0;
80041614:	4b81                	li	s7,0
	int found_largest_digit = 0;
80041616:	c002                	sw	zero,0(sp)
	int size = sizeof(num) * 2;
80041618:	48c1                	li	a7,16
		char nibble = (num >> ((size - 1) << 2) & 0xf);
8004161a:	4512                	lw	a0,4(sp)
8004161c:	45a2                	lw	a1,8(sp)
8004161e:	fff88b13          	addi	s6,a7,-1
80041622:	002b1613          	slli	a2,s6,0x2
80041626:	c646                	sw	a7,12(sp)
80041628:	be9fe0ef          	jal	ra,80040210 <__lshrdi3>
8004162c:	893d                	andi	a0,a0,15
		if (nibble != 0 || found_largest_digit != 0 || size == 1) {
8004162e:	ed39                	bnez	a0,8004168c <z_vprintk+0x288>
80041630:	4782                	lw	a5,0(sp)
			nibble += nibble > 9 ? 87 : 48;
80041632:	03000693          	li	a3,48
		if (nibble != 0 || found_largest_digit != 0 || size == 1) {
80041636:	e789                	bnez	a5,80041640 <z_vprintk+0x23c>
80041638:	48b2                	lw	a7,12(sp)
8004163a:	4785                	li	a5,1
8004163c:	06f89063          	bne	a7,a5,8004169c <z_vprintk+0x298>
			nibble += nibble > 9 ? 87 : 48;
80041640:	9536                	add	a0,a0,a3
			out((int)nibble, ctx);
80041642:	0562                	slli	a0,a0,0x18
80041644:	85a6                	mv	a1,s1
80041646:	8561                	srai	a0,a0,0x18
80041648:	9402                	jalr	s0
			digits++;
8004164a:	0b85                	addi	s7,s7,1
	for (; size != 0; size--) {
8004164c:	020b1d63          	bnez	s6,80041686 <z_vprintk+0x282>
	if (padding == PAD_SPACE_AFTER) {
80041650:	468d                	li	a3,3
			might_format = 0;
80041652:	4c81                	li	s9,0
	if (padding == PAD_SPACE_AFTER) {
80041654:	e0d99ae3          	bne	s3,a3,80041468 <z_vprintk+0x64>
		remaining = min_width * 2 - digits;
80041658:	00191713          	slli	a4,s2,0x1
8004165c:	41770bb3          	sub	s7,a4,s7
		while (remaining-- > 0) {
80041660:	f5705ce3          	blez	s7,800415b8 <z_vprintk+0x1b4>
			out(' ', ctx);
80041664:	85a6                	mv	a1,s1
80041666:	02000513          	li	a0,32
8004166a:	9402                	jalr	s0
8004166c:	1bfd                	addi	s7,s7,-1
8004166e:	bfcd                	j	80041660 <z_vprintk+0x25c>
					x = va_arg(ap, unsigned long long);
80041670:	007d0793          	addi	a5,s10,7
80041674:	ff87f693          	andi	a3,a5,-8
80041678:	429c                	lw	a5,0(a3)
8004167a:	00868d13          	addi	s10,a3,8
8004167e:	c23e                	sw	a5,4(sp)
80041680:	42dc                	lw	a5,4(a3)
80041682:	c43e                	sw	a5,8(sp)
80041684:	b779                	j	80041612 <z_vprintk+0x20e>
			found_largest_digit = 1;
80041686:	c066                	sw	s9,0(sp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
80041688:	88da                	mv	a7,s6
8004168a:	bf41                	j	8004161a <z_vprintk+0x216>
			nibble += nibble > 9 ? 87 : 48;
8004168c:	47a5                	li	a5,9
8004168e:	05700693          	li	a3,87
80041692:	faa7e7e3          	bltu	a5,a0,80041640 <z_vprintk+0x23c>
80041696:	03000693          	li	a3,48
8004169a:	b75d                	j	80041640 <z_vprintk+0x23c>
		if (remaining-- <= min_width) {
8004169c:	fffc0793          	addi	a5,s8,-1
800416a0:	c63e                	sw	a5,12(sp)
800416a2:	01894963          	blt	s2,s8,800416b4 <z_vprintk+0x2b0>
			if (padding == PAD_ZERO_BEFORE) {
800416a6:	4785                	li	a5,1
800416a8:	00f99863          	bne	s3,a5,800416b8 <z_vprintk+0x2b4>
				out('0', ctx);
800416ac:	85a6                	mv	a1,s1
800416ae:	03000513          	li	a0,48
				out(' ', ctx);
800416b2:	9402                	jalr	s0
					x = va_arg(ap, unsigned long);
800416b4:	4c32                	lw	s8,12(sp)
800416b6:	bfc9                	j	80041688 <z_vprintk+0x284>
			} else if (padding == PAD_SPACE_BEFORE) {
800416b8:	4789                	li	a5,2
800416ba:	fef99de3          	bne	s3,a5,800416b4 <z_vprintk+0x2b0>
				out(' ', ctx);
800416be:	85a6                	mv	a1,s1
800416c0:	02000513          	li	a0,32
800416c4:	b7fd                	j	800416b2 <z_vprintk+0x2ae>
					out((int)(*s++), ctx);
800416c6:	85a6                	mv	a1,s1
800416c8:	0b85                	addi	s7,s7,1
800416ca:	9402                	jalr	s0
800416cc:	b589                	j	8004150e <z_vprintk+0x10a>
						out(' ', ctx);
800416ce:	85a6                	mv	a1,s1
800416d0:	02000513          	li	a0,32
800416d4:	9402                	jalr	s0
800416d6:	1bfd                	addi	s7,s7,-1
800416d8:	b5b1                	j	80041524 <z_vprintk+0x120>
				out(c, ctx);
800416da:	000d2503          	lw	a0,0(s10)
800416de:	85a6                	mv	a1,s1
				int c = va_arg(ap, int);
800416e0:	004d0b13          	addi	s6,s10,4
				out(c, ctx);
800416e4:	9402                	jalr	s0
				break;
800416e6:	b589                	j	80041528 <z_vprintk+0x124>
				long_ctr = 0;
800416e8:	4a01                	li	s4,0
				min_width = -1;
800416ea:	597d                	li	s2,-1
				padding = PAD_NONE;
800416ec:	4981                	li	s3,0
				might_format = 1;
800416ee:	4c85                	li	s9,1
800416f0:	bba5                	j	80041468 <z_vprintk+0x64>
				padding = PAD_SPACE_AFTER;
800416f2:	498d                	li	s3,3
800416f4:	bb95                	j	80041468 <z_vprintk+0x64>
					padding = PAD_ZERO_BEFORE;
800416f6:	4985                	li	s3,1
800416f8:	bb85                	j	80041468 <z_vprintk+0x64>

800416fa <vprintk>:
{
800416fa:	1101                	addi	sp,sp,-32
	z_vprintk(char_out, &ctx, fmt, ap);
800416fc:	862a                	mv	a2,a0
800416fe:	80041537          	lui	a0,0x80041
80041702:	86ae                	mv	a3,a1
80041704:	31e50513          	addi	a0,a0,798 # 8004131e <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004131f>
80041708:	006c                	addi	a1,sp,12
{
8004170a:	ce06                	sw	ra,28(sp)
	struct out_context ctx = { 0 };
8004170c:	c602                	sw	zero,12(sp)
	z_vprintk(char_out, &ctx, fmt, ap);
8004170e:	39dd                	jal	80041404 <z_vprintk>
}
80041710:	40f2                	lw	ra,28(sp)
80041712:	6105                	addi	sp,sp,32
80041714:	8082                	ret

80041716 <printk>:
{
80041716:	7139                	addi	sp,sp,-64
80041718:	d22e                	sw	a1,36(sp)
	va_start(ap, fmt);
8004171a:	104c                	addi	a1,sp,36
{
8004171c:	ce06                	sw	ra,28(sp)
8004171e:	d432                	sw	a2,40(sp)
80041720:	d636                	sw	a3,44(sp)
80041722:	d83a                	sw	a4,48(sp)
80041724:	da3e                	sw	a5,52(sp)
80041726:	dc42                	sw	a6,56(sp)
80041728:	de46                	sw	a7,60(sp)
	va_start(ap, fmt);
8004172a:	c62e                	sw	a1,12(sp)
		vprintk(fmt, ap);
8004172c:	37f9                	jal	800416fa <vprintk>
}
8004172e:	40f2                	lw	ra,28(sp)
80041730:	6121                	addi	sp,sp,64
80041732:	8082                	ret

80041734 <assert_post_action>:
__weak void assert_post_action(const char *file, unsigned int line)
{
  ARG_UNUSED(file);
  ARG_UNUSED(line);

  k_panic();
80041734:	800455b7          	lui	a1,0x80045
80041738:	80045537          	lui	a0,0x80045
{
8004173c:	1141                	addi	sp,sp,-16
  k_panic();
8004173e:	94c58593          	addi	a1,a1,-1716 # 8004494c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004494d>
80041742:	97050513          	addi	a0,a0,-1680 # 80044970 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044971>
80041746:	4679                	li	a2,30
{
80041748:	c606                	sw	ra,12(sp)
  k_panic();
8004174a:	37f1                	jal	80041716 <printk>
8004174c:	800445b7          	lui	a1,0x80044
80041750:	56058593          	addi	a1,a1,1376 # 80044560 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044561>
80041754:	4519                	li	a0,6
80041756:	a1aff0ef          	jal	ra,80040970 <z_NanoFatalErrorHandler>

8004175a <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);

GEN_ABS_SYM_END
8004175a:	8082                	ret

8004175c <k_cpu_idle>:
 */
static ALWAYS_INLINE void z_arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
8004175c:	47a1                	li	a5,8
8004175e:	3007a7f3          	csrrs	a5,mstatus,a5
	z_sys_trace_idle();
	/* unlock interrupts */
	irq_unlock(key);

	/* Wait for interrupt */
	__asm__ volatile("wfi");
80041762:	10500073          	wfi
 * @return N/A
 */
void k_cpu_idle(void)
{
	riscv_idle(SOC_MSTATUS_IEN);
}
80041766:	8082                	ret

80041768 <z_arch_irq_enable>:
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
80041768:	4785                	li	a5,1
8004176a:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
8004176e:	30452573          	csrrs	a0,mie,a0
}
80041772:	8082                	ret

80041774 <soc_interrupt_init>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041774:	47a1                	li	a5,8
80041776:	3007b7f3          	csrrc	a5,mstatus,a5
void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
8004177a:	30405073          	csrwi	mie,0
8004177e:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
80041782:	8082                	ret

80041784 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
80041784:	1141                	addi	sp,sp,-16
80041786:	c422                	sw	s0,8(sp)
80041788:	c226                	sw	s1,4(sp)
8004178a:	80045437          	lui	s0,0x80045
8004178e:	c606                	sw	ra,12(sp)
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
80041790:	47a9                	li	a5,10
{
80041792:	84aa                	mv	s1,a0
80041794:	dc840413          	addi	s0,s0,-568 # 80044dc8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dc9>
	if ('\n' == c) {
80041798:	00f51763          	bne	a0,a5,800417a6 <console_out+0x22>
8004179c:	4008                	lw	a0,0(s0)
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
8004179e:	45b5                	li	a1,13
800417a0:	415c                	lw	a5,4(a0)
800417a2:	43dc                	lw	a5,4(a5)
800417a4:	9782                	jalr	a5
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
800417a6:	4008                	lw	a0,0(s0)
800417a8:	0ff4f593          	andi	a1,s1,255
800417ac:	415c                	lw	a5,4(a0)
800417ae:	43dc                	lw	a5,4(a5)
800417b0:	9782                	jalr	a5

	return c;
}
800417b2:	40b2                	lw	ra,12(sp)
800417b4:	4422                	lw	s0,8(sp)
800417b6:	8526                	mv	a0,s1
800417b8:	4492                	lw	s1,4(sp)
800417ba:	0141                	addi	sp,sp,16
800417bc:	8082                	ret

800417be <uart_console_hook_install>:
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
800417be:	80041537          	lui	a0,0x80041
800417c2:	78450513          	addi	a0,a0,1924 # 80041784 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041785>
800417c6:	b915                	j	800413fa <__printk_hook_install>

800417c8 <uart_console_init>:

#ifdef __cplusplus
extern "C" {
#endif

K_SYSCALL_DECLARE1(K_SYSCALL_DEVICE_GET_BINDING, device_get_binding, struct device *, const char *, name)
800417c8:	80045537          	lui	a0,0x80045
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
800417cc:	1141                	addi	sp,sp,-16
800417ce:	97c50513          	addi	a0,a0,-1668 # 8004497c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004497d>
800417d2:	c606                	sw	ra,12(sp)
800417d4:	2921                	jal	80041bec <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
800417d6:	800457b7          	lui	a5,0x80045
800417da:	dca7a423          	sw	a0,-568(a5) # 80044dc8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dc9>
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
800417de:	37c5                	jal	800417be <uart_console_hook_install>

	return 0;
}
800417e0:	40b2                	lw	ra,12(sp)
800417e2:	4501                	li	a0,0
800417e4:	0141                	addi	sp,sp,16
800417e6:	8082                	ret

800417e8 <mtime>:
	volatile u32_t *r = (u32_t *)RISCV_MTIME_BASE;
	u32_t lo, hi;

	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
800417e8:	200007b7          	lui	a5,0x20000
800417ec:	43d8                	lw	a4,4(a5)
		lo = r[0];
800417ee:	4388                	lw	a0,0(a5)
	} while (r[1] != hi);
800417f0:	43cc                	lw	a1,4(a5)
800417f2:	fee59de3          	bne	a1,a4,800417ec <mtime+0x4>

	return (((u64_t)hi) << 32) | lo;
}
800417f6:	8082                	ret

800417f8 <timer_isr>:

static void timer_isr(void *arg)
{
800417f8:	1101                	addi	sp,sp,-32
800417fa:	cc22                	sw	s0,24(sp)
800417fc:	ce06                	sw	ra,28(sp)
800417fe:	ca26                	sw	s1,20(sp)
80041800:	c84a                	sw	s2,16(sp)
80041802:	c64e                	sw	s3,12(sp)
80041804:	c452                	sw	s4,8(sp)
80041806:	c256                	sw	s5,4(sp)
80041808:	4421                	li	s0,8
8004180a:	30043473          	csrrc	s0,mstatus,s0
	 * actually a wrapper for a global spinlock!
	 */
	k.key = z_arch_irq_lock();

#ifdef SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
8004180e:	80045937          	lui	s2,0x80045
80041812:	dcc90513          	addi	a0,s2,-564 # 80044dcc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dcd>
	key = (mstatus & SOC_MSTATUS_IEN);
80041816:	8821                	andi	s0,s0,8
80041818:	57b010ef          	jal	ra,80043592 <z_spin_lock_valid>
8004181c:	e915                	bnez	a0,80041850 <timer_isr+0x58>
8004181e:	800454b7          	lui	s1,0x80045
80041822:	800455b7          	lui	a1,0x80045
80041826:	80045537          	lui	a0,0x80045
8004182a:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
8004182e:	04e00693          	li	a3,78
80041832:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80041836:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004183a:	3df1                	jal	80041716 <printk>
8004183c:	80045537          	lui	a0,0x80045
80041840:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80041844:	3dc9                	jal	80041716 <printk>
80041846:	04e00593          	li	a1,78
8004184a:	99048513          	addi	a0,s1,-1648
8004184e:	35dd                	jal	80041734 <assert_post_action>
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef SPIN_VALIDATE
	z_spin_lock_set_owner(l);
80041850:	dcc90513          	addi	a0,s2,-564
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u64_t now = mtime();
	u32_t dticks = (u32_t)((now - last_count) / CYC_PER_TICK);
80041854:	800454b7          	lui	s1,0x80045
80041858:	577010ef          	jal	ra,800435ce <z_spin_lock_set_owner>
8004185c:	db048493          	addi	s1,s1,-592 # 80044db0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044db1>
	u64_t now = mtime();
80041860:	3761                	jal	800417e8 <mtime>
	u32_t dticks = (u32_t)((now - last_count) / CYC_PER_TICK);
80041862:	0004a983          	lw	s3,0(s1)
80041866:	0044aa83          	lw	s5,4(s1)
	u64_t now = mtime();
8004186a:	872a                	mv	a4,a0
	u32_t dticks = (u32_t)((now - last_count) / CYC_PER_TICK);
8004186c:	41350533          	sub	a0,a0,s3
80041870:	00a73733          	sltu	a4,a4,a0
80041874:	415585b3          	sub	a1,a1,s5
80041878:	6609                	lui	a2,0x2
8004187a:	71060613          	addi	a2,a2,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
8004187e:	4681                	li	a3,0
80041880:	8d99                	sub	a1,a1,a4
80041882:	9c7fe0ef          	jal	ra,80040248 <__udivdi3>

	last_count += dticks * CYC_PER_TICK;
80041886:	6789                	lui	a5,0x2
80041888:	71078793          	addi	a5,a5,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
8004188c:	02a787b3          	mul	a5,a5,a0
	u32_t dticks = (u32_t)((now - last_count) / CYC_PER_TICK);
80041890:	8a2a                	mv	s4,a0
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80041892:	dcc90513          	addi	a0,s2,-564
	last_count += dticks * CYC_PER_TICK;
80041896:	99be                	add	s3,s3,a5
80041898:	00f9b7b3          	sltu	a5,s3,a5
8004189c:	97d6                	add	a5,a5,s5
8004189e:	0134a023          	sw	s3,0(s1)
800418a2:	c0dc                	sw	a5,4(s1)
800418a4:	509010ef          	jal	ra,800435ac <z_spin_unlock_valid>
800418a8:	e915                	bnez	a0,800418dc <timer_isr+0xe4>
800418aa:	800454b7          	lui	s1,0x80045
800418ae:	800455b7          	lui	a1,0x80045
800418b2:	80045537          	lui	a0,0x80045
800418b6:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
800418ba:	06100693          	li	a3,97
800418be:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
800418c2:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800418c6:	3d81                	jal	80041716 <printk>
800418c8:	80045537          	lui	a0,0x80045
800418cc:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
800418d0:	3599                	jal	80041716 <printk>
800418d2:	06100593          	li	a1,97
800418d6:	99048513          	addi	a0,s1,-1648
800418da:	3da9                	jal	80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
800418dc:	30042473          	csrrs	s0,mstatus,s0
		set_mtimecmp(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
800418e0:	4462                	lw	s0,24(sp)
800418e2:	40f2                	lw	ra,28(sp)
800418e4:	44d2                	lw	s1,20(sp)
800418e6:	4942                	lw	s2,16(sp)
800418e8:	49b2                	lw	s3,12(sp)
800418ea:	4a92                	lw	s5,4(sp)
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
800418ec:	8552                	mv	a0,s4
}
800418ee:	4a22                	lw	s4,8(sp)
800418f0:	6105                	addi	sp,sp,32
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
800418f2:	49a0206f          	j	80043d8c <z_clock_announce>

800418f6 <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
800418f6:	1141                	addi	sp,sp,-16
800418f8:	c606                	sw	ra,12(sp)
	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
	set_mtimecmp(mtime() + CYC_PER_TICK);
800418fa:	35fd                	jal	800417e8 <mtime>
800418fc:	6789                	lui	a5,0x2
800418fe:	71078793          	addi	a5,a5,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
	r[1] = 0xffffffff;
80041902:	20000737          	lui	a4,0x20000
	set_mtimecmp(mtime() + CYC_PER_TICK);
80041906:	97aa                	add	a5,a5,a0
	r[1] = 0xffffffff;
80041908:	56fd                	li	a3,-1
8004190a:	c754                	sw	a3,12(a4)
	set_mtimecmp(mtime() + CYC_PER_TICK);
8004190c:	00a7b533          	sltu	a0,a5,a0
80041910:	952e                	add	a0,a0,a1
	r[0] = (u32_t)time;
80041912:	c71c                	sw	a5,8(a4)
	r[1] = (u32_t)(time >> 32);
80041914:	c748                	sw	a0,12(a4)
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
80041916:	451d                	li	a0,7
80041918:	3d81                	jal	80041768 <z_arch_irq_enable>
	return 0;
}
8004191a:	40b2                	lw	ra,12(sp)
8004191c:	4501                	li	a0,0
8004191e:	0141                	addi	sp,sp,16
80041920:	8082                	ret

80041922 <z_clock_set_timeout>:
	 * logic below to reset the comparator, we'll always bump it
	 * forward to the "next tick" due to MIN_DELAY handling and
	 * the interrupt will never fire!  Just rely on the fact that
	 * the OS gave us the proper timeout already.
	 */
	if (idle) {
80041922:	12059363          	bnez	a1,80041a48 <z_clock_set_timeout+0x126>
{
80041926:	1101                	addi	sp,sp,-32
80041928:	ce06                	sw	ra,28(sp)
8004192a:	cc22                	sw	s0,24(sp)
8004192c:	ca26                	sw	s1,20(sp)
8004192e:	c84a                	sw	s2,16(sp)
80041930:	c64e                	sw	s3,12(sp)
		return;
	}

	ticks = ticks == K_FOREVER ? MAX_TICKS : ticks;
80041932:	57fd                	li	a5,-1
80041934:	00f51663          	bne	a0,a5,80041940 <z_clock_set_timeout+0x1e>
80041938:	00069537          	lui	a0,0x69
8004193c:	db750513          	addi	a0,a0,-585 # 68db7 <CONFIG_RISCV_RAM_SIZE+0x28db7>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
80041940:	000697b7          	lui	a5,0x69
80041944:	fff50413          	addi	s0,a0,-1
80041948:	db778793          	addi	a5,a5,-585 # 68db7 <CONFIG_RISCV_RAM_SIZE+0x28db7>
8004194c:	0e87da63          	bge	a5,s0,80041a40 <z_clock_set_timeout+0x11e>
80041950:	843e                	mv	s0,a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041952:	44a1                	li	s1,8
80041954:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80041958:	80045937          	lui	s2,0x80045
8004195c:	dcc90513          	addi	a0,s2,-564 # 80044dcc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dcd>
	key = (mstatus & SOC_MSTATUS_IEN);
80041960:	88a1                	andi	s1,s1,8
80041962:	431010ef          	jal	ra,80043592 <z_spin_lock_valid>
80041966:	e915                	bnez	a0,8004199a <z_clock_set_timeout+0x78>
80041968:	800459b7          	lui	s3,0x80045
8004196c:	800455b7          	lui	a1,0x80045
80041970:	80045537          	lui	a0,0x80045
80041974:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80041978:	04e00693          	li	a3,78
8004197c:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80041980:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80041984:	3b49                	jal	80041716 <printk>
80041986:	80045537          	lui	a0,0x80045
8004198a:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
8004198e:	3361                	jal	80041716 <printk>
80041990:	04e00593          	li	a1,78
80041994:	99098513          	addi	a0,s3,-1648
80041998:	3b71                	jal	80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
8004199a:	dcc90513          	addi	a0,s2,-564
8004199e:	431010ef          	jal	ra,800435ce <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);
	u64_t now = mtime();
800419a2:	3599                	jal	800417e8 <mtime>
	u32_t cyc = ticks * CYC_PER_TICK;
800419a4:	6689                	lui	a3,0x2

	/* Round up to next tick boundary.  Note use of 32 bit math,
	 * max_ticks is calibrated to permit this.
	 */
	cyc += (u32_t)(now - last_count) + (CYC_PER_TICK - 1);
800419a6:	800457b7          	lui	a5,0x80045
	u32_t cyc = ticks * CYC_PER_TICK;
800419aa:	71068613          	addi	a2,a3,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
	cyc += (u32_t)(now - last_count) + (CYC_PER_TICK - 1);
800419ae:	db078793          	addi	a5,a5,-592 # 80044db0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044db1>
800419b2:	4398                	lw	a4,0(a5)
800419b4:	43cc                	lw	a1,4(a5)
	u32_t cyc = ticks * CYC_PER_TICK;
800419b6:	02c407b3          	mul	a5,s0,a2
800419ba:	70f68693          	addi	a3,a3,1807
800419be:	40e68433          	sub	s0,a3,a4
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;

	if ((s32_t)(cyc + last_count - now) < MIN_DELAY) {
800419c2:	3e700693          	li	a3,999
800419c6:	97a2                	add	a5,a5,s0
	cyc += (u32_t)(now - last_count) + (CYC_PER_TICK - 1);
800419c8:	97aa                	add	a5,a5,a0
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
800419ca:	02c7d7b3          	divu	a5,a5,a2
	if ((s32_t)(cyc + last_count - now) < MIN_DELAY) {
800419ce:	40a70533          	sub	a0,a4,a0
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
800419d2:	02c787b3          	mul	a5,a5,a2
	if ((s32_t)(cyc + last_count - now) < MIN_DELAY) {
800419d6:	953e                	add	a0,a0,a5
800419d8:	00a6c363          	blt	a3,a0,800419de <z_clock_set_timeout+0xbc>
		cyc += CYC_PER_TICK;
800419dc:	97b2                	add	a5,a5,a2
	r[1] = 0xffffffff;
800419de:	200006b7          	lui	a3,0x20000
	}

	set_mtimecmp(cyc + last_count);
800419e2:	973e                	add	a4,a4,a5
	r[1] = 0xffffffff;
800419e4:	567d                	li	a2,-1
800419e6:	c6d0                	sw	a2,12(a3)
	set_mtimecmp(cyc + last_count);
800419e8:	00f737b3          	sltu	a5,a4,a5
800419ec:	97ae                	add	a5,a5,a1
	r[0] = (u32_t)time;
800419ee:	c698                	sw	a4,8(a3)
	r[1] = (u32_t)(time >> 32);
800419f0:	c6dc                	sw	a5,12(a3)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
800419f2:	dcc90513          	addi	a0,s2,-564
800419f6:	3b7010ef          	jal	ra,800435ac <z_spin_unlock_valid>
800419fa:	e915                	bnez	a0,80041a2e <z_clock_set_timeout+0x10c>
800419fc:	80045437          	lui	s0,0x80045
80041a00:	800455b7          	lui	a1,0x80045
80041a04:	80045537          	lui	a0,0x80045
80041a08:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80041a0c:	06100693          	li	a3,97
80041a10:	99040613          	addi	a2,s0,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80041a14:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80041a18:	39fd                	jal	80041716 <printk>
80041a1a:	80045537          	lui	a0,0x80045
80041a1e:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80041a22:	39d5                	jal	80041716 <printk>
80041a24:	06100593          	li	a1,97
80041a28:	99040513          	addi	a0,s0,-1648
80041a2c:	3321                	jal	80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041a2e:	3004a4f3          	csrrs	s1,mstatus,s1
	k_spin_unlock(&lock, key);
#endif
}
80041a32:	40f2                	lw	ra,28(sp)
80041a34:	4462                	lw	s0,24(sp)
80041a36:	44d2                	lw	s1,20(sp)
80041a38:	4942                	lw	s2,16(sp)
80041a3a:	49b2                	lw	s3,12(sp)
80041a3c:	6105                	addi	sp,sp,32
80041a3e:	8082                	ret
80041a40:	f00459e3          	bgez	s0,80041952 <z_clock_set_timeout+0x30>
80041a44:	4401                	li	s0,0
80041a46:	b731                	j	80041952 <z_clock_set_timeout+0x30>
80041a48:	8082                	ret

80041a4a <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
80041a4a:	1141                	addi	sp,sp,-16
80041a4c:	c422                	sw	s0,8(sp)
80041a4e:	c606                	sw	ra,12(sp)
80041a50:	c226                	sw	s1,4(sp)
80041a52:	c04a                	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041a54:	4421                	li	s0,8
80041a56:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80041a5a:	80045937          	lui	s2,0x80045
80041a5e:	dcc90513          	addi	a0,s2,-564 # 80044dcc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dcd>
	key = (mstatus & SOC_MSTATUS_IEN);
80041a62:	8821                	andi	s0,s0,8
80041a64:	32f010ef          	jal	ra,80043592 <z_spin_lock_valid>
80041a68:	e915                	bnez	a0,80041a9c <z_clock_elapsed+0x52>
80041a6a:	800454b7          	lui	s1,0x80045
80041a6e:	800455b7          	lui	a1,0x80045
80041a72:	80045537          	lui	a0,0x80045
80041a76:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80041a7a:	04e00693          	li	a3,78
80041a7e:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80041a82:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80041a86:	3941                	jal	80041716 <printk>
80041a88:	80045537          	lui	a0,0x80045
80041a8c:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80041a90:	3159                	jal	80041716 <printk>
80041a92:	04e00593          	li	a1,78
80041a96:	99048513          	addi	a0,s1,-1648
80041a9a:	3969                	jal	80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80041a9c:	dcc90513          	addi	a0,s2,-564
80041aa0:	32f010ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = ((u32_t)mtime() - (u32_t)last_count) / CYC_PER_TICK;
80041aa4:	3391                	jal	800417e8 <mtime>
80041aa6:	800457b7          	lui	a5,0x80045
80041aaa:	db07a483          	lw	s1,-592(a5) # 80044db0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044db1>
80041aae:	409504b3          	sub	s1,a0,s1
80041ab2:	6509                	lui	a0,0x2
80041ab4:	71050513          	addi	a0,a0,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
80041ab8:	02a4d4b3          	divu	s1,s1,a0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80041abc:	dcc90513          	addi	a0,s2,-564
80041ac0:	2ed010ef          	jal	ra,800435ac <z_spin_unlock_valid>
80041ac4:	e915                	bnez	a0,80041af8 <z_clock_elapsed+0xae>
80041ac6:	80045937          	lui	s2,0x80045
80041aca:	800455b7          	lui	a1,0x80045
80041ace:	80045537          	lui	a0,0x80045
80041ad2:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80041ad6:	06100693          	li	a3,97
80041ada:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80041ade:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80041ae2:	3915                	jal	80041716 <printk>
80041ae4:	80045537          	lui	a0,0x80045
80041ae8:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80041aec:	312d                	jal	80041716 <printk>
80041aee:	06100593          	li	a1,97
80041af2:	99090513          	addi	a0,s2,-1648
80041af6:	393d                	jal	80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041af8:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&lock, key);
	return ret;
}
80041afc:	40b2                	lw	ra,12(sp)
80041afe:	4422                	lw	s0,8(sp)
80041b00:	8526                	mv	a0,s1
80041b02:	4902                	lw	s2,0(sp)
80041b04:	4492                	lw	s1,4(sp)
80041b06:	0141                	addi	sp,sp,16
80041b08:	8082                	ret

80041b0a <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
80041b0a:	00054783          	lbu	a5,0(a0)
80041b0e:	0005c703          	lbu	a4,0(a1)
80041b12:	00e79363          	bne	a5,a4,80041b18 <strcmp+0xe>
80041b16:	e781                	bnez	a5,80041b1e <strcmp+0x14>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
80041b18:	40e78533          	sub	a0,a5,a4
80041b1c:	8082                	ret
		s1++;
80041b1e:	0505                	addi	a0,a0,1
		s2++;
80041b20:	0585                	addi	a1,a1,1
80041b22:	b7e5                	j	80041b0a <strcmp>

80041b24 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
80041b24:	0ff5f693          	andi	a3,a1,255
	unsigned char *d_byte = (unsigned char *)buf;
80041b28:	87aa                	mv	a5,a0

	while (((unsigned int)d_byte) & 0x3) {
80041b2a:	0037f713          	andi	a4,a5,3
80041b2e:	ef15                	bnez	a4,80041b6a <memset+0x46>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
80041b30:	0ff5f593          	andi	a1,a1,255

	c_word |= c_word << 8;
80041b34:	00859713          	slli	a4,a1,0x8
80041b38:	8dd9                	or	a1,a1,a4
	c_word |= c_word << 16;
80041b3a:	01059713          	slli	a4,a1,0x10
80041b3e:	8dd9                	or	a1,a1,a4

	while (n >= sizeof(unsigned int)) {
80041b40:	00c78333          	add	t1,a5,a2
80041b44:	873e                	mv	a4,a5
80041b46:	480d                	li	a6,3
80041b48:	40e308b3          	sub	a7,t1,a4
80041b4c:	03186563          	bltu	a6,a7,80041b76 <memset+0x52>
80041b50:	00265713          	srli	a4,a2,0x2
80041b54:	00271593          	slli	a1,a4,0x2
80041b58:	97ae                	add	a5,a5,a1
80041b5a:	55f1                	li	a1,-4
80041b5c:	02b70733          	mul	a4,a4,a1
80041b60:	9732                	add	a4,a4,a2
80041b62:	973e                	add	a4,a4,a5

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
80041b64:	00e79d63          	bne	a5,a4,80041b7e <memset+0x5a>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
80041b68:	8082                	ret
		if (n == 0) {
80041b6a:	de7d                	beqz	a2,80041b68 <memset+0x44>
		*(d_byte++) = c_byte;
80041b6c:	0785                	addi	a5,a5,1
80041b6e:	fed78fa3          	sb	a3,-1(a5)
		n--;
80041b72:	167d                	addi	a2,a2,-1
80041b74:	bf5d                	j	80041b2a <memset+0x6>
		*(d_word++) = c_word;
80041b76:	0711                	addi	a4,a4,4
80041b78:	feb72e23          	sw	a1,-4(a4) # 1ffffffc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1ff0bdbc>
		n -= sizeof(unsigned int);
80041b7c:	b7f1                	j	80041b48 <memset+0x24>
		*(d_byte++) = c_byte;
80041b7e:	0785                	addi	a5,a5,1
80041b80:	fed78fa3          	sb	a3,-1(a5)
		n--;
80041b84:	b7c5                	j	80041b64 <memset+0x40>

80041b86 <uart_pulserain_rattlesnake_poll_out>:
static unsigned char uart_pulserain_rattlesnake_poll_out(struct device *dev,
					      unsigned char c)
{
    volatile unsigned int *uart = (unsigned int*)PULSERAIN_RATTLESNAKE_UART_BASE;
   
    while ((*uart) & 0x80000000){};
80041b86:	200007b7          	lui	a5,0x20000
80041b8a:	4b94                	lw	a3,16(a5)
80041b8c:	fe06cfe3          	bltz	a3,80041b8a <uart_pulserain_rattlesnake_poll_out+0x4>
        *uart = c;
80041b90:	cb8c                	sw	a1,16(a5)
    while ((*uart) & 0x80000000){};
80041b92:	20000737          	lui	a4,0x20000
80041b96:	4b1c                	lw	a5,16(a4)
80041b98:	fe07cfe3          	bltz	a5,80041b96 <uart_pulserain_rattlesnake_poll_out+0x10>
  
    return c;
}
80041b9c:	852e                	mv	a0,a1
80041b9e:	8082                	ret

80041ba0 <uart_pulserain_rattlesnake_poll_in>:

static int uart_pulserain_rattlesnake_poll_in(struct device *dev, unsigned char *c)
{
	*c = 0;
80041ba0:	00058023          	sb	zero,0(a1)
	return 0;
}
80041ba4:	4501                	li	a0,0
80041ba6:	8082                	ret

80041ba8 <uart_pulserain_rattlesnake_init>:
static int uart_pulserain_rattlesnake_init(struct device *dev)
{
	/* Nothing to do */

	return 0;
}
80041ba8:	4501                	li	a0,0
80041baa:	8082                	ret

80041bac <z_sys_device_do_config_level>:
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
80041bac:	00251713          	slli	a4,a0,0x2
80041bb0:	800457b7          	lui	a5,0x80045
80041bb4:	0505                	addi	a0,a0,1
80041bb6:	a2878793          	addi	a5,a5,-1496 # 80044a28 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a29>
80041bba:	050a                	slli	a0,a0,0x2
{
80041bbc:	1141                	addi	sp,sp,-16
	for (info = config_levels[level]; info < config_levels[level+1];
80041bbe:	973e                	add	a4,a4,a5
80041bc0:	97aa                	add	a5,a5,a0
{
80041bc2:	c422                	sw	s0,8(sp)
80041bc4:	c226                	sw	s1,4(sp)
	for (info = config_levels[level]; info < config_levels[level+1];
80041bc6:	4300                	lw	s0,0(a4)
80041bc8:	4384                	lw	s1,0(a5)
{
80041bca:	c606                	sw	ra,12(sp)
	for (info = config_levels[level]; info < config_levels[level+1];
80041bcc:	00946763          	bltu	s0,s1,80041bda <z_sys_device_do_config_level+0x2e>
			info->driver_api = NULL;
		} else {
			z_object_init(info);
		}
	}
}
80041bd0:	40b2                	lw	ra,12(sp)
80041bd2:	4422                	lw	s0,8(sp)
80041bd4:	4492                	lw	s1,4(sp)
80041bd6:	0141                	addi	sp,sp,16
80041bd8:	8082                	ret
		retval = device_conf->init(info);
80041bda:	401c                	lw	a5,0(s0)
80041bdc:	8522                	mv	a0,s0
80041bde:	43dc                	lw	a5,4(a5)
80041be0:	9782                	jalr	a5
		if (retval != 0) {
80041be2:	c119                	beqz	a0,80041be8 <z_sys_device_do_config_level+0x3c>
			info->driver_api = NULL;
80041be4:	00042223          	sw	zero,4(s0)
								info++) {
80041be8:	0431                	addi	s0,s0,12
80041bea:	b7cd                	j	80041bcc <z_sys_device_do_config_level+0x20>

80041bec <z_impl_device_get_binding>:

struct device *z_impl_device_get_binding(const char *name)
{
80041bec:	1141                	addi	sp,sp,-16
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
80041bee:	800457b7          	lui	a5,0x80045
{
80041bf2:	c226                	sw	s1,4(sp)
	for (info = __device_init_start; info != __device_init_end; info++) {
80041bf4:	800454b7          	lui	s1,0x80045
{
80041bf8:	c422                	sw	s0,8(sp)
80041bfa:	c606                	sw	ra,12(sp)
	for (info = __device_init_start; info != __device_init_end; info++) {
80041bfc:	d6878413          	addi	s0,a5,-664 # 80044d68 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d69>
{
80041c00:	c04a                	sw	s2,0(sp)
80041c02:	d6878793          	addi	a5,a5,-664
80041c06:	d9848493          	addi	s1,s1,-616 # 80044d98 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d99>
	for (info = __device_init_start; info != __device_init_end; info++) {
80041c0a:	00941863          	bne	s0,s1,80041c1a <z_impl_device_get_binding+0x2e>
80041c0e:	892a                	mv	s2,a0
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
80041c10:	843e                	mv	s0,a5
80041c12:	00941c63          	bne	s0,s1,80041c2a <z_impl_device_get_binding+0x3e>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
80041c16:	4401                	li	s0,0
80041c18:	a015                	j	80041c3c <z_impl_device_get_binding+0x50>
		if ((info->driver_api != NULL) &&
80041c1a:	4058                	lw	a4,4(s0)
80041c1c:	c709                	beqz	a4,80041c26 <z_impl_device_get_binding+0x3a>
		    (info->config->name == name)) {
80041c1e:	4018                	lw	a4,0(s0)
		if ((info->driver_api != NULL) &&
80041c20:	4318                	lw	a4,0(a4)
80041c22:	00a70d63          	beq	a4,a0,80041c3c <z_impl_device_get_binding+0x50>
	for (info = __device_init_start; info != __device_init_end; info++) {
80041c26:	0431                	addi	s0,s0,12
80041c28:	b7cd                	j	80041c0a <z_impl_device_get_binding+0x1e>
		if (info->driver_api == NULL) {
80041c2a:	405c                	lw	a5,4(s0)
80041c2c:	e399                	bnez	a5,80041c32 <z_impl_device_get_binding+0x46>
	for (info = __device_init_start; info != __device_init_end; info++) {
80041c2e:	0431                	addi	s0,s0,12
80041c30:	b7cd                	j	80041c12 <z_impl_device_get_binding+0x26>
		if (strcmp(name, info->config->name) == 0) {
80041c32:	401c                	lw	a5,0(s0)
80041c34:	854a                	mv	a0,s2
80041c36:	438c                	lw	a1,0(a5)
80041c38:	3dc9                	jal	80041b0a <strcmp>
80041c3a:	f975                	bnez	a0,80041c2e <z_impl_device_get_binding+0x42>
}
80041c3c:	8522                	mv	a0,s0
80041c3e:	40b2                	lw	ra,12(sp)
80041c40:	4422                	lw	s0,8(sp)
80041c42:	4492                	lw	s1,4(sp)
80041c44:	4902                	lw	s2,0(sp)
80041c46:	0141                	addi	sp,sp,16
80041c48:	8082                	ret

80041c4a <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
80041c4a:	1141                	addi	sp,sp,-16
80041c4c:	c422                	sw	s0,8(sp)
80041c4e:	c226                	sw	s1,4(sp)
80041c50:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041c52:	4421                	li	s0,8
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
80041c54:	4489                	li	s1,2
80041c56:	300437f3          	csrrc	a5,mstatus,s0
	s32_t ticks = z_get_next_timeout_expiry();
80041c5a:	7a5010ef          	jal	ra,80043bfe <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
80041c5e:	00a4c363          	blt	s1,a0,80041c64 <idle+0x1a>
80041c62:	4505                	li	a0,1
80041c64:	4585                	li	a1,1
80041c66:	052020ef          	jal	ra,80043cb8 <z_set_timeout_expiry>
	k_cpu_idle();
80041c6a:	3ccd                	jal	8004175c <k_cpu_idle>
80041c6c:	b7ed                	j	80041c56 <idle+0xc>

80041c6e <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(&__bss_start, 0,
80041c6e:	80045537          	lui	a0,0x80045
80041c72:	800457b7          	lui	a5,0x80045
80041c76:	db050613          	addi	a2,a0,-592 # 80044db0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044db1>
80041c7a:	21c78793          	addi	a5,a5,540 # 8004521c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004521d>
80041c7e:	40c78633          	sub	a2,a5,a2
80041c82:	4581                	li	a1,0
80041c84:	db050513          	addi	a0,a0,-592
80041c88:	bd71                	j	80041b24 <memset>

80041c8a <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
80041c8a:	1141                	addi	sp,sp,-16
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
80041c8c:	4509                	li	a0,2
{
80041c8e:	c606                	sw	ra,12(sp)
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
80041c90:	3f31                	jal	80041bac <z_sys_device_do_config_level>
	if (boot_delay > 0 && IS_ENABLED(CONFIG_MULTITHREADING)) {
		printk("***** delaying boot " STRINGIFY(CONFIG_BOOT_DELAY)
		       "ms (per build configuration) *****\n");
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}
	PRINT_BOOT_BANNER();
80041c92:	80045537          	lui	a0,0x80045
80041c96:	a3c50513          	addi	a0,a0,-1476 # 80044a3c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a3d>
80041c9a:	3cb5                	jal	80041716 <printk>

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
80041c9c:	450d                	li	a0,3
80041c9e:	3739                	jal	80041bac <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
80041ca0:	2e3010ef          	jal	ra,80043782 <z_init_static_threads>
	__main_time_stamp = (u64_t)k_cycle_get_32();
#endif

	extern void main(void);

	main();
80041ca4:	b93fe0ef          	jal	ra,80040836 <main>

	/* Mark nonessenrial since main() has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
80041ca8:	800457b7          	lui	a5,0x80045
80041cac:	17878793          	addi	a5,a5,376 # 80045178 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045179>
80041cb0:	00c7c703          	lbu	a4,12(a5)
80041cb4:	9b79                	andi	a4,a4,-2
80041cb6:	00e78623          	sb	a4,12(a5)

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
80041cba:	40b2                	lw	ra,12(sp)
80041cbc:	0141                	addi	sp,sp,16
80041cbe:	8082                	ret

80041cc0 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
80041cc0:	7135                	addi	sp,sp,-160
80041cc2:	cd22                	sw	s0,152(sp)
void k_cpu_idle(void);
void k_cpu_atomic_idle(unsigned int key);

static ALWAYS_INLINE void kernel_arch_init(void)
{
	_kernel.irq_stack =
80041cc4:	800477b7          	lui	a5,0x80047
80041cc8:	80045437          	lui	s0,0x80045
80041ccc:	c74e                	sw	s3,140(sp)
80041cce:	22078793          	addi	a5,a5,544 # 80047220 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047221>
80041cd2:	1e840993          	addi	s3,s0,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
80041cd6:	00f9a223          	sw	a5,4(s3)

	/* perform any architecture-specific initialization */
	kernel_arch_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
80041cda:	081c                	addi	a5,sp,16
80041cdc:	07000613          	li	a2,112
80041ce0:	4581                	li	a1,0
80041ce2:	853e                	mv	a0,a5
{
80041ce4:	cf06                	sw	ra,156(sp)
80041ce6:	cb26                	sw	s1,148(sp)
80041ce8:	c94a                	sw	s2,144(sp)
80041cea:	c552                	sw	s4,136(sp)
	struct k_thread dummy_thread = {
80041cec:	3d25                	jal	80041b24 <memset>
80041cee:	4a05                	li	s4,1
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
80041cf0:	00a9a423          	sw	a0,8(s3)
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
80041cf4:	4501                	li	a0,0
	struct k_thread dummy_thread = {
80041cf6:	01410ea3          	sb	s4,29(sp)
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
80041cfa:	3d4d                	jal	80041bac <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
80041cfc:	4505                	li	a0,1
80041cfe:	357d                	jal	80041bac <z_sys_device_do_config_level>
	dummy_thread->base.user_options = K_ESSENTIAL;
80041d00:	10100793          	li	a5,257
80041d04:	00f11e23          	sh	a5,28(sp)
	z_sched_init();
80041d08:	4d2010ef          	jal	ra,800431da <z_sched_init>
	z_setup_new_thread(_main_thread, _main_stack,
80041d0c:	800457b7          	lui	a5,0x80045
	_kernel.ready_q.cache = _main_thread;
80041d10:	80045937          	lui	s2,0x80045
	z_setup_new_thread(_main_thread, _main_stack,
80041d14:	a8078793          	addi	a5,a5,-1408 # 80044a80 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a81>
80041d18:	800426b7          	lui	a3,0x80042
80041d1c:	800465b7          	lui	a1,0x80046
	_kernel.ready_q.cache = _main_thread;
80041d20:	17890493          	addi	s1,s2,376 # 80045178 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045179>
	z_setup_new_thread(_main_thread, _main_stack,
80041d24:	c23e                	sw	a5,4(sp)
80041d26:	4701                	li	a4,0
80041d28:	4781                	li	a5,0
80041d2a:	c052                	sw	s4,0(sp)
80041d2c:	4881                	li	a7,0
80041d2e:	4801                	li	a6,0
80041d30:	c8a68693          	addi	a3,a3,-886 # 80041c8a <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041c8b>
80041d34:	40000613          	li	a2,1024
80041d38:	42058593          	addi	a1,a1,1056 # 80046420 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046421>
80041d3c:	17890513          	addi	a0,s2,376
	_kernel.ready_q.cache = _main_thread;
80041d40:	0299a023          	sw	s1,32(s3)
	z_setup_new_thread(_main_thread, _main_stack,
80041d44:	7c8010ef          	jal	ra,8004350c <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
80041d48:	00d4c783          	lbu	a5,13(s1)
80041d4c:	1e840413          	addi	s0,s0,488
80041d50:	ffb7f713          	andi	a4,a5,-5
80041d54:	00e486a3          	sb	a4,13(s1)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
80041d58:	8bed                	andi	a5,a5,27
80041d5a:	e799                	bnez	a5,80041d68 <z_cstart+0xa8>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
80041d5c:	4c9c                	lw	a5,24(s1)
80041d5e:	e789                	bnez	a5,80041d68 <z_cstart+0xa8>
		z_add_thread_to_ready_q(thread);
80041d60:	17890513          	addi	a0,s2,376
80041d64:	611000ef          	jal	ra,80042b74 <z_add_thread_to_ready_q>
	z_setup_new_thread(thr, stack,
80041d68:	800457b7          	lui	a5,0x80045
80041d6c:	a8878793          	addi	a5,a5,-1400 # 80044a88 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a89>
80041d70:	c23e                	sw	a5,4(sp)
80041d72:	80045537          	lui	a0,0x80045
80041d76:	4785                	li	a5,1
80041d78:	800426b7          	lui	a3,0x80042
80041d7c:	800475b7          	lui	a1,0x80047
80041d80:	10850493          	addi	s1,a0,264 # 80045108 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045109>
80041d84:	c03e                	sw	a5,0(sp)
80041d86:	02800893          	li	a7,40
80041d8a:	4801                	li	a6,0
80041d8c:	4781                	li	a5,0
80041d8e:	4701                	li	a4,0
80041d90:	c4a68693          	addi	a3,a3,-950 # 80041c4a <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041c4b>
80041d94:	20000613          	li	a2,512
80041d98:	82058593          	addi	a1,a1,-2016 # 80046820 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046821>
80041d9c:	10850513          	addi	a0,a0,264
80041da0:	76c010ef          	jal	ra,8004350c <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
80041da4:	00d4c783          	lbu	a5,13(s1)
	_kernel.cpus[0].idle_thread = _idle_thread;
80041da8:	c444                	sw	s1,12(s0)
80041daa:	4521                	li	a0,8
80041dac:	9bed                	andi	a5,a5,-5
80041dae:	00f486a3          	sb	a5,13(s1)
	list->head = (sys_dnode_t *)list;
80041db2:	800457b7          	lui	a5,0x80045
80041db6:	20078793          	addi	a5,a5,512 # 80045200 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045201>
80041dba:	cc1c                	sw	a5,24(s0)
	list->tail = (sys_dnode_t *)list;
80041dbc:	cc5c                	sw	a5,28(s0)
80041dbe:	30053573          	csrrc	a0,mstatus,a0
#ifndef CONFIG_ARM
#ifdef CONFIG_TRACING
	sys_trace_thread_switched_out();
#endif
#endif
	ret = __swap(key);
80041dc2:	8921                	andi	a0,a0,8
80041dc4:	bfcfe0ef          	jal	ra,800401c0 <__swap>

80041dc8 <z_sched_lock>:
		z_ready_thread(th);
	}
}

static inline void z_sched_lock(void)
{
80041dc8:	1141                	addi	sp,sp,-16
80041dca:	c422                	sw	s0,8(sp)
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!z_is_in_isr(), "");
80041dcc:	80045437          	lui	s0,0x80045
80041dd0:	1e842783          	lw	a5,488(s0) # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
{
80041dd4:	c606                	sw	ra,12(sp)
80041dd6:	c226                	sw	s1,4(sp)
80041dd8:	1e840413          	addi	s0,s0,488
	__ASSERT(!z_is_in_isr(), "");
80041ddc:	cf8d                	beqz	a5,80041e16 <z_sched_lock+0x4e>
80041dde:	800454b7          	lui	s1,0x80045
80041de2:	800455b7          	lui	a1,0x80045
80041de6:	80045537          	lui	a0,0x80045
80041dea:	b1858593          	addi	a1,a1,-1256 # 80044b18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b19>
80041dee:	10000693          	li	a3,256
80041df2:	aec48613          	addi	a2,s1,-1300 # 80044aec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044aed>
80041df6:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80041dfa:	91dff0ef          	jal	ra,80041716 <printk>
80041dfe:	80045537          	lui	a0,0x80045
80041e02:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
80041e06:	911ff0ef          	jal	ra,80041716 <printk>
80041e0a:	10000593          	li	a1,256
80041e0e:	aec48513          	addi	a0,s1,-1300
80041e12:	923ff0ef          	jal	ra,80041734 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
80041e16:	441c                	lw	a5,8(s0)
80041e18:	00f7c703          	lbu	a4,15(a5)
80041e1c:	4785                	li	a5,1
80041e1e:	02f71e63          	bne	a4,a5,80041e5a <z_sched_lock+0x92>
80041e22:	800454b7          	lui	s1,0x80045
80041e26:	800455b7          	lui	a1,0x80045
80041e2a:	80045537          	lui	a0,0x80045
80041e2e:	b3458593          	addi	a1,a1,-1228 # 80044b34 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b35>
80041e32:	10100693          	li	a3,257
80041e36:	aec48613          	addi	a2,s1,-1300 # 80044aec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044aed>
80041e3a:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80041e3e:	8d9ff0ef          	jal	ra,80041716 <printk>
80041e42:	80045537          	lui	a0,0x80045
80041e46:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
80041e4a:	8cdff0ef          	jal	ra,80041716 <printk>
80041e4e:	10100593          	li	a1,257
80041e52:	aec48513          	addi	a0,s1,-1300
80041e56:	8dfff0ef          	jal	ra,80041734 <assert_post_action>

	--_current->base.sched_locked;
80041e5a:	4418                	lw	a4,8(s0)
80041e5c:	00f74783          	lbu	a5,15(a4) # 2000000f <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1ff0bdcf>
80041e60:	17fd                	addi	a5,a5,-1
80041e62:	00f707a3          	sb	a5,15(a4)
	compiler_barrier();

	K_DEBUG("scheduler locked (%p:%d)\n",
		_current, _current->base.sched_locked);
#endif
}
80041e66:	40b2                	lw	ra,12(sp)
80041e68:	4422                	lw	s0,8(sp)
80041e6a:	4492                	lw	s1,4(sp)
80041e6c:	0141                	addi	sp,sp,16
80041e6e:	8082                	ret

80041e70 <z_impl_k_mutex_init>:

#endif /* CONFIG_OBJECT_TRACING */

void z_impl_k_mutex_init(struct k_mutex *mutex)
{
	mutex->owner = NULL;
80041e70:	00052423          	sw	zero,8(a0)
	mutex->lock_count = 0U;
80041e74:	00052623          	sw	zero,12(a0)
	list->head = (sys_dnode_t *)list;
80041e78:	c108                	sw	a0,0(a0)
	list->tail = (sys_dnode_t *)list;
80041e7a:	c148                	sw	a0,4(a0)
	z_waitq_init(&mutex->wait_q);

	SYS_TRACING_OBJ_INIT(k_mutex, mutex);
	z_object_init(mutex);
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_INIT);
}
80041e7c:	8082                	ret

80041e7e <z_impl_k_mutex_lock>:
		z_thread_priority_set(mutex->owner, new_prio);
	}
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
80041e7e:	7179                	addi	sp,sp,-48
80041e80:	d422                	sw	s0,40(sp)
80041e82:	cc52                	sw	s4,24(sp)
80041e84:	842a                	mv	s0,a0
80041e86:	d606                	sw	ra,44(sp)
80041e88:	d226                	sw	s1,36(sp)
80041e8a:	d04a                	sw	s2,32(sp)
80041e8c:	ce4e                	sw	s3,28(sp)
80041e8e:	ca56                	sw	s5,20(sp)
80041e90:	8a2e                	mv	s4,a1
	int new_prio;
	k_spinlock_key_t key;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	z_sched_lock();
80041e92:	3f1d                	jal	80041dc8 <z_sched_lock>

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
80041e94:	4458                	lw	a4,12(s0)
80041e96:	800457b7          	lui	a5,0x80045
80041e9a:	1e878793          	addi	a5,a5,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
80041e9e:	cb19                	beqz	a4,80041eb4 <z_impl_k_mutex_lock+0x36>
80041ea0:	4410                	lw	a2,8(s0)
80041ea2:	4794                	lw	a3,8(a5)
80041ea4:	02d60c63          	beq	a2,a3,80041edc <z_impl_k_mutex_lock+0x5e>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
80041ea8:	020a1c63          	bnez	s4,80041ee0 <z_impl_k_mutex_lock+0x62>
		k_sched_unlock();
80041eac:	375000ef          	jal	ra,80042a20 <k_sched_unlock>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
80041eb0:	5541                	li	a0,-16
80041eb2:	a821                	j	80041eca <z_impl_k_mutex_lock+0x4c>
					_current->base.prio :
80041eb4:	4794                	lw	a3,8(a5)
80041eb6:	00e68683          	lb	a3,14(a3)
		mutex->owner = _current;
80041eba:	479c                	lw	a5,8(a5)
		mutex->lock_count++;
80041ebc:	0705                	addi	a4,a4,1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
80041ebe:	c814                	sw	a3,16(s0)
		mutex->lock_count++;
80041ec0:	c458                	sw	a4,12(s0)
		mutex->owner = _current;
80041ec2:	c41c                	sw	a5,8(s0)
		k_sched_unlock();
80041ec4:	35d000ef          	jal	ra,80042a20 <k_sched_unlock>
		return 0;
80041ec8:	4501                	li	a0,0

	k_sched_unlock();

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
80041eca:	50b2                	lw	ra,44(sp)
80041ecc:	5422                	lw	s0,40(sp)
80041ece:	5492                	lw	s1,36(sp)
80041ed0:	5902                	lw	s2,32(sp)
80041ed2:	49f2                	lw	s3,28(sp)
80041ed4:	4a62                	lw	s4,24(sp)
80041ed6:	4ad2                	lw	s5,20(sp)
80041ed8:	6145                	addi	sp,sp,48
80041eda:	8082                	ret
					_current->base.prio :
80041edc:	4814                	lw	a3,16(s0)
80041ede:	bff1                	j	80041eba <z_impl_k_mutex_lock+0x3c>
	new_prio = new_prio_for_inheritance(_current->base.prio,
80041ee0:	00e60783          	lb	a5,14(a2)
80041ee4:	00e68903          	lb	s2,14(a3)
80041ee8:	0127d363          	bge	a5,s2,80041eee <z_impl_k_mutex_lock+0x70>
80041eec:	893e                	mv	s2,a5
80041eee:	00095363          	bgez	s2,80041ef4 <z_impl_k_mutex_lock+0x76>
80041ef2:	4901                	li	s2,0
80041ef4:	49a1                	li	s3,8
80041ef6:	3009b9f3          	csrrc	s3,mstatus,s3
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80041efa:	800454b7          	lui	s1,0x80045
80041efe:	dd048513          	addi	a0,s1,-560 # 80044dd0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd1>
	key = (mstatus & SOC_MSTATUS_IEN);
80041f02:	0089f993          	andi	s3,s3,8
80041f06:	68c010ef          	jal	ra,80043592 <z_spin_lock_valid>
80041f0a:	ed0d                	bnez	a0,80041f44 <z_impl_k_mutex_lock+0xc6>
80041f0c:	80045ab7          	lui	s5,0x80045
80041f10:	800455b7          	lui	a1,0x80045
80041f14:	80045537          	lui	a0,0x80045
80041f18:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80041f1c:	04e00693          	li	a3,78
80041f20:	990a8613          	addi	a2,s5,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80041f24:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80041f28:	feeff0ef          	jal	ra,80041716 <printk>
80041f2c:	80045537          	lui	a0,0x80045
80041f30:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80041f34:	fe2ff0ef          	jal	ra,80041716 <printk>
80041f38:	04e00593          	li	a1,78
80041f3c:	990a8513          	addi	a0,s5,-1648
80041f40:	ff4ff0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80041f44:	dd048513          	addi	a0,s1,-560
80041f48:	686010ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
80041f4c:	4408                	lw	a0,8(s0)
80041f4e:	00e50783          	lb	a5,14(a0)
80041f52:	00f95563          	bge	s2,a5,80041f5c <z_impl_k_mutex_lock+0xde>
		z_thread_priority_set(mutex->owner, new_prio);
80041f56:	85ca                	mv	a1,s2
80041f58:	168010ef          	jal	ra,800430c0 <z_thread_priority_set>
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
80041f5c:	86d2                	mv	a3,s4
80041f5e:	8622                	mv	a2,s0
80041f60:	85ce                	mv	a1,s3
80041f62:	dd048513          	addi	a0,s1,-560
80041f66:	0f4010ef          	jal	ra,8004305a <z_pend_curr>
	if (got_mutex == 0) {
80041f6a:	c62a                	sw	a0,12(sp)
80041f6c:	e509                	bnez	a0,80041f76 <z_impl_k_mutex_lock+0xf8>
		k_sched_unlock();
80041f6e:	2b3000ef          	jal	ra,80042a20 <k_sched_unlock>
		return 0;
80041f72:	4532                	lw	a0,12(sp)
80041f74:	bf99                	j	80041eca <z_impl_k_mutex_lock+0x4c>
	return list->head == list;
80041f76:	401c                	lw	a5,0(s0)
80041f78:	01042983          	lw	s3,16(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80041f7c:	00f40b63          	beq	s0,a5,80041f92 <z_impl_k_mutex_lock+0x114>
		new_prio_for_inheritance(waiter->base.prio, new_prio) :
80041f80:	cb89                	beqz	a5,80041f92 <z_impl_k_mutex_lock+0x114>
80041f82:	00e78783          	lb	a5,14(a5)
80041f86:	0137d363          	bge	a5,s3,80041f8c <z_impl_k_mutex_lock+0x10e>
80041f8a:	89be                	mv	s3,a5
80041f8c:	0009d363          	bgez	s3,80041f92 <z_impl_k_mutex_lock+0x114>
80041f90:	4981                	li	s3,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041f92:	4921                	li	s2,8
80041f94:	30093973          	csrrc	s2,mstatus,s2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80041f98:	dd048513          	addi	a0,s1,-560
	key = (mstatus & SOC_MSTATUS_IEN);
80041f9c:	00897913          	andi	s2,s2,8
80041fa0:	5f2010ef          	jal	ra,80043592 <z_spin_lock_valid>
80041fa4:	ed0d                	bnez	a0,80041fde <z_impl_k_mutex_lock+0x160>
80041fa6:	80045a37          	lui	s4,0x80045
80041faa:	800455b7          	lui	a1,0x80045
80041fae:	80045537          	lui	a0,0x80045
80041fb2:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80041fb6:	04e00693          	li	a3,78
80041fba:	990a0613          	addi	a2,s4,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80041fbe:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80041fc2:	f54ff0ef          	jal	ra,80041716 <printk>
80041fc6:	80045537          	lui	a0,0x80045
80041fca:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80041fce:	f48ff0ef          	jal	ra,80041716 <printk>
80041fd2:	04e00593          	li	a1,78
80041fd6:	990a0513          	addi	a0,s4,-1648
80041fda:	f5aff0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80041fde:	dd048513          	addi	a0,s1,-560
80041fe2:	5ec010ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, new_prio);
80041fe6:	4408                	lw	a0,8(s0)
	if (mutex->owner->base.prio != new_prio) {
80041fe8:	00e50783          	lb	a5,14(a0)
80041fec:	00f98563          	beq	s3,a5,80041ff6 <z_impl_k_mutex_lock+0x178>
		z_thread_priority_set(mutex->owner, new_prio);
80041ff0:	85ce                	mv	a1,s3
80041ff2:	0ce010ef          	jal	ra,800430c0 <z_thread_priority_set>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80041ff6:	dd048513          	addi	a0,s1,-560
80041ffa:	5b2010ef          	jal	ra,800435ac <z_spin_unlock_valid>
80041ffe:	ed0d                	bnez	a0,80042038 <z_impl_k_mutex_lock+0x1ba>
80042000:	80045437          	lui	s0,0x80045
80042004:	800455b7          	lui	a1,0x80045
80042008:	80045537          	lui	a0,0x80045
8004200c:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042010:	06100693          	li	a3,97
80042014:	99040613          	addi	a2,s0,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042018:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004201c:	efaff0ef          	jal	ra,80041716 <printk>
80042020:	80045537          	lui	a0,0x80045
80042024:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80042028:	eeeff0ef          	jal	ra,80041716 <printk>
8004202c:	06100593          	li	a1,97
80042030:	99040513          	addi	a0,s0,-1648
80042034:	f00ff0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042038:	30092973          	csrrs	s2,mstatus,s2
	k_sched_unlock();
8004203c:	1e5000ef          	jal	ra,80042a20 <k_sched_unlock>
	return -EAGAIN;
80042040:	5555                	li	a0,-11
80042042:	b561                	j	80041eca <z_impl_k_mutex_lock+0x4c>

80042044 <z_impl_k_mutex_unlock>:

void z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
	struct k_thread *new_owner;

	__ASSERT(mutex->lock_count > 0U, "");
80042044:	455c                	lw	a5,12(a0)
{
80042046:	1101                	addi	sp,sp,-32
80042048:	cc22                	sw	s0,24(sp)
8004204a:	ce06                	sw	ra,28(sp)
8004204c:	ca26                	sw	s1,20(sp)
8004204e:	c84a                	sw	s2,16(sp)
80042050:	c64e                	sw	s3,12(sp)
80042052:	842a                	mv	s0,a0
	__ASSERT(mutex->lock_count > 0U, "");
80042054:	ef8d                	bnez	a5,8004208e <z_impl_k_mutex_unlock+0x4a>
80042056:	800454b7          	lui	s1,0x80045
8004205a:	800455b7          	lui	a1,0x80045
8004205e:	80045537          	lui	a0,0x80045
80042062:	ab458593          	addi	a1,a1,-1356 # 80044ab4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044ab5>
80042066:	0d400693          	li	a3,212
8004206a:	a9048613          	addi	a2,s1,-1392 # 80044a90 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a91>
8004206e:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042072:	ea4ff0ef          	jal	ra,80041716 <printk>
80042076:	80045537          	lui	a0,0x80045
8004207a:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
8004207e:	e98ff0ef          	jal	ra,80041716 <printk>
80042082:	0d400593          	li	a1,212
80042086:	a9048513          	addi	a0,s1,-1392
8004208a:	eaaff0ef          	jal	ra,80041734 <assert_post_action>
	__ASSERT(mutex->owner == _current, "");
8004208e:	800457b7          	lui	a5,0x80045
80042092:	4418                	lw	a4,8(s0)
80042094:	1f07a783          	lw	a5,496(a5) # 800451f0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451f1>
80042098:	02f70e63          	beq	a4,a5,800420d4 <z_impl_k_mutex_unlock+0x90>
8004209c:	800454b7          	lui	s1,0x80045
800420a0:	800455b7          	lui	a1,0x80045
800420a4:	80045537          	lui	a0,0x80045
800420a8:	acc58593          	addi	a1,a1,-1332 # 80044acc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044acd>
800420ac:	0d500693          	li	a3,213
800420b0:	a9048613          	addi	a2,s1,-1392 # 80044a90 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a91>
800420b4:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800420b8:	e5eff0ef          	jal	ra,80041716 <printk>
800420bc:	80045537          	lui	a0,0x80045
800420c0:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
800420c4:	e52ff0ef          	jal	ra,80041716 <printk>
800420c8:	0d500593          	li	a1,213
800420cc:	a9048513          	addi	a0,s1,-1392
800420d0:	e64ff0ef          	jal	ra,80041734 <assert_post_action>

	sys_trace_void(SYS_TRACE_ID_MUTEX_UNLOCK);
	z_sched_lock();
800420d4:	39d5                	jal	80041dc8 <z_sched_lock>

	K_DEBUG("mutex %p lock_count: %d\n", mutex, mutex->lock_count);

	if (mutex->lock_count - 1U != 0U) {
800420d6:	445c                	lw	a5,12(s0)
800420d8:	4705                	li	a4,1
800420da:	00e78c63          	beq	a5,a4,800420f2 <z_impl_k_mutex_unlock+0xae>
		mutex->lock_count--;
800420de:	17fd                	addi	a5,a5,-1
800420e0:	c45c                	sw	a5,12(s0)
	}


k_mutex_unlock_return:
	k_sched_unlock();
}
800420e2:	4462                	lw	s0,24(sp)
800420e4:	40f2                	lw	ra,28(sp)
800420e6:	44d2                	lw	s1,20(sp)
800420e8:	4942                	lw	s2,16(sp)
800420ea:	49b2                	lw	s3,12(sp)
800420ec:	6105                	addi	sp,sp,32
	k_sched_unlock();
800420ee:	1330006f          	j	80042a20 <k_sched_unlock>
	__asm__ volatile ("csrrc %0, mstatus, %1"
800420f2:	44a1                	li	s1,8
800420f4:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
800420f8:	80045937          	lui	s2,0x80045
800420fc:	dd090513          	addi	a0,s2,-560 # 80044dd0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd1>
	key = (mstatus & SOC_MSTATUS_IEN);
80042100:	88a1                	andi	s1,s1,8
80042102:	490010ef          	jal	ra,80043592 <z_spin_lock_valid>
80042106:	ed0d                	bnez	a0,80042140 <z_impl_k_mutex_unlock+0xfc>
80042108:	800459b7          	lui	s3,0x80045
8004210c:	800455b7          	lui	a1,0x80045
80042110:	80045537          	lui	a0,0x80045
80042114:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80042118:	04e00693          	li	a3,78
8004211c:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042120:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042124:	df2ff0ef          	jal	ra,80041716 <printk>
80042128:	80045537          	lui	a0,0x80045
8004212c:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80042130:	de6ff0ef          	jal	ra,80041716 <printk>
80042134:	04e00593          	li	a1,78
80042138:	99098513          	addi	a0,s3,-1648
8004213c:	df8ff0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80042140:	dd090513          	addi	a0,s2,-560
80042144:	48a010ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
80042148:	4408                	lw	a0,8(s0)
8004214a:	480c                	lw	a1,16(s0)
	if (mutex->owner->base.prio != new_prio) {
8004214c:	00e50783          	lb	a5,14(a0)
80042150:	00f58463          	beq	a1,a5,80042158 <z_impl_k_mutex_unlock+0x114>
		z_thread_priority_set(mutex->owner, new_prio);
80042154:	76d000ef          	jal	ra,800430c0 <z_thread_priority_set>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
80042158:	8522                	mv	a0,s0
8004215a:	2379                	jal	800426e8 <z_unpend_first_thread>
	mutex->owner = new_owner;
8004215c:	c408                	sw	a0,8(s0)
	new_owner = z_unpend_first_thread(&mutex->wait_q);
8004215e:	89aa                	mv	s3,a0
	if (new_owner != NULL) {
80042160:	c135                	beqz	a0,800421c4 <z_impl_k_mutex_unlock+0x180>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
80042162:	00d54783          	lbu	a5,13(a0)
80042166:	8bfd                	andi	a5,a5,31
80042168:	e789                	bnez	a5,80042172 <z_impl_k_mutex_unlock+0x12e>
	if (z_is_thread_ready(thread)) {
8004216a:	4d1c                	lw	a5,24(a0)
8004216c:	e399                	bnez	a5,80042172 <z_impl_k_mutex_unlock+0x12e>
		z_add_thread_to_ready_q(thread);
8004216e:	207000ef          	jal	ra,80042b74 <z_add_thread_to_ready_q>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042172:	dd090513          	addi	a0,s2,-560
80042176:	436010ef          	jal	ra,800435ac <z_spin_unlock_valid>
8004217a:	ed0d                	bnez	a0,800421b4 <z_impl_k_mutex_unlock+0x170>
8004217c:	80045937          	lui	s2,0x80045
80042180:	800455b7          	lui	a1,0x80045
80042184:	80045537          	lui	a0,0x80045
80042188:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
8004218c:	06100693          	li	a3,97
80042190:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042194:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042198:	d7eff0ef          	jal	ra,80041716 <printk>
8004219c:	80045537          	lui	a0,0x80045
800421a0:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
800421a4:	d72ff0ef          	jal	ra,80041716 <printk>
800421a8:	06100593          	li	a1,97
800421ac:	99090513          	addi	a0,s2,-1648
800421b0:	d84ff0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
800421b4:	3004a4f3          	csrrs	s1,mstatus,s1
		mutex->owner_orig_prio = new_owner->base.prio;
800421b8:	00e98783          	lb	a5,14(s3)
}

static ALWAYS_INLINE void
z_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
800421bc:	0609a623          	sw	zero,108(s3)
800421c0:	c81c                	sw	a5,16(s0)
800421c2:	b705                	j	800420e2 <z_impl_k_mutex_unlock+0x9e>
		mutex->lock_count = 0U;
800421c4:	00042623          	sw	zero,12(s0)
800421c8:	dd090513          	addi	a0,s2,-560
800421cc:	3e0010ef          	jal	ra,800435ac <z_spin_unlock_valid>
800421d0:	ed0d                	bnez	a0,8004220a <z_impl_k_mutex_unlock+0x1c6>
800421d2:	80045437          	lui	s0,0x80045
800421d6:	800455b7          	lui	a1,0x80045
800421da:	80045537          	lui	a0,0x80045
800421de:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
800421e2:	06100693          	li	a3,97
800421e6:	99040613          	addi	a2,s0,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
800421ea:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800421ee:	d28ff0ef          	jal	ra,80041716 <printk>
800421f2:	80045537          	lui	a0,0x80045
800421f6:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
800421fa:	d1cff0ef          	jal	ra,80041716 <printk>
800421fe:	06100593          	li	a1,97
80042202:	99040513          	addi	a0,s0,-1648
80042206:	d2eff0ef          	jal	ra,80041734 <assert_post_action>
8004220a:	3004a4f3          	csrrs	s1,mstatus,s1
8004220e:	bdd1                	j	800420e2 <z_impl_k_mutex_unlock+0x9e>

80042210 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
80042210:	00d54783          	lbu	a5,13(a0)
80042214:	8bfd                	andi	a5,a5,31
80042216:	e789                	bnez	a5,80042220 <z_is_thread_ready+0x10>
80042218:	4d08                	lw	a0,24(a0)
8004221a:	00153513          	seqz	a0,a0
8004221e:	8082                	ret
80042220:	4501                	li	a0,0
}
80042222:	8082                	ret

80042224 <z_priq_rb_lessthan>:
#endif
}

bool z_is_t1_higher_prio_than_t2(struct k_thread *t1, struct k_thread *t2)
{
	if (t1->base.prio < t2->base.prio) {
80042224:	00e50703          	lb	a4,14(a0)
80042228:	00e58683          	lb	a3,14(a1)

	ta = CONTAINER_OF(a, struct k_thread, base.qnode_rb);
	tb = CONTAINER_OF(b, struct k_thread, base.qnode_rb);

	if (z_is_t1_higher_prio_than_t2(ta, tb)) {
		return true;
8004222c:	4785                	li	a5,1
	if (t1->base.prio < t2->base.prio) {
8004222e:	00d74963          	blt	a4,a3,80042240 <z_priq_rb_lessthan+0x1c>
	} else if (z_is_t1_higher_prio_than_t2(tb, ta)) {
		return false;
80042232:	4781                	li	a5,0
	if (t1->base.prio < t2->base.prio) {
80042234:	00e6c663          	blt	a3,a4,80042240 <z_priq_rb_lessthan+0x1c>
	} else {
		return ta->base.order_key < tb->base.order_key ? 1 : 0;
80042238:	491c                	lw	a5,16(a0)
8004223a:	4988                	lw	a0,16(a1)
8004223c:	00a7b7b3          	sltu	a5,a5,a0
	}
}
80042240:	853e                	mv	a0,a5
80042242:	8082                	ret

80042244 <reset_time_slice>:
{
80042244:	1141                	addi	sp,sp,-16
80042246:	c606                	sw	ra,12(sp)
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
80042248:	803ff0ef          	jal	ra,80041a4a <z_clock_elapsed>
8004224c:	800457b7          	lui	a5,0x80045
80042250:	ddc7a783          	lw	a5,-548(a5) # 80044ddc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044ddd>
}
80042254:	40b2                	lw	ra,12(sp)
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
80042256:	80045737          	lui	a4,0x80045
8004225a:	953e                	add	a0,a0,a5
8004225c:	1ea72c23          	sw	a0,504(a4) # 800451f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451f9>
	z_set_timeout_expiry(slice_time, false);
80042260:	4581                	li	a1,0
80042262:	853e                	mv	a0,a5
}
80042264:	0141                	addi	sp,sp,16
	z_set_timeout_expiry(slice_time, false);
80042266:	2530106f          	j	80043cb8 <z_set_timeout_expiry>

8004226a <pended_on.isra.15>:
	__ASSERT_NO_MSG(thread->base.pended_on);
8004226a:	411c                	lw	a5,0(a0)
static _wait_q_t *pended_on(struct k_thread *thread)
8004226c:	1141                	addi	sp,sp,-16
8004226e:	c422                	sw	s0,8(sp)
80042270:	c606                	sw	ra,12(sp)
80042272:	c226                	sw	s1,4(sp)
80042274:	842a                	mv	s0,a0
	__ASSERT_NO_MSG(thread->base.pended_on);
80042276:	e79d                	bnez	a5,800422a4 <pended_on.isra.15+0x3a>
80042278:	800454b7          	lui	s1,0x80045
8004227c:	800455b7          	lui	a1,0x80045
80042280:	80045537          	lui	a0,0x80045
80042284:	ba858593          	addi	a1,a1,-1112 # 80044ba8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044ba9>
80042288:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004228c:	18300693          	li	a3,387
80042290:	b8448613          	addi	a2,s1,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
80042294:	c82ff0ef          	jal	ra,80041716 <printk>
80042298:	18300593          	li	a1,387
8004229c:	b8448513          	addi	a0,s1,-1148
800422a0:	c94ff0ef          	jal	ra,80041734 <assert_post_action>
}
800422a4:	4008                	lw	a0,0(s0)
800422a6:	40b2                	lw	ra,12(sp)
800422a8:	4422                	lw	s0,8(sp)
800422aa:	4492                	lw	s1,4(sp)
800422ac:	0141                	addi	sp,sp,16
800422ae:	8082                	ret

800422b0 <k_sched_time_slice_set>:
{
800422b0:	1101                	addi	sp,sp,-32
800422b2:	cc22                	sw	s0,24(sp)
800422b4:	c84a                	sw	s2,16(sp)
800422b6:	c452                	sw	s4,8(sp)
800422b8:	ce06                	sw	ra,28(sp)
800422ba:	ca26                	sw	s1,20(sp)
800422bc:	c64e                	sw	s3,12(sp)
800422be:	892a                	mv	s2,a0
800422c0:	8a2e                	mv	s4,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
800422c2:	4421                	li	s0,8
800422c4:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
800422c8:	800454b7          	lui	s1,0x80045
800422cc:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
800422d0:	8821                	andi	s0,s0,8
800422d2:	2c0010ef          	jal	ra,80043592 <z_spin_lock_valid>
800422d6:	ed0d                	bnez	a0,80042310 <k_sched_time_slice_set+0x60>
800422d8:	800459b7          	lui	s3,0x80045
800422dc:	800455b7          	lui	a1,0x80045
800422e0:	80045537          	lui	a0,0x80045
800422e4:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
800422e8:	04e00693          	li	a3,78
800422ec:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
800422f0:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800422f4:	c22ff0ef          	jal	ra,80041716 <printk>
800422f8:	80045537          	lui	a0,0x80045
800422fc:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80042300:	c16ff0ef          	jal	ra,80041716 <printk>
80042304:	04e00593          	li	a1,78
80042308:	99098513          	addi	a0,s3,-1648
8004230c:	c28ff0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80042310:	dd448513          	addi	a0,s1,-556
80042314:	2ba010ef          	jal	ra,800435ce <z_spin_lock_set_owner>
		_current_cpu->slice_ticks = 0;
80042318:	800457b7          	lui	a5,0x80045
8004231c:	1e07ac23          	sw	zero,504(a5) # 800451f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451f9>
		CONFIG_SYS_CLOCK_TICKS_PER_SEC);
#else
	/* simple division keeps precision */
	s32_t ms_per_tick = MSEC_PER_SEC / CONFIG_SYS_CLOCK_TICKS_PER_SEC;

	return (s32_t)ceiling_fraction(ms, ms_per_tick);
80042320:	0925                	addi	s2,s2,9
80042322:	47a9                	li	a5,10
80042324:	02f94933          	div	s2,s2,a5
		slice_time = z_ms_to_ticks(slice);
80042328:	800457b7          	lui	a5,0x80045
8004232c:	dd27ae23          	sw	s2,-548(a5) # 80044ddc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044ddd>
		slice_max_prio = prio;
80042330:	800457b7          	lui	a5,0x80045
80042334:	dd47ac23          	sw	s4,-552(a5) # 80044dd8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd9>
		reset_time_slice();
80042338:	3731                	jal	80042244 <reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
8004233a:	dd448513          	addi	a0,s1,-556
8004233e:	26e010ef          	jal	ra,800435ac <z_spin_unlock_valid>
80042342:	ed0d                	bnez	a0,8004237c <k_sched_time_slice_set+0xcc>
80042344:	800454b7          	lui	s1,0x80045
80042348:	800455b7          	lui	a1,0x80045
8004234c:	80045537          	lui	a0,0x80045
80042350:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042354:	06100693          	li	a3,97
80042358:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
8004235c:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042360:	bb6ff0ef          	jal	ra,80041716 <printk>
80042364:	80045537          	lui	a0,0x80045
80042368:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
8004236c:	baaff0ef          	jal	ra,80041716 <printk>
80042370:	06100593          	li	a1,97
80042374:	99048513          	addi	a0,s1,-1648
80042378:	bbcff0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004237c:	30042473          	csrrs	s0,mstatus,s0
}
80042380:	40f2                	lw	ra,28(sp)
80042382:	4462                	lw	s0,24(sp)
80042384:	44d2                	lw	s1,20(sp)
80042386:	4942                	lw	s2,16(sp)
80042388:	49b2                	lw	s3,12(sp)
8004238a:	4a22                	lw	s4,8(sp)
8004238c:	6105                	addi	sp,sp,32
8004238e:	8082                	ret

80042390 <z_unpend_thread_no_timeout>:
{
80042390:	1101                	addi	sp,sp,-32
80042392:	cc22                	sw	s0,24(sp)
80042394:	c84a                	sw	s2,16(sp)
80042396:	ce06                	sw	ra,28(sp)
80042398:	ca26                	sw	s1,20(sp)
8004239a:	c64e                	sw	s3,12(sp)
8004239c:	892a                	mv	s2,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
8004239e:	4421                	li	s0,8
800423a0:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
800423a4:	800454b7          	lui	s1,0x80045
800423a8:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
800423ac:	8821                	andi	s0,s0,8
800423ae:	1e4010ef          	jal	ra,80043592 <z_spin_lock_valid>
800423b2:	ed0d                	bnez	a0,800423ec <z_unpend_thread_no_timeout+0x5c>
800423b4:	800459b7          	lui	s3,0x80045
800423b8:	800455b7          	lui	a1,0x80045
800423bc:	80045537          	lui	a0,0x80045
800423c0:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
800423c4:	04e00693          	li	a3,78
800423c8:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
800423cc:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800423d0:	b46ff0ef          	jal	ra,80041716 <printk>
800423d4:	80045537          	lui	a0,0x80045
800423d8:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
800423dc:	b3aff0ef          	jal	ra,80041716 <printk>
800423e0:	04e00593          	li	a1,78
800423e4:	99098513          	addi	a0,s3,-1648
800423e8:	b4cff0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
800423ec:	dd448513          	addi	a0,s1,-556
800423f0:	1de010ef          	jal	ra,800435ce <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
800423f4:	00890513          	addi	a0,s2,8
800423f8:	3d8d                	jal	8004226a <pended_on.isra.15>
800423fa:	85ca                	mv	a1,s2
800423fc:	2451                	jal	80042680 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
800423fe:	00d94783          	lbu	a5,13(s2)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042402:	dd448513          	addi	a0,s1,-556
80042406:	9bf5                	andi	a5,a5,-3
80042408:	00f906a3          	sb	a5,13(s2)
8004240c:	1a0010ef          	jal	ra,800435ac <z_spin_unlock_valid>
80042410:	ed0d                	bnez	a0,8004244a <z_unpend_thread_no_timeout+0xba>
80042412:	800454b7          	lui	s1,0x80045
80042416:	800455b7          	lui	a1,0x80045
8004241a:	80045537          	lui	a0,0x80045
8004241e:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042422:	06100693          	li	a3,97
80042426:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
8004242a:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004242e:	ae8ff0ef          	jal	ra,80041716 <printk>
80042432:	80045537          	lui	a0,0x80045
80042436:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
8004243a:	adcff0ef          	jal	ra,80041716 <printk>
8004243e:	06100593          	li	a1,97
80042442:	99048513          	addi	a0,s1,-1648
80042446:	aeeff0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004244a:	30042473          	csrrs	s0,mstatus,s0
}
8004244e:	40f2                	lw	ra,28(sp)
80042450:	4462                	lw	s0,24(sp)
	thread->base.pended_on = NULL;
80042452:	00092423          	sw	zero,8(s2)
}
80042456:	44d2                	lw	s1,20(sp)
80042458:	4942                	lw	s2,16(sp)
8004245a:	49b2                	lw	s3,12(sp)
8004245c:	6105                	addi	sp,sp,32
8004245e:	8082                	ret

80042460 <z_reschedule>:
	if (resched()) {
80042460:	800457b7          	lui	a5,0x80045
80042464:	1e87a783          	lw	a5,488(a5) # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
{
80042468:	1141                	addi	sp,sp,-16
8004246a:	c422                	sw	s0,8(sp)
8004246c:	c606                	sw	ra,12(sp)
8004246e:	c226                	sw	s1,4(sp)
80042470:	842e                	mv	s0,a1
	if (resched()) {
80042472:	e7b9                	bnez	a5,800424c0 <z_reschedule+0x60>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042474:	138010ef          	jal	ra,800435ac <z_spin_unlock_valid>
80042478:	ed0d                	bnez	a0,800424b2 <z_reschedule+0x52>
8004247a:	800454b7          	lui	s1,0x80045
8004247e:	800455b7          	lui	a1,0x80045
80042482:	80045537          	lui	a0,0x80045
80042486:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
8004248a:	07800693          	li	a3,120
8004248e:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042492:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042496:	a80ff0ef          	jal	ra,80041716 <printk>
8004249a:	80045537          	lui	a0,0x80045
8004249e:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
800424a2:	a74ff0ef          	jal	ra,80041716 <printk>
800424a6:	07800593          	li	a1,120
800424aa:	99048513          	addi	a0,s1,-1648
800424ae:	a86ff0ef          	jal	ra,80041734 <assert_post_action>
800424b2:	8522                	mv	a0,s0
}
800424b4:	4422                	lw	s0,8(sp)
800424b6:	40b2                	lw	ra,12(sp)
800424b8:	4492                	lw	s1,4(sp)
800424ba:	0141                	addi	sp,sp,16
800424bc:	d05fd06f          	j	800401c0 <__swap>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
800424c0:	0ec010ef          	jal	ra,800435ac <z_spin_unlock_valid>
800424c4:	ed0d                	bnez	a0,800424fe <z_reschedule+0x9e>
800424c6:	800454b7          	lui	s1,0x80045
800424ca:	800455b7          	lui	a1,0x80045
800424ce:	80045537          	lui	a0,0x80045
800424d2:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
800424d6:	06100693          	li	a3,97
800424da:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
800424de:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800424e2:	a34ff0ef          	jal	ra,80041716 <printk>
800424e6:	80045537          	lui	a0,0x80045
800424ea:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
800424ee:	a28ff0ef          	jal	ra,80041716 <printk>
800424f2:	06100593          	li	a1,97
800424f6:	99048513          	addi	a0,s1,-1648
800424fa:	a3aff0ef          	jal	ra,80041734 <assert_post_action>
			  : "=r" (mstatus)
			  : "r" (key & SOC_MSTATUS_IEN)
800424fe:	8821                	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042500:	30042473          	csrrs	s0,mstatus,s0
80042504:	40b2                	lw	ra,12(sp)
80042506:	4422                	lw	s0,8(sp)
80042508:	4492                	lw	s1,4(sp)
8004250a:	0141                	addi	sp,sp,16
8004250c:	8082                	ret

8004250e <z_reschedule_irqlock>:
	if (resched()) {
8004250e:	80045737          	lui	a4,0x80045
80042512:	1e872703          	lw	a4,488(a4) # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
80042516:	e319                	bnez	a4,8004251c <z_reschedule_irqlock+0xe>
80042518:	ca9fd06f          	j	800401c0 <__swap>
			  : "r" (key & SOC_MSTATUS_IEN)
8004251c:	00857793          	andi	a5,a0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042520:	3007a7f3          	csrrs	a5,mstatus,a5
}
80042524:	8082                	ret

80042526 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
80042526:	4521                	li	a0,8
80042528:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(z_arch_irq_lock());
8004252c:	8921                	andi	a0,a0,8
8004252e:	b7c5                	j	8004250e <z_reschedule_irqlock>

80042530 <k_sched_lock>:
{
80042530:	1101                	addi	sp,sp,-32
80042532:	cc22                	sw	s0,24(sp)
80042534:	ce06                	sw	ra,28(sp)
80042536:	ca26                	sw	s1,20(sp)
80042538:	c84a                	sw	s2,16(sp)
8004253a:	c64e                	sw	s3,12(sp)
8004253c:	4421                	li	s0,8
8004253e:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80042542:	800454b7          	lui	s1,0x80045
80042546:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
8004254a:	8821                	andi	s0,s0,8
8004254c:	046010ef          	jal	ra,80043592 <z_spin_lock_valid>
80042550:	ed0d                	bnez	a0,8004258a <k_sched_lock+0x5a>
80042552:	80045937          	lui	s2,0x80045
80042556:	800455b7          	lui	a1,0x80045
8004255a:	80045537          	lui	a0,0x80045
8004255e:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80042562:	04e00693          	li	a3,78
80042566:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
8004256a:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004256e:	9a8ff0ef          	jal	ra,80041716 <printk>
80042572:	80045537          	lui	a0,0x80045
80042576:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
8004257a:	99cff0ef          	jal	ra,80041716 <printk>
8004257e:	04e00593          	li	a1,78
80042582:	99090513          	addi	a0,s2,-1648
80042586:	9aeff0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
8004258a:	dd448513          	addi	a0,s1,-556
	__ASSERT(!z_is_in_isr(), "");
8004258e:	80045937          	lui	s2,0x80045
80042592:	03c010ef          	jal	ra,800435ce <z_spin_lock_set_owner>
80042596:	1e892783          	lw	a5,488(s2) # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
8004259a:	1e890913          	addi	s2,s2,488
8004259e:	cf8d                	beqz	a5,800425d8 <k_sched_lock+0xa8>
800425a0:	800459b7          	lui	s3,0x80045
800425a4:	800455b7          	lui	a1,0x80045
800425a8:	80045537          	lui	a0,0x80045
800425ac:	b1858593          	addi	a1,a1,-1256 # 80044b18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b19>
800425b0:	10000693          	li	a3,256
800425b4:	aec98613          	addi	a2,s3,-1300 # 80044aec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044aed>
800425b8:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800425bc:	95aff0ef          	jal	ra,80041716 <printk>
800425c0:	80045537          	lui	a0,0x80045
800425c4:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
800425c8:	94eff0ef          	jal	ra,80041716 <printk>
800425cc:	10000593          	li	a1,256
800425d0:	aec98513          	addi	a0,s3,-1300
800425d4:	960ff0ef          	jal	ra,80041734 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
800425d8:	00892783          	lw	a5,8(s2)
800425dc:	00f7c703          	lbu	a4,15(a5)
800425e0:	4785                	li	a5,1
800425e2:	02f71e63          	bne	a4,a5,8004261e <k_sched_lock+0xee>
800425e6:	800459b7          	lui	s3,0x80045
800425ea:	800455b7          	lui	a1,0x80045
800425ee:	80045537          	lui	a0,0x80045
800425f2:	b3458593          	addi	a1,a1,-1228 # 80044b34 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b35>
800425f6:	10100693          	li	a3,257
800425fa:	aec98613          	addi	a2,s3,-1300 # 80044aec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044aed>
800425fe:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042602:	914ff0ef          	jal	ra,80041716 <printk>
80042606:	80045537          	lui	a0,0x80045
8004260a:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
8004260e:	908ff0ef          	jal	ra,80041716 <printk>
80042612:	10100593          	li	a1,257
80042616:	aec98513          	addi	a0,s3,-1300
8004261a:	91aff0ef          	jal	ra,80041734 <assert_post_action>
	--_current->base.sched_locked;
8004261e:	00892703          	lw	a4,8(s2)
80042622:	00f74783          	lbu	a5,15(a4)
80042626:	17fd                	addi	a5,a5,-1
80042628:	00f707a3          	sb	a5,15(a4)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
8004262c:	dd448513          	addi	a0,s1,-556
80042630:	77d000ef          	jal	ra,800435ac <z_spin_unlock_valid>
80042634:	ed0d                	bnez	a0,8004266e <k_sched_lock+0x13e>
80042636:	800454b7          	lui	s1,0x80045
8004263a:	800455b7          	lui	a1,0x80045
8004263e:	80045537          	lui	a0,0x80045
80042642:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042646:	06100693          	li	a3,97
8004264a:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
8004264e:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042652:	8c4ff0ef          	jal	ra,80041716 <printk>
80042656:	80045537          	lui	a0,0x80045
8004265a:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
8004265e:	8b8ff0ef          	jal	ra,80041716 <printk>
80042662:	06100593          	li	a1,97
80042666:	99048513          	addi	a0,s1,-1648
8004266a:	8caff0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004266e:	30042473          	csrrs	s0,mstatus,s0
}
80042672:	40f2                	lw	ra,28(sp)
80042674:	4462                	lw	s0,24(sp)
80042676:	44d2                	lw	s1,20(sp)
80042678:	4942                	lw	s2,16(sp)
8004267a:	49b2                	lw	s3,12(sp)
8004267c:	6105                	addi	sp,sp,32
8004267e:	8082                	ret

80042680 <z_priq_dumb_remove>:
	return thread == _idle_thread;
80042680:	800457b7          	lui	a5,0x80045
	__ASSERT_NO_MSG(!is_idle(thread));
80042684:	d647a783          	lw	a5,-668(a5) # 80044d64 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d65>
{
80042688:	1141                	addi	sp,sp,-16
8004268a:	c422                	sw	s0,8(sp)
8004268c:	c606                	sw	ra,12(sp)
8004268e:	c226                	sw	s1,4(sp)
80042690:	842e                	mv	s0,a1
	__ASSERT_NO_MSG(!is_idle(thread));
80042692:	02f59863          	bne	a1,a5,800426c2 <z_priq_dumb_remove+0x42>
80042696:	800454b7          	lui	s1,0x80045
8004269a:	800455b7          	lui	a1,0x80045
8004269e:	80045537          	lui	a0,0x80045
800426a2:	c1858593          	addi	a1,a1,-1000 # 80044c18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044c19>
800426a6:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800426aa:	28c00693          	li	a3,652
800426ae:	b8448613          	addi	a2,s1,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
800426b2:	864ff0ef          	jal	ra,80041716 <printk>
800426b6:	28c00593          	li	a1,652
800426ba:	b8448513          	addi	a0,s1,-1148
800426be:	876ff0ef          	jal	ra,80041734 <assert_post_action>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
800426c2:	4058                	lw	a4,4(s0)
800426c4:	401c                	lw	a5,0(s0)
}
800426c6:	40b2                	lw	ra,12(sp)
800426c8:	4492                	lw	s1,4(sp)
800426ca:	c31c                	sw	a5,0(a4)
	node->next->prev = node->prev;
800426cc:	c3d8                	sw	a4,4(a5)
	node->next = NULL;
800426ce:	00042023          	sw	zero,0(s0)
	node->prev = NULL;
800426d2:	00042223          	sw	zero,4(s0)
800426d6:	4422                	lw	s0,8(sp)
800426d8:	0141                	addi	sp,sp,16
800426da:	8082                	ret

800426dc <z_priq_dumb_best>:
	return list->head == list;
800426dc:	411c                	lw	a5,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
800426de:	00f51363          	bne	a0,a5,800426e4 <z_priq_dumb_best+0x8>
	struct k_thread *t = NULL;
800426e2:	4781                	li	a5,0
}
800426e4:	853e                	mv	a0,a5
800426e6:	8082                	ret

800426e8 <z_unpend_first_thread>:
{
800426e8:	1101                	addi	sp,sp,-32
800426ea:	c84a                	sw	s2,16(sp)
800426ec:	c64e                	sw	s3,12(sp)
800426ee:	ce06                	sw	ra,28(sp)
800426f0:	cc22                	sw	s0,24(sp)
800426f2:	ca26                	sw	s1,20(sp)
800426f4:	89aa                	mv	s3,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
800426f6:	4921                	li	s2,8
800426f8:	30093973          	csrrc	s2,mstatus,s2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
800426fc:	800454b7          	lui	s1,0x80045
80042700:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
80042704:	00897913          	andi	s2,s2,8
80042708:	68b000ef          	jal	ra,80043592 <z_spin_lock_valid>
8004270c:	ed0d                	bnez	a0,80042746 <z_unpend_first_thread+0x5e>
8004270e:	80045437          	lui	s0,0x80045
80042712:	800455b7          	lui	a1,0x80045
80042716:	80045537          	lui	a0,0x80045
8004271a:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
8004271e:	04e00693          	li	a3,78
80042722:	99040613          	addi	a2,s0,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042726:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004272a:	fedfe0ef          	jal	ra,80041716 <printk>
8004272e:	80045537          	lui	a0,0x80045
80042732:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80042736:	fe1fe0ef          	jal	ra,80041716 <printk>
8004273a:	04e00593          	li	a1,78
8004273e:	99040513          	addi	a0,s0,-1648
80042742:	ff3fe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80042746:	dd448513          	addi	a0,s1,-556
8004274a:	685000ef          	jal	ra,800435ce <z_spin_lock_set_owner>
		ret = _priq_wait_best(&wait_q->waitq);
8004274e:	854e                	mv	a0,s3
80042750:	3771                	jal	800426dc <z_priq_dumb_best>
80042752:	842a                	mv	s0,a0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042754:	dd448513          	addi	a0,s1,-556
80042758:	655000ef          	jal	ra,800435ac <z_spin_unlock_valid>
8004275c:	ed0d                	bnez	a0,80042796 <z_unpend_first_thread+0xae>
8004275e:	800459b7          	lui	s3,0x80045
80042762:	800455b7          	lui	a1,0x80045
80042766:	80045537          	lui	a0,0x80045
8004276a:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
8004276e:	06100693          	li	a3,97
80042772:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042776:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004277a:	f9dfe0ef          	jal	ra,80041716 <printk>
8004277e:	80045537          	lui	a0,0x80045
80042782:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80042786:	f91fe0ef          	jal	ra,80041716 <printk>
8004278a:	06100593          	li	a1,97
8004278e:	99098513          	addi	a0,s3,-1648
80042792:	fa3fe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042796:	30092973          	csrrs	s2,mstatus,s2

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
8004279a:	cc5d                	beqz	s0,80042858 <z_unpend_first_thread+0x170>
	__asm__ volatile ("csrrc %0, mstatus, %1"
8004279c:	4921                	li	s2,8
8004279e:	30093973          	csrrc	s2,mstatus,s2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
800427a2:	dd448513          	addi	a0,s1,-556
	key = (mstatus & SOC_MSTATUS_IEN);
800427a6:	00897913          	andi	s2,s2,8
800427aa:	5e9000ef          	jal	ra,80043592 <z_spin_lock_valid>
800427ae:	ed0d                	bnez	a0,800427e8 <z_unpend_first_thread+0x100>
800427b0:	800459b7          	lui	s3,0x80045
800427b4:	800455b7          	lui	a1,0x80045
800427b8:	80045537          	lui	a0,0x80045
800427bc:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
800427c0:	04e00693          	li	a3,78
800427c4:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
800427c8:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800427cc:	f4bfe0ef          	jal	ra,80041716 <printk>
800427d0:	80045537          	lui	a0,0x80045
800427d4:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
800427d8:	f3ffe0ef          	jal	ra,80041716 <printk>
800427dc:	04e00593          	li	a1,78
800427e0:	99098513          	addi	a0,s3,-1648
800427e4:	f51fe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
800427e8:	dd448513          	addi	a0,s1,-556
800427ec:	5e3000ef          	jal	ra,800435ce <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
800427f0:	00840513          	addi	a0,s0,8
800427f4:	a77ff0ef          	jal	ra,8004226a <pended_on.isra.15>
800427f8:	85a2                	mv	a1,s0
800427fa:	3559                	jal	80042680 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
800427fc:	00d44783          	lbu	a5,13(s0)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042800:	dd448513          	addi	a0,s1,-556
80042804:	9bf5                	andi	a5,a5,-3
80042806:	00f406a3          	sb	a5,13(s0)
8004280a:	5a3000ef          	jal	ra,800435ac <z_spin_unlock_valid>
8004280e:	ed0d                	bnez	a0,80042848 <z_unpend_first_thread+0x160>
80042810:	800454b7          	lui	s1,0x80045
80042814:	800455b7          	lui	a1,0x80045
80042818:	80045537          	lui	a0,0x80045
8004281c:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042820:	06100693          	li	a3,97
80042824:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042828:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004282c:	eebfe0ef          	jal	ra,80041716 <printk>
80042830:	80045537          	lui	a0,0x80045
80042834:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80042838:	edffe0ef          	jal	ra,80041716 <printk>
8004283c:	06100593          	li	a1,97
80042840:	99048513          	addi	a0,s1,-1648
80042844:	ef1fe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042848:	30092973          	csrrs	s2,mstatus,s2
	thread->base.pended_on = NULL;
8004284c:	00042423          	sw	zero,8(s0)
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
80042850:	01840513          	addi	a0,s0,24
80042854:	2e0010ef          	jal	ra,80043b34 <z_abort_timeout>
}
80042858:	8522                	mv	a0,s0
8004285a:	40f2                	lw	ra,28(sp)
8004285c:	4462                	lw	s0,24(sp)
8004285e:	44d2                	lw	s1,20(sp)
80042860:	4942                	lw	s2,16(sp)
80042862:	49b2                	lw	s3,12(sp)
80042864:	6105                	addi	sp,sp,32
80042866:	8082                	ret

80042868 <z_priq_rb_add>:

void z_priq_rb_add(struct _priq_rb *pq, struct k_thread *thread)
{
80042868:	7179                	addi	sp,sp,-48
8004286a:	d422                	sw	s0,40(sp)
8004286c:	d226                	sw	s1,36(sp)
8004286e:	d04a                	sw	s2,32(sp)
80042870:	d606                	sw	ra,44(sp)
80042872:	ce4e                	sw	s3,28(sp)
80042874:	1800                	addi	s0,sp,48
	return thread == _idle_thread;
80042876:	800457b7          	lui	a5,0x80045
	struct k_thread *t;

	__ASSERT_NO_MSG(!is_idle(thread));
8004287a:	d647a783          	lw	a5,-668(a5) # 80044d64 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d65>
{
8004287e:	84aa                	mv	s1,a0
80042880:	892e                	mv	s2,a1
	__ASSERT_NO_MSG(!is_idle(thread));
80042882:	02f59863          	bne	a1,a5,800428b2 <z_priq_rb_add+0x4a>
80042886:	800459b7          	lui	s3,0x80045
8004288a:	800455b7          	lui	a1,0x80045
8004288e:	80045537          	lui	a0,0x80045
80042892:	c1858593          	addi	a1,a1,-1000 # 80044c18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044c19>
80042896:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004289a:	2b000693          	li	a3,688
8004289e:	b8498613          	addi	a2,s3,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
800428a2:	e75fe0ef          	jal	ra,80041716 <printk>
800428a6:	2b000593          	li	a1,688
800428aa:	b8498513          	addi	a0,s3,-1148
800428ae:	e87fe0ef          	jal	ra,80041734 <assert_post_action>

	thread->base.order_key = pq->next_order_key++;
800428b2:	44d8                	lw	a4,12(s1)
800428b4:	00170793          	addi	a5,a4,1
800428b8:	c4dc                	sw	a5,12(s1)
800428ba:	00e92823          	sw	a4,16(s2)
	 * will almost never be hit on real systems.  BUT on very
	 * long-running systems where a priq never completely empties
	 * AND that contains very large numbers of threads, it can be
	 * a latency glitch to loop over all the threads like this.
	 */
	if (!pq->next_order_key) {
800428be:	ef9d                	bnez	a5,800428fc <z_priq_rb_add+0x94>
		RB_FOR_EACH_CONTAINER(&pq->tree, t, base.qnode_rb) {
800428c0:	449c                	lw	a5,8(s1)
800428c2:	00279713          	slli	a4,a5,0x2
800428c6:	075d                	addi	a4,a4,23
800428c8:	9b41                	andi	a4,a4,-16
800428ca:	07dd                	addi	a5,a5,23
800428cc:	40e10133          	sub	sp,sp,a4
800428d0:	9bc1                	andi	a5,a5,-16
800428d2:	00f10713          	addi	a4,sp,15
800428d6:	40f10133          	sub	sp,sp,a5
800428da:	00f10793          	addi	a5,sp,15
800428de:	9bc1                	andi	a5,a5,-16
800428e0:	9b41                	andi	a4,a4,-16
800428e2:	fcf42c23          	sw	a5,-40(s0)
800428e6:	57fd                	li	a5,-1
800428e8:	fce42a23          	sw	a4,-44(s0)
800428ec:	fcf42e23          	sw	a5,-36(s0)
800428f0:	fd440593          	addi	a1,s0,-44
800428f4:	8526                	mv	a0,s1
800428f6:	989fe0ef          	jal	ra,8004127e <z_rb_foreach_next>
800428fa:	ed11                	bnez	a0,80042916 <z_priq_rb_add+0xae>
			t->base.order_key = pq->next_order_key++;
		}
	}

	rb_insert(&pq->tree, &thread->base.qnode_rb);
800428fc:	85ca                	mv	a1,s2
800428fe:	8526                	mv	a0,s1
80042900:	e6afe0ef          	jal	ra,80040f6a <rb_insert>
}
80042904:	fd040113          	addi	sp,s0,-48
80042908:	50b2                	lw	ra,44(sp)
8004290a:	5422                	lw	s0,40(sp)
8004290c:	5492                	lw	s1,36(sp)
8004290e:	5902                	lw	s2,32(sp)
80042910:	49f2                	lw	s3,28(sp)
80042912:	6145                	addi	sp,sp,48
80042914:	8082                	ret
			t->base.order_key = pq->next_order_key++;
80042916:	44dc                	lw	a5,12(s1)
80042918:	00178713          	addi	a4,a5,1
8004291c:	c4d8                	sw	a4,12(s1)
8004291e:	c91c                	sw	a5,16(a0)
80042920:	bfc1                	j	800428f0 <z_priq_rb_add+0x88>

80042922 <z_priq_rb_remove>:
	return thread == _idle_thread;
80042922:	800457b7          	lui	a5,0x80045
	if (pq == &_kernel.ready_q.runq && thread == _current &&
	    z_is_thread_prevented_from_running(thread)) {
		return;
	}
#endif
	__ASSERT_NO_MSG(!is_idle(thread));
80042926:	d647a783          	lw	a5,-668(a5) # 80044d64 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d65>
{
8004292a:	1141                	addi	sp,sp,-16
8004292c:	c422                	sw	s0,8(sp)
8004292e:	c226                	sw	s1,4(sp)
80042930:	c606                	sw	ra,12(sp)
80042932:	c04a                	sw	s2,0(sp)
80042934:	842a                	mv	s0,a0
80042936:	84ae                	mv	s1,a1
	__ASSERT_NO_MSG(!is_idle(thread));
80042938:	02f59863          	bne	a1,a5,80042968 <z_priq_rb_remove+0x46>
8004293c:	80045937          	lui	s2,0x80045
80042940:	800455b7          	lui	a1,0x80045
80042944:	80045537          	lui	a0,0x80045
80042948:	c1858593          	addi	a1,a1,-1000 # 80044c18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044c19>
8004294c:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042950:	2cb00693          	li	a3,715
80042954:	b8490613          	addi	a2,s2,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
80042958:	dbffe0ef          	jal	ra,80041716 <printk>
8004295c:	2cb00593          	li	a1,715
80042960:	b8490513          	addi	a0,s2,-1148
80042964:	dd1fe0ef          	jal	ra,80041734 <assert_post_action>

	rb_remove(&pq->tree, &thread->base.qnode_rb);
80042968:	85a6                	mv	a1,s1
8004296a:	8522                	mv	a0,s0
8004296c:	f4afe0ef          	jal	ra,800410b6 <rb_remove>

	if (!pq->tree.root) {
80042970:	401c                	lw	a5,0(s0)
80042972:	e399                	bnez	a5,80042978 <z_priq_rb_remove+0x56>
		pq->next_order_key = 0;
80042974:	00042623          	sw	zero,12(s0)
	}
}
80042978:	40b2                	lw	ra,12(sp)
8004297a:	4422                	lw	s0,8(sp)
8004297c:	4492                	lw	s1,4(sp)
8004297e:	4902                	lw	s2,0(sp)
80042980:	0141                	addi	sp,sp,16
80042982:	8082                	ret

80042984 <z_priq_rb_best>:
/**
 * @brief Returns the lowest-sorted member of the tree
 */
static inline struct rbnode *rb_get_min(struct rbtree *tree)
{
	return z_rb_get_minmax(tree, 0);
80042984:	4581                	li	a1,0
80042986:	dcefe06f          	j	80040f54 <z_rb_get_minmax>

8004298a <update_cache>:
{
8004298a:	1141                	addi	sp,sp,-16
8004298c:	c422                	sw	s0,8(sp)
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
8004298e:	80045437          	lui	s0,0x80045
{
80042992:	c04a                	sw	s2,0(sp)
80042994:	892a                	mv	s2,a0
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
80042996:	1e840513          	addi	a0,s0,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
8004299a:	02450513          	addi	a0,a0,36
{
8004299e:	c226                	sw	s1,4(sp)
800429a0:	c606                	sw	ra,12(sp)
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
800429a2:	37cd                	jal	80042984 <z_priq_rb_best>
	return th ? th : _current_cpu->idle_thread;
800429a4:	1e840413          	addi	s0,s0,488
800429a8:	84aa                	mv	s1,a0
800429aa:	e111                	bnez	a0,800429ae <update_cache+0x24>
800429ac:	4444                	lw	s1,12(s0)
	if (preempt_ok != 0) {
800429ae:	06091263          	bnez	s2,80042a12 <update_cache+0x88>
	__ASSERT(_current != NULL, "");
800429b2:	441c                	lw	a5,8(s0)
800429b4:	ef8d                	bnez	a5,800429ee <update_cache+0x64>
800429b6:	80045937          	lui	s2,0x80045
800429ba:	800455b7          	lui	a1,0x80045
800429be:	80045537          	lui	a0,0x80045
800429c2:	bc058593          	addi	a1,a1,-1088 # 80044bc0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044bc1>
800429c6:	07f00693          	li	a3,127
800429ca:	b8490613          	addi	a2,s2,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
800429ce:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800429d2:	d45fe0ef          	jal	ra,80041716 <printk>
800429d6:	80045537          	lui	a0,0x80045
800429da:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
800429de:	d39fe0ef          	jal	ra,80041716 <printk>
800429e2:	07f00593          	li	a1,127
800429e6:	b8490513          	addi	a0,s2,-1148
800429ea:	d4bfe0ef          	jal	ra,80041734 <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
800429ee:	441c                	lw	a5,8(s0)
800429f0:	00d7c703          	lbu	a4,13(a5)
800429f4:	8b7d                	andi	a4,a4,31
800429f6:	ef11                	bnez	a4,80042a12 <update_cache+0x88>
	if (is_preempt(_current) || is_metairq(th)) {
800429f8:	00e7d683          	lhu	a3,14(a5)
800429fc:	07f00713          	li	a4,127
80042a00:	00d77963          	bgeu	a4,a3,80042a12 <update_cache+0x88>
		_kernel.ready_q.cache = _current;
80042a04:	d01c                	sw	a5,32(s0)
}
80042a06:	40b2                	lw	ra,12(sp)
80042a08:	4422                	lw	s0,8(sp)
80042a0a:	4492                	lw	s1,4(sp)
80042a0c:	4902                	lw	s2,0(sp)
80042a0e:	0141                	addi	sp,sp,16
80042a10:	8082                	ret
		if (th != _current) {
80042a12:	441c                	lw	a5,8(s0)
80042a14:	00978463          	beq	a5,s1,80042a1c <update_cache+0x92>
			reset_time_slice();
80042a18:	82dff0ef          	jal	ra,80042244 <reset_time_slice>
		_kernel.ready_q.cache = th;
80042a1c:	d004                	sw	s1,32(s0)
}
80042a1e:	b7e5                	j	80042a06 <update_cache+0x7c>

80042a20 <k_sched_unlock>:
{
80042a20:	1101                	addi	sp,sp,-32
80042a22:	c84a                	sw	s2,16(sp)
	__ASSERT(_current->base.sched_locked != 0, "");
80042a24:	80045937          	lui	s2,0x80045
80042a28:	1e890793          	addi	a5,s2,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
80042a2c:	479c                	lw	a5,8(a5)
{
80042a2e:	ce06                	sw	ra,28(sp)
80042a30:	cc22                	sw	s0,24(sp)
	__ASSERT(_current->base.sched_locked != 0, "");
80042a32:	00f7c783          	lbu	a5,15(a5)
{
80042a36:	ca26                	sw	s1,20(sp)
80042a38:	c64e                	sw	s3,12(sp)
80042a3a:	1e890913          	addi	s2,s2,488
	__ASSERT(_current->base.sched_locked != 0, "");
80042a3e:	ef8d                	bnez	a5,80042a78 <k_sched_unlock+0x58>
80042a40:	80045437          	lui	s0,0x80045
80042a44:	800455b7          	lui	a1,0x80045
80042a48:	80045537          	lui	a0,0x80045
80042a4c:	b5c58593          	addi	a1,a1,-1188 # 80044b5c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b5d>
80042a50:	22100693          	li	a3,545
80042a54:	b8440613          	addi	a2,s0,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
80042a58:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042a5c:	cbbfe0ef          	jal	ra,80041716 <printk>
80042a60:	80045537          	lui	a0,0x80045
80042a64:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
80042a68:	caffe0ef          	jal	ra,80041716 <printk>
80042a6c:	22100593          	li	a1,545
80042a70:	b8440513          	addi	a0,s0,-1148
80042a74:	cc1fe0ef          	jal	ra,80041734 <assert_post_action>
	__ASSERT(!z_is_in_isr(), "");
80042a78:	00092783          	lw	a5,0(s2)
80042a7c:	cf8d                	beqz	a5,80042ab6 <k_sched_unlock+0x96>
80042a7e:	80045437          	lui	s0,0x80045
80042a82:	800455b7          	lui	a1,0x80045
80042a86:	80045537          	lui	a0,0x80045
80042a8a:	b1858593          	addi	a1,a1,-1256 # 80044b18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b19>
80042a8e:	22200693          	li	a3,546
80042a92:	b8440613          	addi	a2,s0,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
80042a96:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042a9a:	c7dfe0ef          	jal	ra,80041716 <printk>
80042a9e:	80045537          	lui	a0,0x80045
80042aa2:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
80042aa6:	c71fe0ef          	jal	ra,80041716 <printk>
80042aaa:	22200593          	li	a1,546
80042aae:	b8440513          	addi	a0,s0,-1148
80042ab2:	c83fe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrc %0, mstatus, %1"
80042ab6:	4421                	li	s0,8
80042ab8:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80042abc:	800454b7          	lui	s1,0x80045
80042ac0:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
80042ac4:	8821                	andi	s0,s0,8
80042ac6:	2cd000ef          	jal	ra,80043592 <z_spin_lock_valid>
80042aca:	ed0d                	bnez	a0,80042b04 <k_sched_unlock+0xe4>
80042acc:	800459b7          	lui	s3,0x80045
80042ad0:	800455b7          	lui	a1,0x80045
80042ad4:	80045537          	lui	a0,0x80045
80042ad8:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80042adc:	04e00693          	li	a3,78
80042ae0:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042ae4:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042ae8:	c2ffe0ef          	jal	ra,80041716 <printk>
80042aec:	80045537          	lui	a0,0x80045
80042af0:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80042af4:	c23fe0ef          	jal	ra,80041716 <printk>
80042af8:	04e00593          	li	a1,78
80042afc:	99098513          	addi	a0,s3,-1648
80042b00:	c35fe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80042b04:	dd448513          	addi	a0,s1,-556
80042b08:	2c7000ef          	jal	ra,800435ce <z_spin_lock_set_owner>
		++_current->base.sched_locked;
80042b0c:	00892703          	lw	a4,8(s2)
		update_cache(1);
80042b10:	4505                	li	a0,1
		++_current->base.sched_locked;
80042b12:	00f74783          	lbu	a5,15(a4)
80042b16:	0785                	addi	a5,a5,1
80042b18:	00f707a3          	sb	a5,15(a4)
		update_cache(1);
80042b1c:	35bd                	jal	8004298a <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042b1e:	dd448513          	addi	a0,s1,-556
80042b22:	28b000ef          	jal	ra,800435ac <z_spin_unlock_valid>
80042b26:	ed0d                	bnez	a0,80042b60 <k_sched_unlock+0x140>
80042b28:	800454b7          	lui	s1,0x80045
80042b2c:	800455b7          	lui	a1,0x80045
80042b30:	80045537          	lui	a0,0x80045
80042b34:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042b38:	06100693          	li	a3,97
80042b3c:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042b40:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042b44:	bd3fe0ef          	jal	ra,80041716 <printk>
80042b48:	80045537          	lui	a0,0x80045
80042b4c:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80042b50:	bc7fe0ef          	jal	ra,80041716 <printk>
80042b54:	06100593          	li	a1,97
80042b58:	99048513          	addi	a0,s1,-1648
80042b5c:	bd9fe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042b60:	30042473          	csrrs	s0,mstatus,s0
}
80042b64:	4462                	lw	s0,24(sp)
80042b66:	40f2                	lw	ra,28(sp)
80042b68:	44d2                	lw	s1,20(sp)
80042b6a:	4942                	lw	s2,16(sp)
80042b6c:	49b2                	lw	s3,12(sp)
80042b6e:	6105                	addi	sp,sp,32
	z_reschedule_unlocked();
80042b70:	9b7ff06f          	j	80042526 <z_reschedule_unlocked>

80042b74 <z_add_thread_to_ready_q>:
{
80042b74:	1101                	addi	sp,sp,-32
80042b76:	cc22                	sw	s0,24(sp)
80042b78:	c84a                	sw	s2,16(sp)
80042b7a:	ce06                	sw	ra,28(sp)
80042b7c:	ca26                	sw	s1,20(sp)
80042b7e:	c64e                	sw	s3,12(sp)
80042b80:	892a                	mv	s2,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80042b82:	4421                	li	s0,8
80042b84:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80042b88:	800454b7          	lui	s1,0x80045
80042b8c:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
80042b90:	8821                	andi	s0,s0,8
80042b92:	201000ef          	jal	ra,80043592 <z_spin_lock_valid>
80042b96:	ed0d                	bnez	a0,80042bd0 <z_add_thread_to_ready_q+0x5c>
80042b98:	800459b7          	lui	s3,0x80045
80042b9c:	800455b7          	lui	a1,0x80045
80042ba0:	80045537          	lui	a0,0x80045
80042ba4:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80042ba8:	04e00693          	li	a3,78
80042bac:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042bb0:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042bb4:	b63fe0ef          	jal	ra,80041716 <printk>
80042bb8:	80045537          	lui	a0,0x80045
80042bbc:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80042bc0:	b57fe0ef          	jal	ra,80041716 <printk>
80042bc4:	04e00593          	li	a1,78
80042bc8:	99098513          	addi	a0,s3,-1648
80042bcc:	b69fe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80042bd0:	dd448513          	addi	a0,s1,-556
80042bd4:	1fb000ef          	jal	ra,800435ce <z_spin_lock_set_owner>
		_priq_run_add(&_kernel.ready_q.runq, thread);
80042bd8:	80045537          	lui	a0,0x80045
80042bdc:	85ca                	mv	a1,s2
80042bde:	20c50513          	addi	a0,a0,524 # 8004520c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004520d>
80042be2:	c87ff0ef          	jal	ra,80042868 <z_priq_rb_add>
	thread->base.thread_state |= states;
80042be6:	00d94783          	lbu	a5,13(s2)
		update_cache(0);
80042bea:	4501                	li	a0,0
80042bec:	0407e793          	ori	a5,a5,64
80042bf0:	00f906a3          	sb	a5,13(s2)
80042bf4:	3b59                	jal	8004298a <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042bf6:	dd448513          	addi	a0,s1,-556
80042bfa:	1b3000ef          	jal	ra,800435ac <z_spin_unlock_valid>
80042bfe:	ed0d                	bnez	a0,80042c38 <z_add_thread_to_ready_q+0xc4>
80042c00:	800454b7          	lui	s1,0x80045
80042c04:	800455b7          	lui	a1,0x80045
80042c08:	80045537          	lui	a0,0x80045
80042c0c:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042c10:	06100693          	li	a3,97
80042c14:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042c18:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042c1c:	afbfe0ef          	jal	ra,80041716 <printk>
80042c20:	80045537          	lui	a0,0x80045
80042c24:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80042c28:	aeffe0ef          	jal	ra,80041716 <printk>
80042c2c:	06100593          	li	a1,97
80042c30:	99048513          	addi	a0,s1,-1648
80042c34:	b01fe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042c38:	30042473          	csrrs	s0,mstatus,s0
}
80042c3c:	40f2                	lw	ra,28(sp)
80042c3e:	4462                	lw	s0,24(sp)
80042c40:	44d2                	lw	s1,20(sp)
80042c42:	4942                	lw	s2,16(sp)
80042c44:	49b2                	lw	s3,12(sp)
80042c46:	6105                	addi	sp,sp,32
80042c48:	8082                	ret

80042c4a <z_thread_timeout>:
	if (th->base.pended_on != NULL) {
80042c4a:	ff052783          	lw	a5,-16(a0)
{
80042c4e:	1101                	addi	sp,sp,-32
80042c50:	cc22                	sw	s0,24(sp)
80042c52:	c64e                	sw	s3,12(sp)
80042c54:	ce06                	sw	ra,28(sp)
80042c56:	ca26                	sw	s1,20(sp)
80042c58:	c84a                	sw	s2,16(sp)
80042c5a:	c452                	sw	s4,8(sp)
80042c5c:	842a                	mv	s0,a0
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
80042c5e:	fe850993          	addi	s3,a0,-24
	if (th->base.pended_on != NULL) {
80042c62:	cfcd                	beqz	a5,80042d1c <z_thread_timeout+0xd2>
	__asm__ volatile ("csrrc %0, mstatus, %1"
80042c64:	44a1                	li	s1,8
80042c66:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80042c6a:	80045937          	lui	s2,0x80045
80042c6e:	dd490513          	addi	a0,s2,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
80042c72:	88a1                	andi	s1,s1,8
80042c74:	11f000ef          	jal	ra,80043592 <z_spin_lock_valid>
80042c78:	ed0d                	bnez	a0,80042cb2 <z_thread_timeout+0x68>
80042c7a:	80045a37          	lui	s4,0x80045
80042c7e:	800455b7          	lui	a1,0x80045
80042c82:	80045537          	lui	a0,0x80045
80042c86:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80042c8a:	04e00693          	li	a3,78
80042c8e:	990a0613          	addi	a2,s4,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042c92:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042c96:	a81fe0ef          	jal	ra,80041716 <printk>
80042c9a:	80045537          	lui	a0,0x80045
80042c9e:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80042ca2:	a75fe0ef          	jal	ra,80041716 <printk>
80042ca6:	04e00593          	li	a1,78
80042caa:	990a0513          	addi	a0,s4,-1648
80042cae:	a87fe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80042cb2:	dd490513          	addi	a0,s2,-556
80042cb6:	119000ef          	jal	ra,800435ce <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
80042cba:	ff040513          	addi	a0,s0,-16
80042cbe:	dacff0ef          	jal	ra,8004226a <pended_on.isra.15>
80042cc2:	85ce                	mv	a1,s3
80042cc4:	9bdff0ef          	jal	ra,80042680 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
80042cc8:	ff544783          	lbu	a5,-11(s0)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042ccc:	dd490513          	addi	a0,s2,-556
80042cd0:	9bf5                	andi	a5,a5,-3
80042cd2:	fef40aa3          	sb	a5,-11(s0)
80042cd6:	0d7000ef          	jal	ra,800435ac <z_spin_unlock_valid>
80042cda:	ed0d                	bnez	a0,80042d14 <z_thread_timeout+0xca>
80042cdc:	80045937          	lui	s2,0x80045
80042ce0:	800455b7          	lui	a1,0x80045
80042ce4:	80045537          	lui	a0,0x80045
80042ce8:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042cec:	06100693          	li	a3,97
80042cf0:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042cf4:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042cf8:	a1ffe0ef          	jal	ra,80041716 <printk>
80042cfc:	80045537          	lui	a0,0x80045
80042d00:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80042d04:	a13fe0ef          	jal	ra,80041716 <printk>
80042d08:	06100593          	li	a1,97
80042d0c:	99090513          	addi	a0,s2,-1648
80042d10:	a25fe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042d14:	3004a4f3          	csrrs	s1,mstatus,s1
	thread->base.pended_on = NULL;
80042d18:	fe042823          	sw	zero,-16(s0)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
80042d1c:	ff544783          	lbu	a5,-11(s0)
	if (z_is_thread_ready(thread)) {
80042d20:	854e                	mv	a0,s3
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
80042d22:	9bad                	andi	a5,a5,-21
80042d24:	fef40aa3          	sb	a5,-11(s0)
	if (z_is_thread_ready(thread)) {
80042d28:	ce8ff0ef          	jal	ra,80042210 <z_is_thread_ready>
80042d2c:	c911                	beqz	a0,80042d40 <z_thread_timeout+0xf6>
}
80042d2e:	4462                	lw	s0,24(sp)
80042d30:	40f2                	lw	ra,28(sp)
80042d32:	44d2                	lw	s1,20(sp)
80042d34:	4942                	lw	s2,16(sp)
80042d36:	4a22                	lw	s4,8(sp)
		z_add_thread_to_ready_q(thread);
80042d38:	854e                	mv	a0,s3
80042d3a:	49b2                	lw	s3,12(sp)
80042d3c:	6105                	addi	sp,sp,32
80042d3e:	bd1d                	j	80042b74 <z_add_thread_to_ready_q>
80042d40:	40f2                	lw	ra,28(sp)
80042d42:	4462                	lw	s0,24(sp)
80042d44:	44d2                	lw	s1,20(sp)
80042d46:	4942                	lw	s2,16(sp)
80042d48:	49b2                	lw	s3,12(sp)
80042d4a:	4a22                	lw	s4,8(sp)
80042d4c:	6105                	addi	sp,sp,32
80042d4e:	8082                	ret

80042d50 <z_move_thread_to_end_of_prio_q>:
{
80042d50:	1101                	addi	sp,sp,-32
80042d52:	cc22                	sw	s0,24(sp)
80042d54:	c64e                	sw	s3,12(sp)
80042d56:	ce06                	sw	ra,28(sp)
80042d58:	ca26                	sw	s1,20(sp)
80042d5a:	c84a                	sw	s2,16(sp)
80042d5c:	c452                	sw	s4,8(sp)
80042d5e:	89aa                	mv	s3,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80042d60:	4421                	li	s0,8
80042d62:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80042d66:	800454b7          	lui	s1,0x80045
80042d6a:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
80042d6e:	8821                	andi	s0,s0,8
80042d70:	023000ef          	jal	ra,80043592 <z_spin_lock_valid>
80042d74:	ed0d                	bnez	a0,80042dae <z_move_thread_to_end_of_prio_q+0x5e>
80042d76:	80045937          	lui	s2,0x80045
80042d7a:	800455b7          	lui	a1,0x80045
80042d7e:	80045537          	lui	a0,0x80045
80042d82:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80042d86:	04e00693          	li	a3,78
80042d8a:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042d8e:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042d92:	985fe0ef          	jal	ra,80041716 <printk>
80042d96:	80045537          	lui	a0,0x80045
80042d9a:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80042d9e:	979fe0ef          	jal	ra,80041716 <printk>
80042da2:	04e00593          	li	a1,78
80042da6:	99090513          	addi	a0,s2,-1648
80042daa:	98bfe0ef          	jal	ra,80041734 <assert_post_action>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
80042dae:	80045937          	lui	s2,0x80045
	z_spin_lock_set_owner(l);
80042db2:	dd448513          	addi	a0,s1,-556
80042db6:	1e890913          	addi	s2,s2,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
80042dba:	015000ef          	jal	ra,800435ce <z_spin_lock_set_owner>
80042dbe:	02490a13          	addi	s4,s2,36
80042dc2:	85ce                	mv	a1,s3
80042dc4:	8552                	mv	a0,s4
80042dc6:	b5dff0ef          	jal	ra,80042922 <z_priq_rb_remove>
		_priq_run_add(&_kernel.ready_q.runq, thread);
80042dca:	85ce                	mv	a1,s3
80042dcc:	8552                	mv	a0,s4
80042dce:	a9bff0ef          	jal	ra,80042868 <z_priq_rb_add>
	thread->base.thread_state |= states;
80042dd2:	00d9c783          	lbu	a5,13(s3)
		update_cache(thread == _current);
80042dd6:	00892503          	lw	a0,8(s2)
80042dda:	0407e793          	ori	a5,a5,64
80042dde:	41350533          	sub	a0,a0,s3
80042de2:	00153513          	seqz	a0,a0
80042de6:	00f986a3          	sb	a5,13(s3)
80042dea:	ba1ff0ef          	jal	ra,8004298a <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042dee:	dd448513          	addi	a0,s1,-556
80042df2:	7ba000ef          	jal	ra,800435ac <z_spin_unlock_valid>
80042df6:	ed0d                	bnez	a0,80042e30 <z_move_thread_to_end_of_prio_q+0xe0>
80042df8:	800454b7          	lui	s1,0x80045
80042dfc:	800455b7          	lui	a1,0x80045
80042e00:	80045537          	lui	a0,0x80045
80042e04:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042e08:	06100693          	li	a3,97
80042e0c:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042e10:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042e14:	903fe0ef          	jal	ra,80041716 <printk>
80042e18:	80045537          	lui	a0,0x80045
80042e1c:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80042e20:	8f7fe0ef          	jal	ra,80041716 <printk>
80042e24:	06100593          	li	a1,97
80042e28:	99048513          	addi	a0,s1,-1648
80042e2c:	909fe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042e30:	30042473          	csrrs	s0,mstatus,s0
}
80042e34:	40f2                	lw	ra,28(sp)
80042e36:	4462                	lw	s0,24(sp)
80042e38:	44d2                	lw	s1,20(sp)
80042e3a:	4942                	lw	s2,16(sp)
80042e3c:	49b2                	lw	s3,12(sp)
80042e3e:	4a22                	lw	s4,8(sp)
80042e40:	6105                	addi	sp,sp,32
80042e42:	8082                	ret

80042e44 <z_time_slice>:
	if (slice_time && sliceable(_current)) {
80042e44:	800457b7          	lui	a5,0x80045
80042e48:	ddc7a783          	lw	a5,-548(a5) # 80044ddc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044ddd>
80042e4c:	cba9                	beqz	a5,80042e9e <z_time_slice+0x5a>
80042e4e:	800457b7          	lui	a5,0x80045
80042e52:	1e878793          	addi	a5,a5,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
80042e56:	4798                	lw	a4,8(a5)
		&& !z_is_thread_timeout_active(t);
80042e58:	07f00693          	li	a3,127
80042e5c:	00e75603          	lhu	a2,14(a4)
80042e60:	02c6ef63          	bltu	a3,a2,80042e9e <z_time_slice+0x5a>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
80042e64:	800456b7          	lui	a3,0x80045
80042e68:	00e70603          	lb	a2,14(a4)
80042e6c:	dd86a683          	lw	a3,-552(a3) # 80044dd8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd9>
80042e70:	02d64763          	blt	a2,a3,80042e9e <z_time_slice+0x5a>
	return thread == _idle_thread;
80042e74:	800456b7          	lui	a3,0x80045
		&& !is_idle(t)
80042e78:	d646a683          	lw	a3,-668(a3) # 80044d64 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d65>
80042e7c:	02d70163          	beq	a4,a3,80042e9e <z_time_slice+0x5a>
		&& !z_is_thread_timeout_active(t);
80042e80:	4f14                	lw	a3,24(a4)
80042e82:	ee91                	bnez	a3,80042e9e <z_time_slice+0x5a>
		if (ticks >= _current_cpu->slice_ticks) {
80042e84:	4b94                	lw	a3,16(a5)
80042e86:	00d54a63          	blt	a0,a3,80042e9a <z_time_slice+0x56>
{
80042e8a:	1141                	addi	sp,sp,-16
			z_move_thread_to_end_of_prio_q(_current);
80042e8c:	853a                	mv	a0,a4
{
80042e8e:	c606                	sw	ra,12(sp)
			z_move_thread_to_end_of_prio_q(_current);
80042e90:	35c1                	jal	80042d50 <z_move_thread_to_end_of_prio_q>
}
80042e92:	40b2                	lw	ra,12(sp)
80042e94:	0141                	addi	sp,sp,16
			reset_time_slice();
80042e96:	baeff06f          	j	80042244 <reset_time_slice>
			_current_cpu->slice_ticks -= ticks;
80042e9a:	8e89                	sub	a3,a3,a0
80042e9c:	cb94                	sw	a3,16(a5)
80042e9e:	8082                	ret

80042ea0 <z_remove_thread_from_ready_q>:
{
80042ea0:	1101                	addi	sp,sp,-32
80042ea2:	cc22                	sw	s0,24(sp)
80042ea4:	c64e                	sw	s3,12(sp)
80042ea6:	ce06                	sw	ra,28(sp)
80042ea8:	ca26                	sw	s1,20(sp)
80042eaa:	c84a                	sw	s2,16(sp)
80042eac:	89aa                	mv	s3,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80042eae:	4421                	li	s0,8
80042eb0:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80042eb4:	800454b7          	lui	s1,0x80045
80042eb8:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
80042ebc:	8821                	andi	s0,s0,8
80042ebe:	6d4000ef          	jal	ra,80043592 <z_spin_lock_valid>
80042ec2:	ed0d                	bnez	a0,80042efc <z_remove_thread_from_ready_q+0x5c>
80042ec4:	80045937          	lui	s2,0x80045
80042ec8:	800455b7          	lui	a1,0x80045
80042ecc:	80045537          	lui	a0,0x80045
80042ed0:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80042ed4:	04e00693          	li	a3,78
80042ed8:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042edc:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042ee0:	837fe0ef          	jal	ra,80041716 <printk>
80042ee4:	80045537          	lui	a0,0x80045
80042ee8:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80042eec:	82bfe0ef          	jal	ra,80041716 <printk>
80042ef0:	04e00593          	li	a1,78
80042ef4:	99090513          	addi	a0,s2,-1648
80042ef8:	83dfe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80042efc:	dd448513          	addi	a0,s1,-556
80042f00:	6ce000ef          	jal	ra,800435ce <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
80042f04:	00d9c783          	lbu	a5,13(s3)
80042f08:	80045937          	lui	s2,0x80045
80042f0c:	1e890913          	addi	s2,s2,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
80042f10:	0407f793          	andi	a5,a5,64
80042f14:	cf81                	beqz	a5,80042f2c <z_remove_thread_from_ready_q+0x8c>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
80042f16:	85ce                	mv	a1,s3
80042f18:	02490513          	addi	a0,s2,36
80042f1c:	a07ff0ef          	jal	ra,80042922 <z_priq_rb_remove>
	thread->base.thread_state &= ~states;
80042f20:	00d9c783          	lbu	a5,13(s3)
80042f24:	fbf7f793          	andi	a5,a5,-65
80042f28:	00f986a3          	sb	a5,13(s3)
		update_cache(thread == _current);
80042f2c:	00892503          	lw	a0,8(s2)
80042f30:	41350533          	sub	a0,a0,s3
80042f34:	00153513          	seqz	a0,a0
80042f38:	a53ff0ef          	jal	ra,8004298a <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80042f3c:	dd448513          	addi	a0,s1,-556
80042f40:	25b5                	jal	800435ac <z_spin_unlock_valid>
80042f42:	ed0d                	bnez	a0,80042f7c <z_remove_thread_from_ready_q+0xdc>
80042f44:	800454b7          	lui	s1,0x80045
80042f48:	800455b7          	lui	a1,0x80045
80042f4c:	80045537          	lui	a0,0x80045
80042f50:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80042f54:	06100693          	li	a3,97
80042f58:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80042f5c:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042f60:	fb6fe0ef          	jal	ra,80041716 <printk>
80042f64:	80045537          	lui	a0,0x80045
80042f68:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80042f6c:	faafe0ef          	jal	ra,80041716 <printk>
80042f70:	06100593          	li	a1,97
80042f74:	99048513          	addi	a0,s1,-1648
80042f78:	fbcfe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80042f7c:	30042473          	csrrs	s0,mstatus,s0
}
80042f80:	40f2                	lw	ra,28(sp)
80042f82:	4462                	lw	s0,24(sp)
80042f84:	44d2                	lw	s1,20(sp)
80042f86:	4942                	lw	s2,16(sp)
80042f88:	49b2                	lw	s3,12(sp)
80042f8a:	6105                	addi	sp,sp,32
80042f8c:	8082                	ret

80042f8e <pend>:
{
80042f8e:	1101                	addi	sp,sp,-32
80042f90:	cc22                	sw	s0,24(sp)
80042f92:	ca26                	sw	s1,20(sp)
80042f94:	842a                	mv	s0,a0
80042f96:	c84a                	sw	s2,16(sp)
80042f98:	ce06                	sw	ra,28(sp)
80042f9a:	c64e                	sw	s3,12(sp)
80042f9c:	84ae                	mv	s1,a1
80042f9e:	8932                	mv	s2,a2
	z_remove_thread_from_ready_q(thread);
80042fa0:	3701                	jal	80042ea0 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
80042fa2:	00d44783          	lbu	a5,13(s0)
80042fa6:	0027e793          	ori	a5,a5,2
80042faa:	00f406a3          	sb	a5,13(s0)
	if (wait_q != NULL) {
80042fae:	cca9                	beqz	s1,80043008 <pend+0x7a>
	return thread == _idle_thread;
80042fb0:	800457b7          	lui	a5,0x80045
	__ASSERT_NO_MSG(!is_idle(thread));
80042fb4:	d647a783          	lw	a5,-668(a5) # 80044d64 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d65>
		thread->base.pended_on = wait_q;
80042fb8:	c404                	sw	s1,8(s0)
	__ASSERT_NO_MSG(!is_idle(thread));
80042fba:	02f41863          	bne	s0,a5,80042fea <pend+0x5c>
80042fbe:	800459b7          	lui	s3,0x80045
80042fc2:	800455b7          	lui	a1,0x80045
80042fc6:	80045537          	lui	a0,0x80045
80042fca:	c1858593          	addi	a1,a1,-1000 # 80044c18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044c19>
80042fce:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80042fd2:	27600693          	li	a3,630
80042fd6:	b8498613          	addi	a2,s3,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
80042fda:	f3cfe0ef          	jal	ra,80041716 <printk>
80042fde:	27600593          	li	a1,630
80042fe2:	b8498513          	addi	a0,s3,-1148
80042fe6:	f4efe0ef          	jal	ra,80041734 <assert_post_action>
	return list->head == list;
80042fea:	409c                	lw	a5,0(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80042fec:	04f48963          	beq	s1,a5,8004303e <pend+0xb0>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80042ff0:	c7b9                	beqz	a5,8004303e <pend+0xb0>
	if (t1->base.prio < t2->base.prio) {
80042ff2:	00e40703          	lb	a4,14(s0)
80042ff6:	00e78683          	lb	a3,14(a5)
80042ffa:	02d75d63          	bge	a4,a3,80043034 <pend+0xa6>
	node->prev = successor->prev;
80042ffe:	43d8                	lw	a4,4(a5)
	node->next = successor;
80043000:	c01c                	sw	a5,0(s0)
	node->prev = successor->prev;
80043002:	c058                	sw	a4,4(s0)
	successor->prev->next = node;
80043004:	c300                	sw	s0,0(a4)
	successor->prev = node;
80043006:	c3c0                	sw	s0,4(a5)
	if (timeout != K_FOREVER) {
80043008:	57fd                	li	a5,-1
8004300a:	04f90163          	beq	s2,a5,8004304c <pend+0xbe>
8004300e:	0925                	addi	s2,s2,9
80043010:	4629                	li	a2,10
80043012:	02c94633          	div	a2,s2,a2
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
80043016:	01840513          	addi	a0,s0,24
}
8004301a:	4462                	lw	s0,24(sp)
8004301c:	40f2                	lw	ra,28(sp)
8004301e:	44d2                	lw	s1,20(sp)
80043020:	4942                	lw	s2,16(sp)
80043022:	49b2                	lw	s3,12(sp)
80043024:	800435b7          	lui	a1,0x80043
80043028:	c4a58593          	addi	a1,a1,-950 # 80042c4a <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042c4b>
8004302c:	6105                	addi	sp,sp,32
8004302e:	0605                	addi	a2,a2,1
80043030:	13d0006f          	j	8004396c <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
80043034:	40d4                	lw	a3,4(s1)
80043036:	00d78463          	beq	a5,a3,8004303e <pend+0xb0>
8004303a:	439c                	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
8004303c:	ffcd                	bnez	a5,80042ff6 <pend+0x68>
	node->prev = list->tail;
8004303e:	40dc                	lw	a5,4(s1)
	node->next = list;
80043040:	c004                	sw	s1,0(s0)
	node->prev = list->tail;
80043042:	c05c                	sw	a5,4(s0)
	list->tail->next = node;
80043044:	40dc                	lw	a5,4(s1)
80043046:	c380                	sw	s0,0(a5)
	list->tail = node;
80043048:	c0c0                	sw	s0,4(s1)
8004304a:	bf7d                	j	80043008 <pend+0x7a>
}
8004304c:	40f2                	lw	ra,28(sp)
8004304e:	4462                	lw	s0,24(sp)
80043050:	44d2                	lw	s1,20(sp)
80043052:	4942                	lw	s2,16(sp)
80043054:	49b2                	lw	s3,12(sp)
80043056:	6105                	addi	sp,sp,32
80043058:	8082                	ret

8004305a <z_pend_curr>:
{
8004305a:	1141                	addi	sp,sp,-16
	pend(_current, wait_q, timeout);
8004305c:	800457b7          	lui	a5,0x80045
{
80043060:	c422                	sw	s0,8(sp)
80043062:	842a                	mv	s0,a0
	pend(_current, wait_q, timeout);
80043064:	1f07a503          	lw	a0,496(a5) # 800451f0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451f1>
{
80043068:	c226                	sw	s1,4(sp)
8004306a:	84ae                	mv	s1,a1
8004306c:	85b2                	mv	a1,a2
	pend(_current, wait_q, timeout);
8004306e:	8636                	mv	a2,a3
{
80043070:	c606                	sw	ra,12(sp)
	pend(_current, wait_q, timeout);
80043072:	3f31                	jal	80042f8e <pend>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043074:	8522                	mv	a0,s0
80043076:	2b1d                	jal	800435ac <z_spin_unlock_valid>
80043078:	ed0d                	bnez	a0,800430b2 <z_pend_curr+0x58>
8004307a:	80045437          	lui	s0,0x80045
8004307e:	800455b7          	lui	a1,0x80045
80043082:	80045537          	lui	a0,0x80045
80043086:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
8004308a:	07800693          	li	a3,120
8004308e:	99040613          	addi	a2,s0,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043092:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043096:	e80fe0ef          	jal	ra,80041716 <printk>
8004309a:	80045537          	lui	a0,0x80045
8004309e:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
800430a2:	e74fe0ef          	jal	ra,80041716 <printk>
800430a6:	07800593          	li	a1,120
800430aa:	99040513          	addi	a0,s0,-1648
800430ae:	e86fe0ef          	jal	ra,80041734 <assert_post_action>
}
800430b2:	4422                	lw	s0,8(sp)
800430b4:	40b2                	lw	ra,12(sp)
800430b6:	8526                	mv	a0,s1
800430b8:	4492                	lw	s1,4(sp)
800430ba:	0141                	addi	sp,sp,16
800430bc:	904fd06f          	j	800401c0 <__swap>

800430c0 <z_thread_priority_set>:
{
800430c0:	1101                	addi	sp,sp,-32
800430c2:	cc22                	sw	s0,24(sp)
800430c4:	c84a                	sw	s2,16(sp)
800430c6:	c64e                	sw	s3,12(sp)
800430c8:	ce06                	sw	ra,28(sp)
800430ca:	ca26                	sw	s1,20(sp)
800430cc:	c452                	sw	s4,8(sp)
800430ce:	c256                	sw	s5,4(sp)
800430d0:	892a                	mv	s2,a0
800430d2:	89ae                	mv	s3,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
800430d4:	4421                	li	s0,8
800430d6:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
800430da:	800454b7          	lui	s1,0x80045
800430de:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
800430e2:	8821                	andi	s0,s0,8
800430e4:	217d                	jal	80043592 <z_spin_lock_valid>
800430e6:	ed0d                	bnez	a0,80043120 <z_thread_priority_set+0x60>
800430e8:	80045a37          	lui	s4,0x80045
800430ec:	800455b7          	lui	a1,0x80045
800430f0:	80045537          	lui	a0,0x80045
800430f4:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
800430f8:	04e00693          	li	a3,78
800430fc:	990a0613          	addi	a2,s4,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043100:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043104:	e12fe0ef          	jal	ra,80041716 <printk>
80043108:	80045537          	lui	a0,0x80045
8004310c:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80043110:	e06fe0ef          	jal	ra,80041716 <printk>
80043114:	04e00593          	li	a1,78
80043118:	990a0513          	addi	a0,s4,-1648
8004311c:	e18fe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80043120:	dd448513          	addi	a0,s1,-556
80043124:	216d                	jal	800435ce <z_spin_lock_set_owner>
		need_sched = z_is_thread_ready(thread);
80043126:	854a                	mv	a0,s2
80043128:	8e8ff0ef          	jal	ra,80042210 <z_is_thread_ready>
8004312c:	09e2                	slli	s3,s3,0x18
8004312e:	8aaa                	mv	s5,a0
		if (need_sched) {
80043130:	4189d993          	srai	s3,s3,0x18
80043134:	c559                	beqz	a0,800431c2 <z_thread_priority_set+0x102>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
80043136:	80045a37          	lui	s4,0x80045
8004313a:	20ca0a13          	addi	s4,s4,524 # 8004520c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004520d>
8004313e:	85ca                	mv	a1,s2
80043140:	8552                	mv	a0,s4
80043142:	fe0ff0ef          	jal	ra,80042922 <z_priq_rb_remove>
			_priq_run_add(&_kernel.ready_q.runq, thread);
80043146:	8552                	mv	a0,s4
			thread->base.prio = prio;
80043148:	01390723          	sb	s3,14(s2)
			_priq_run_add(&_kernel.ready_q.runq, thread);
8004314c:	85ca                	mv	a1,s2
8004314e:	f1aff0ef          	jal	ra,80042868 <z_priq_rb_add>
			update_cache(1);
80043152:	4505                	li	a0,1
80043154:	837ff0ef          	jal	ra,8004298a <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043158:	dd448513          	addi	a0,s1,-556
8004315c:	2981                	jal	800435ac <z_spin_unlock_valid>
8004315e:	ed0d                	bnez	a0,80043198 <z_thread_priority_set+0xd8>
80043160:	800454b7          	lui	s1,0x80045
80043164:	800455b7          	lui	a1,0x80045
80043168:	80045537          	lui	a0,0x80045
8004316c:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80043170:	06100693          	li	a3,97
80043174:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043178:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004317c:	d9afe0ef          	jal	ra,80041716 <printk>
80043180:	80045537          	lui	a0,0x80045
80043184:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80043188:	d8efe0ef          	jal	ra,80041716 <printk>
8004318c:	06100593          	li	a1,97
80043190:	99048513          	addi	a0,s1,-1648
80043194:	da0fe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80043198:	30042473          	csrrs	s0,mstatus,s0
	if (need_sched && _current->base.sched_locked == 0) {
8004319c:	020a8663          	beqz	s5,800431c8 <z_thread_priority_set+0x108>
800431a0:	800457b7          	lui	a5,0x80045
800431a4:	1f07a783          	lw	a5,496(a5) # 800451f0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451f1>
800431a8:	00f7c783          	lbu	a5,15(a5)
800431ac:	ef91                	bnez	a5,800431c8 <z_thread_priority_set+0x108>
}
800431ae:	4462                	lw	s0,24(sp)
800431b0:	40f2                	lw	ra,28(sp)
800431b2:	44d2                	lw	s1,20(sp)
800431b4:	4942                	lw	s2,16(sp)
800431b6:	49b2                	lw	s3,12(sp)
800431b8:	4a22                	lw	s4,8(sp)
800431ba:	4a92                	lw	s5,4(sp)
800431bc:	6105                	addi	sp,sp,32
		z_reschedule_unlocked();
800431be:	b68ff06f          	j	80042526 <z_reschedule_unlocked>
			thread->base.prio = prio;
800431c2:	01390723          	sb	s3,14(s2)
800431c6:	bf49                	j	80043158 <z_thread_priority_set+0x98>
}
800431c8:	40f2                	lw	ra,28(sp)
800431ca:	4462                	lw	s0,24(sp)
800431cc:	44d2                	lw	s1,20(sp)
800431ce:	4942                	lw	s2,16(sp)
800431d0:	49b2                	lw	s3,12(sp)
800431d2:	4a22                	lw	s4,8(sp)
800431d4:	4a92                	lw	s5,4(sp)
800431d6:	6105                	addi	sp,sp,32
800431d8:	8082                	ret

800431da <z_sched_init>:
#ifdef CONFIG_SCHED_DUMB
	sys_dlist_init(&_kernel.ready_q.runq);
#endif

#ifdef CONFIG_SCHED_SCALABLE
	_kernel.ready_q.runq = (struct _priq_rb) {
800431da:	800457b7          	lui	a5,0x80045
800431de:	80042737          	lui	a4,0x80042
800431e2:	1e878793          	addi	a5,a5,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
800431e6:	22470713          	addi	a4,a4,548 # 80042224 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042225>
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
800431ea:	4581                	li	a1,0
800431ec:	4501                	li	a0,0
	_kernel.ready_q.runq = (struct _priq_rb) {
800431ee:	0207a223          	sw	zero,36(a5)
800431f2:	0207a623          	sw	zero,44(a5)
800431f6:	0207a823          	sw	zero,48(a5)
800431fa:	d798                	sw	a4,40(a5)
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
800431fc:	8b4ff06f          	j	800422b0 <k_sched_time_slice_set>

80043200 <z_impl_k_thread_priority_get>:
}

int z_impl_k_thread_priority_get(k_tid_t thread)
{
	return thread->base.prio;
}
80043200:	00e50503          	lb	a0,14(a0)
80043204:	8082                	ret

80043206 <z_impl_k_yield>:
}
#endif
#endif

void z_impl_k_yield(void)
{
80043206:	1101                	addi	sp,sp,-32
80043208:	cc22                	sw	s0,24(sp)
	__ASSERT(!z_is_in_isr(), "");
8004320a:	80045437          	lui	s0,0x80045
8004320e:	1e842783          	lw	a5,488(s0) # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
{
80043212:	ce06                	sw	ra,28(sp)
80043214:	ca26                	sw	s1,20(sp)
80043216:	c84a                	sw	s2,16(sp)
80043218:	c64e                	sw	s3,12(sp)
8004321a:	1e840413          	addi	s0,s0,488
	__ASSERT(!z_is_in_isr(), "");
8004321e:	cf8d                	beqz	a5,80043258 <z_impl_k_yield+0x52>
80043220:	800454b7          	lui	s1,0x80045
80043224:	800455b7          	lui	a1,0x80045
80043228:	80045537          	lui	a0,0x80045
8004322c:	b1858593          	addi	a1,a1,-1256 # 80044b18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b19>
80043230:	37e00693          	li	a3,894
80043234:	b8448613          	addi	a2,s1,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
80043238:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004323c:	cdafe0ef          	jal	ra,80041716 <printk>
80043240:	80045537          	lui	a0,0x80045
80043244:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
80043248:	ccefe0ef          	jal	ra,80041716 <printk>
8004324c:	37e00593          	li	a1,894
80043250:	b8448513          	addi	a0,s1,-1148
80043254:	ce0fe0ef          	jal	ra,80041734 <assert_post_action>

	if (!is_idle(_current)) {
80043258:	800457b7          	lui	a5,0x80045
8004325c:	4418                	lw	a4,8(s0)
8004325e:	d647a783          	lw	a5,-668(a5) # 80044d64 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d65>
80043262:	0af70b63          	beq	a4,a5,80043318 <z_impl_k_yield+0x112>
	__asm__ volatile ("csrrc %0, mstatus, %1"
80043266:	47a1                	li	a5,8
80043268:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
8004326c:	800454b7          	lui	s1,0x80045
80043270:	dd448513          	addi	a0,s1,-556 # 80044dd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044dd5>
	key = (mstatus & SOC_MSTATUS_IEN);
80043274:	0087f993          	andi	s3,a5,8
80043278:	2e29                	jal	80043592 <z_spin_lock_valid>
8004327a:	ed0d                	bnez	a0,800432b4 <z_impl_k_yield+0xae>
8004327c:	80045937          	lui	s2,0x80045
80043280:	800455b7          	lui	a1,0x80045
80043284:	80045537          	lui	a0,0x80045
80043288:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
8004328c:	04e00693          	li	a3,78
80043290:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043294:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043298:	c7efe0ef          	jal	ra,80041716 <printk>
8004329c:	80045537          	lui	a0,0x80045
800432a0:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
800432a4:	c72fe0ef          	jal	ra,80041716 <printk>
800432a8:	04e00593          	li	a1,78
800432ac:	99090513          	addi	a0,s2,-1648
800432b0:	c84fe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
800432b4:	dd448513          	addi	a0,s1,-556
800432b8:	2e19                	jal	800435ce <z_spin_lock_set_owner>
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
800432ba:	440c                	lw	a1,8(s0)
800432bc:	02440913          	addi	s2,s0,36
800432c0:	854a                	mv	a0,s2
800432c2:	e60ff0ef          	jal	ra,80042922 <z_priq_rb_remove>
						 _current);
				_priq_run_add(&_kernel.ready_q.runq,
800432c6:	440c                	lw	a1,8(s0)
800432c8:	854a                	mv	a0,s2
800432ca:	d9eff0ef          	jal	ra,80042868 <z_priq_rb_add>
					      _current);
			}
			update_cache(1);
800432ce:	4505                	li	a0,1
800432d0:	ebaff0ef          	jal	ra,8004298a <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
800432d4:	dd448513          	addi	a0,s1,-556
800432d8:	2cd1                	jal	800435ac <z_spin_unlock_valid>
800432da:	ed0d                	bnez	a0,80043314 <z_impl_k_yield+0x10e>
800432dc:	80045437          	lui	s0,0x80045
800432e0:	800455b7          	lui	a1,0x80045
800432e4:	80045537          	lui	a0,0x80045
800432e8:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
800432ec:	06100693          	li	a3,97
800432f0:	99040613          	addi	a2,s0,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
800432f4:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800432f8:	c1efe0ef          	jal	ra,80041716 <printk>
800432fc:	80045537          	lui	a0,0x80045
80043300:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80043304:	c12fe0ef          	jal	ra,80041716 <printk>
80043308:	06100593          	li	a1,97
8004330c:	99040513          	addi	a0,s0,-1648
80043310:	c24fe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80043314:	3009a7f3          	csrrs	a5,mstatus,s3
	__asm__ volatile ("csrrc %0, mstatus, %1"
80043318:	4521                	li	a0,8
8004331a:	30053573          	csrrc	a0,mstatus,a0
		}
	}
	z_swap_unlocked();
}
8004331e:	4462                	lw	s0,24(sp)
80043320:	40f2                	lw	ra,28(sp)
80043322:	44d2                	lw	s1,20(sp)
80043324:	4942                	lw	s2,16(sp)
80043326:	49b2                	lw	s3,12(sp)
80043328:	8921                	andi	a0,a0,8
8004332a:	6105                	addi	sp,sp,32
8004332c:	e95fc06f          	j	800401c0 <__swap>

80043330 <z_impl_k_sleep>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER0_SIMPLE_VOID(k_yield);
#endif

s32_t z_impl_k_sleep(s32_t duration)
{
80043330:	7179                	addi	sp,sp,-48
80043332:	d226                	sw	s1,36(sp)
#ifdef CONFIG_MULTITHREADING
	u32_t expected_wakeup_time;
	s32_t ticks;

	__ASSERT(!z_is_in_isr(), "");
80043334:	800454b7          	lui	s1,0x80045
80043338:	1e84a783          	lw	a5,488(s1) # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
{
8004333c:	d422                	sw	s0,40(sp)
8004333e:	d606                	sw	ra,44(sp)
80043340:	d04a                	sw	s2,32(sp)
80043342:	ce4e                	sw	s3,28(sp)
80043344:	cc52                	sw	s4,24(sp)
80043346:	842a                	mv	s0,a0
80043348:	1e848493          	addi	s1,s1,488
	__ASSERT(!z_is_in_isr(), "");
8004334c:	cf8d                	beqz	a5,80043386 <z_impl_k_sleep+0x56>
8004334e:	80045937          	lui	s2,0x80045
80043352:	800455b7          	lui	a1,0x80045
80043356:	80045537          	lui	a0,0x80045
8004335a:	b1858593          	addi	a1,a1,-1256 # 80044b18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b19>
8004335e:	39900693          	li	a3,921
80043362:	b8490613          	addi	a2,s2,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
80043366:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004336a:	bacfe0ef          	jal	ra,80041716 <printk>
8004336e:	80045537          	lui	a0,0x80045
80043372:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
80043376:	ba0fe0ef          	jal	ra,80041716 <printk>
8004337a:	39900593          	li	a1,921
8004337e:	b8490513          	addi	a0,s2,-1148
80043382:	bb2fe0ef          	jal	ra,80041734 <assert_post_action>

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
80043386:	ec01                	bnez	s0,8004339e <z_impl_k_sleep+0x6e>
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
80043388:	e7fff0ef          	jal	ra,80043206 <z_impl_k_yield>
		return __ticks_to_ms(ticks);
	}
#endif

	return 0;
}
8004338c:	8522                	mv	a0,s0
8004338e:	50b2                	lw	ra,44(sp)
80043390:	5422                	lw	s0,40(sp)
80043392:	5492                	lw	s1,36(sp)
80043394:	5902                	lw	s2,32(sp)
80043396:	49f2                	lw	s3,28(sp)
80043398:	4a62                	lw	s4,24(sp)
8004339a:	6145                	addi	sp,sp,48
8004339c:	8082                	ret
8004339e:	47a9                	li	a5,10
800433a0:	0425                	addi	s0,s0,9
800433a2:	02f44433          	div	s0,s0,a5
	expected_wakeup_time = ticks + z_tick_get_32();
800433a6:	4ad000ef          	jal	ra,80044052 <z_tick_get_32>
800433aa:	49a1                	li	s3,8
	struct k_spinlock local_lock = {};
800433ac:	c602                	sw	zero,12(sp)
	ticks = _TICK_ALIGN + z_ms_to_ticks(duration);
800433ae:	0405                	addi	s0,s0,1
	expected_wakeup_time = ticks + z_tick_get_32();
800433b0:	00a40933          	add	s2,s0,a0
800433b4:	3009b9f3          	csrrc	s3,mstatus,s3
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
800433b8:	0068                	addi	a0,sp,12
	key = (mstatus & SOC_MSTATUS_IEN);
800433ba:	0089f993          	andi	s3,s3,8
800433be:	2ad1                	jal	80043592 <z_spin_lock_valid>
800433c0:	ed0d                	bnez	a0,800433fa <z_impl_k_sleep+0xca>
800433c2:	80045a37          	lui	s4,0x80045
800433c6:	800455b7          	lui	a1,0x80045
800433ca:	80045537          	lui	a0,0x80045
800433ce:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
800433d2:	04e00693          	li	a3,78
800433d6:	990a0613          	addi	a2,s4,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
800433da:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800433de:	b38fe0ef          	jal	ra,80041716 <printk>
800433e2:	80045537          	lui	a0,0x80045
800433e6:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
800433ea:	b2cfe0ef          	jal	ra,80041716 <printk>
800433ee:	04e00593          	li	a1,78
800433f2:	990a0513          	addi	a0,s4,-1648
800433f6:	b3efe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
800433fa:	0068                	addi	a0,sp,12
800433fc:	2ac9                	jal	800435ce <z_spin_lock_set_owner>
	z_remove_thread_from_ready_q(_current);
800433fe:	4488                	lw	a0,8(s1)
80043400:	aa1ff0ef          	jal	ra,80042ea0 <z_remove_thread_from_ready_q>
80043404:	4488                	lw	a0,8(s1)
80043406:	800435b7          	lui	a1,0x80043
8004340a:	8622                	mv	a2,s0
8004340c:	0561                	addi	a0,a0,24
8004340e:	c4a58593          	addi	a1,a1,-950 # 80042c4a <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042c4b>
80043412:	2ba9                	jal	8004396c <z_add_timeout>
	z_mark_thread_as_suspended(_current);
80043414:	4498                	lw	a4,8(s1)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043416:	0068                	addi	a0,sp,12
	thread->base.thread_state |= _THREAD_SUSPENDED;
80043418:	00d74783          	lbu	a5,13(a4)
8004341c:	0107e793          	ori	a5,a5,16
80043420:	00f706a3          	sb	a5,13(a4)
80043424:	2261                	jal	800435ac <z_spin_unlock_valid>
80043426:	ed0d                	bnez	a0,80043460 <z_impl_k_sleep+0x130>
80043428:	80045437          	lui	s0,0x80045
8004342c:	800455b7          	lui	a1,0x80045
80043430:	80045537          	lui	a0,0x80045
80043434:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80043438:	07800693          	li	a3,120
8004343c:	99040613          	addi	a2,s0,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043440:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043444:	ad2fe0ef          	jal	ra,80041716 <printk>
80043448:	80045537          	lui	a0,0x80045
8004344c:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80043450:	ac6fe0ef          	jal	ra,80041716 <printk>
80043454:	07800593          	li	a1,120
80043458:	99040513          	addi	a0,s0,-1648
8004345c:	ad8fe0ef          	jal	ra,80041734 <assert_post_action>
80043460:	854e                	mv	a0,s3
80043462:	d5ffc0ef          	jal	ra,800401c0 <__swap>
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
80043466:	449c                	lw	a5,8(s1)
80043468:	00d7c783          	lbu	a5,13(a5)
8004346c:	8bc1                	andi	a5,a5,16
8004346e:	cf8d                	beqz	a5,800434a8 <z_impl_k_sleep+0x178>
80043470:	80045437          	lui	s0,0x80045
80043474:	800455b7          	lui	a1,0x80045
80043478:	80045537          	lui	a0,0x80045
8004347c:	be058593          	addi	a1,a1,-1056 # 80044be0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044be1>
80043480:	3b600693          	li	a3,950
80043484:	b8440613          	addi	a2,s0,-1148 # 80044b84 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b85>
80043488:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004348c:	a8afe0ef          	jal	ra,80041716 <printk>
80043490:	80045537          	lui	a0,0x80045
80043494:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
80043498:	a7efe0ef          	jal	ra,80041716 <printk>
8004349c:	3b600593          	li	a1,950
800434a0:	b8440513          	addi	a0,s0,-1148
800434a4:	a90fe0ef          	jal	ra,80041734 <assert_post_action>
	ticks = expected_wakeup_time - z_tick_get_32();
800434a8:	3ab000ef          	jal	ra,80044052 <z_tick_get_32>
800434ac:	40a90533          	sub	a0,s2,a0
	return 0;
800434b0:	4401                	li	s0,0
	if (ticks > 0) {
800434b2:	eca05de3          	blez	a0,8004338c <z_impl_k_sleep+0x5c>
#ifdef _NEED_PRECISE_TICK_MS_CONVERSION
	/* use 64-bit math to keep precision */
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
#else
	/* simple multiplication keeps precision */
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
800434b6:	3e800793          	li	a5,1000
800434ba:	02f515b3          	mulh	a1,a0,a5
800434be:	06400613          	li	a2,100
800434c2:	4681                	li	a3,0
800434c4:	02f50533          	mul	a0,a0,a5
800434c8:	d81fc0ef          	jal	ra,80040248 <__udivdi3>
800434cc:	842a                	mv	s0,a0
		return __ticks_to_ms(ticks);
800434ce:	bd7d                	j	8004338c <z_impl_k_sleep+0x5c>

800434d0 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
800434d0:	800457b7          	lui	a5,0x80045
800434d4:	1f07a503          	lw	a0,496(a5) # 800451f0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451f1>
800434d8:	8082                	ret

800434da <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
800434da:	00d54783          	lbu	a5,13(a0)
800434de:	8bfd                	andi	a5,a5,31
800434e0:	e789                	bnez	a5,800434ea <z_is_thread_ready+0x10>
800434e2:	4d08                	lw	a0,24(a0)
800434e4:	00153513          	seqz	a0,a0
800434e8:	8082                	ret
800434ea:	4501                	li	a0,0
}
800434ec:	8082                	ret

800434ee <k_is_in_isr>:
#endif
}

bool k_is_in_isr(void)
{
	return z_is_in_isr();
800434ee:	800457b7          	lui	a5,0x80045
800434f2:	1e87a503          	lw	a0,488(a5) # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
}
800434f6:	00a03533          	snez	a0,a0
800434fa:	8082                	ret

800434fc <z_is_thread_essential>:
 *
 * Returns true if current thread is essential, false if it is not.
 */
bool z_is_thread_essential(void)
{
	return (_current->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
800434fc:	800457b7          	lui	a5,0x80045
80043500:	1f07a783          	lw	a5,496(a5) # 800451f0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451f1>
80043504:	00c7c503          	lbu	a0,12(a5)
}
80043508:	8905                	andi	a0,a0,1
8004350a:	8082                	ret

8004350c <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
8004350c:	1101                	addi	sp,sp,-32
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
8004350e:	5302                	lw	t1,32(sp)
{
80043510:	cc22                	sw	s0,24(sp)
80043512:	ce06                	sw	ra,28(sp)
	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80043514:	c01a                	sw	t1,0(sp)
{
80043516:	842a                	mv	s0,a0
	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80043518:	d9efd0ef          	jal	ra,80040ab6 <z_new_thread>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
8004351c:	800457b7          	lui	a5,0x80045
80043520:	1f07a783          	lw	a5,496(a5) # 800451f0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451f1>
	sys_trace_thread_create(new_thread);
}
80043524:	40f2                	lw	ra,28(sp)
	new_thread->resource_pool = _current->resource_pool;
80043526:	57bc                	lw	a5,104(a5)
80043528:	d43c                	sw	a5,104(s0)
}
8004352a:	4462                	lw	s0,24(sp)
8004352c:	6105                	addi	sp,sp,32
8004352e:	8082                	ret

80043530 <z_thread_single_abort>:
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_thread_resume, K_OBJ_THREAD, k_tid_t);
#endif

void z_thread_single_abort(struct k_thread *thread)
{
	if (thread->fn_abort != NULL) {
80043530:	513c                	lw	a5,96(a0)
{
80043532:	1141                	addi	sp,sp,-16
80043534:	c422                	sw	s0,8(sp)
80043536:	c606                	sw	ra,12(sp)
80043538:	842a                	mv	s0,a0
	if (thread->fn_abort != NULL) {
8004353a:	c391                	beqz	a5,8004353e <z_thread_single_abort+0xe>
		thread->fn_abort();
8004353c:	9782                	jalr	a5

	if (IS_ENABLED(CONFIG_SMP)) {
		z_sched_abort(thread);
	}

	if (z_is_thread_ready(thread)) {
8004353e:	8522                	mv	a0,s0
80043540:	3f69                	jal	800434da <z_is_thread_ready>
80043542:	cd11                	beqz	a0,8004355e <z_thread_single_abort+0x2e>
		z_remove_thread_from_ready_q(thread);
80043544:	8522                	mv	a0,s0
80043546:	95bff0ef          	jal	ra,80042ea0 <z_remove_thread_from_ready_q>
		if (z_is_thread_timeout_active(thread)) {
			(void)z_abort_thread_timeout(thread);
		}
	}

	thread->base.thread_state |= _THREAD_DEAD;
8004354a:	00d44783          	lbu	a5,13(s0)
	z_object_uninit(thread);

	/* Revoke permissions on thread's ID so that it may be recycled */
	z_thread_perms_all_clear(thread);
#endif
}
8004354e:	40b2                	lw	ra,12(sp)
	thread->base.thread_state |= _THREAD_DEAD;
80043550:	0087e793          	ori	a5,a5,8
80043554:	00f406a3          	sb	a5,13(s0)
}
80043558:	4422                	lw	s0,8(sp)
8004355a:	0141                	addi	sp,sp,16
8004355c:	8082                	ret
		if (z_is_thread_pending(thread)) {
8004355e:	00d44783          	lbu	a5,13(s0)
80043562:	8b89                	andi	a5,a5,2
80043564:	c781                	beqz	a5,8004356c <z_thread_single_abort+0x3c>
			z_unpend_thread_no_timeout(thread);
80043566:	8522                	mv	a0,s0
80043568:	e29fe0ef          	jal	ra,80042390 <z_unpend_thread_no_timeout>
		if (z_is_thread_timeout_active(thread)) {
8004356c:	4c1c                	lw	a5,24(s0)
8004356e:	dff1                	beqz	a5,8004354a <z_thread_single_abort+0x1a>
	return z_abort_timeout(&thread->base.timeout);
80043570:	01840513          	addi	a0,s0,24
80043574:	23c1                	jal	80043b34 <z_abort_timeout>
80043576:	bfd1                	j	8004354a <z_thread_single_abort+0x1a>

80043578 <z_init_thread_base>:
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
80043578:	00d50623          	sb	a3,12(a0)
	thread_base->thread_state = (u8_t)initial_state;
8004357c:	00c506a3          	sb	a2,13(a0)

	thread_base->prio = priority;
80043580:	00b50723          	sb	a1,14(a0)

	thread_base->sched_locked = 0U;
80043584:	000507a3          	sb	zero,15(a0)
	node->next = NULL;
80043588:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
8004358c:	00052e23          	sw	zero,28(a0)

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
80043590:	8082                	ret

80043592 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu) {
80043592:	4108                	lw	a0,0(a0)
80043594:	c911                	beqz	a0,800435a8 <z_spin_lock_valid+0x16>
		if ((l->thread_cpu & 3) == _current_cpu->id) {
80043596:	800457b7          	lui	a5,0x80045
8004359a:	1fc7c783          	lbu	a5,508(a5) # 800451fc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451fd>
8004359e:	890d                	andi	a0,a0,3
800435a0:	8d1d                	sub	a0,a0,a5
800435a2:	00a03533          	snez	a0,a0
800435a6:	8082                	ret
			return false;
		}
	}
	return true;
800435a8:	4505                	li	a0,1
}
800435aa:	8082                	ret

800435ac <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (u32_t)_current)) {
800435ac:	800457b7          	lui	a5,0x80045
800435b0:	1e878793          	addi	a5,a5,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
800435b4:	0147c703          	lbu	a4,20(a5)
800435b8:	479c                	lw	a5,8(a5)
800435ba:	8fd9                	or	a5,a5,a4
800435bc:	4118                	lw	a4,0(a0)
800435be:	00f71663          	bne	a4,a5,800435ca <z_spin_unlock_valid+0x1e>
		return false;
	}
	l->thread_cpu = 0;
800435c2:	00052023          	sw	zero,0(a0)
	return true;
800435c6:	4505                	li	a0,1
800435c8:	8082                	ret
		return false;
800435ca:	4501                	li	a0,0
}
800435cc:	8082                	ret

800435ce <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (u32_t)_current;
800435ce:	800457b7          	lui	a5,0x80045
800435d2:	1e878793          	addi	a5,a5,488 # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
800435d6:	0147c703          	lbu	a4,20(a5)
800435da:	479c                	lw	a5,8(a5)
800435dc:	8fd9                	or	a5,a5,a4
800435de:	c11c                	sw	a5,0(a0)
}
800435e0:	8082                	ret

800435e2 <z_impl_k_thread_start>:
{
800435e2:	1101                	addi	sp,sp,-32
800435e4:	cc22                	sw	s0,24(sp)
800435e6:	c84a                	sw	s2,16(sp)
800435e8:	ce06                	sw	ra,28(sp)
800435ea:	ca26                	sw	s1,20(sp)
800435ec:	c64e                	sw	s3,12(sp)
800435ee:	892a                	mv	s2,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
800435f0:	4421                	li	s0,8
800435f2:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
800435f6:	800454b7          	lui	s1,0x80045
800435fa:	de048513          	addi	a0,s1,-544 # 80044de0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044de1>
	key = (mstatus & SOC_MSTATUS_IEN);
800435fe:	8821                	andi	s0,s0,8
80043600:	3f49                	jal	80043592 <z_spin_lock_valid>
80043602:	ed0d                	bnez	a0,8004363c <z_impl_k_thread_start+0x5a>
80043604:	800459b7          	lui	s3,0x80045
80043608:	800455b7          	lui	a1,0x80045
8004360c:	80045537          	lui	a0,0x80045
80043610:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80043614:	04e00693          	li	a3,78
80043618:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
8004361c:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043620:	8f6fe0ef          	jal	ra,80041716 <printk>
80043624:	80045537          	lui	a0,0x80045
80043628:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
8004362c:	8eafe0ef          	jal	ra,80041716 <printk>
80043630:	04e00593          	li	a1,78
80043634:	99098513          	addi	a0,s3,-1648
80043638:	8fcfe0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
8004363c:	de048513          	addi	a0,s1,-544
80043640:	3779                	jal	800435ce <z_spin_lock_set_owner>
	if (z_has_thread_started(thread)) {
80043642:	00d94783          	lbu	a5,13(s2)
80043646:	0047f713          	andi	a4,a5,4
8004364a:	eb31                	bnez	a4,8004369e <z_impl_k_thread_start+0xbc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
8004364c:	de048513          	addi	a0,s1,-544
80043650:	3fb1                	jal	800435ac <z_spin_unlock_valid>
80043652:	ed0d                	bnez	a0,8004368c <z_impl_k_thread_start+0xaa>
80043654:	800454b7          	lui	s1,0x80045
80043658:	800455b7          	lui	a1,0x80045
8004365c:	80045537          	lui	a0,0x80045
80043660:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80043664:	06100693          	li	a3,97
80043668:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
8004366c:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043670:	8a6fe0ef          	jal	ra,80041716 <printk>
80043674:	80045537          	lui	a0,0x80045
80043678:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
8004367c:	89afe0ef          	jal	ra,80041716 <printk>
80043680:	06100593          	li	a1,97
80043684:	99048513          	addi	a0,s1,-1648
80043688:	8acfe0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004368c:	30042473          	csrrs	s0,mstatus,s0
}
80043690:	40f2                	lw	ra,28(sp)
80043692:	4462                	lw	s0,24(sp)
80043694:	44d2                	lw	s1,20(sp)
80043696:	4942                	lw	s2,16(sp)
80043698:	49b2                	lw	s3,12(sp)
8004369a:	6105                	addi	sp,sp,32
8004369c:	8082                	ret
	thread->base.thread_state &= ~_THREAD_PRESTART;
8004369e:	9bed                	andi	a5,a5,-5
800436a0:	00f906a3          	sb	a5,13(s2)
	if (z_is_thread_ready(thread)) {
800436a4:	854a                	mv	a0,s2
800436a6:	e35ff0ef          	jal	ra,800434da <z_is_thread_ready>
800436aa:	c501                	beqz	a0,800436b2 <z_impl_k_thread_start+0xd0>
		z_add_thread_to_ready_q(thread);
800436ac:	854a                	mv	a0,s2
800436ae:	cc6ff0ef          	jal	ra,80042b74 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
800436b2:	85a2                	mv	a1,s0
}
800436b4:	4462                	lw	s0,24(sp)
800436b6:	40f2                	lw	ra,28(sp)
800436b8:	4942                	lw	s2,16(sp)
800436ba:	49b2                	lw	s3,12(sp)
	z_reschedule(&lock, key);
800436bc:	de048513          	addi	a0,s1,-544
}
800436c0:	44d2                	lw	s1,20(sp)
800436c2:	6105                	addi	sp,sp,32
	z_reschedule(&lock, key);
800436c4:	d9dfe06f          	j	80042460 <z_reschedule>

800436c8 <z_impl_k_thread_create>:
{
800436c8:	7139                	addi	sp,sp,-64
800436ca:	d256                	sw	s5,36(sp)
800436cc:	8ab6                	mv	s5,a3
	__ASSERT(!z_is_in_isr(), "Threads may not be created in ISRs");
800436ce:	800456b7          	lui	a3,0x80045
800436d2:	1e86a683          	lw	a3,488(a3) # 800451e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451e9>
{
800436d6:	dc22                	sw	s0,56(sp)
800436d8:	da26                	sw	s1,52(sp)
800436da:	d64e                	sw	s3,44(sp)
800436dc:	d452                	sw	s4,40(sp)
800436de:	de06                	sw	ra,60(sp)
800436e0:	d84a                	sw	s2,48(sp)
800436e2:	84aa                	mv	s1,a0
800436e4:	89ae                	mv	s3,a1
800436e6:	8a32                	mv	s4,a2
800436e8:	4416                	lw	s0,68(sp)
	__ASSERT(!z_is_in_isr(), "Threads may not be created in ISRs");
800436ea:	c6a9                	beqz	a3,80043734 <z_impl_k_thread_create+0x6c>
800436ec:	80045937          	lui	s2,0x80045
800436f0:	800455b7          	lui	a1,0x80045
800436f4:	80045537          	lui	a0,0x80045
800436f8:	1f200693          	li	a3,498
800436fc:	c2c90613          	addi	a2,s2,-980 # 80044c2c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044c2d>
80043700:	b1858593          	addi	a1,a1,-1256 # 80044b18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b19>
80043704:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043708:	ce46                	sw	a7,28(sp)
8004370a:	cc42                	sw	a6,24(sp)
8004370c:	ca3e                	sw	a5,20(sp)
8004370e:	c83a                	sw	a4,16(sp)
80043710:	806fe0ef          	jal	ra,80041716 <printk>
80043714:	80045537          	lui	a0,0x80045
80043718:	c5050513          	addi	a0,a0,-944 # 80044c50 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044c51>
8004371c:	ffbfd0ef          	jal	ra,80041716 <printk>
80043720:	1f200593          	li	a1,498
80043724:	c2c90513          	addi	a0,s2,-980
80043728:	80cfe0ef          	jal	ra,80041734 <assert_post_action>
8004372c:	48f2                	lw	a7,28(sp)
8004372e:	4862                	lw	a6,24(sp)
80043730:	47d2                	lw	a5,20(sp)
80043732:	4742                	lw	a4,16(sp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80043734:	4686                	lw	a3,64(sp)
80043736:	c202                	sw	zero,4(sp)
80043738:	8652                	mv	a2,s4
8004373a:	c036                	sw	a3,0(sp)
8004373c:	85ce                	mv	a1,s3
8004373e:	86d6                	mv	a3,s5
80043740:	8526                	mv	a0,s1
80043742:	dcbff0ef          	jal	ra,8004350c <z_setup_new_thread>
	if (delay != K_FOREVER) {
80043746:	57fd                	li	a5,-1
80043748:	00f40663          	beq	s0,a5,80043754 <z_impl_k_thread_create+0x8c>
	if (delay == 0) {
8004374c:	ec11                	bnez	s0,80043768 <z_impl_k_thread_create+0xa0>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)
8004374e:	8526                	mv	a0,s1
80043750:	e93ff0ef          	jal	ra,800435e2 <z_impl_k_thread_start>
}
80043754:	50f2                	lw	ra,60(sp)
80043756:	5462                	lw	s0,56(sp)
80043758:	8526                	mv	a0,s1
8004375a:	5942                	lw	s2,48(sp)
8004375c:	54d2                	lw	s1,52(sp)
8004375e:	59b2                	lw	s3,44(sp)
80043760:	5a22                	lw	s4,40(sp)
80043762:	5a92                	lw	s5,36(sp)
80043764:	6121                	addi	sp,sp,64
80043766:	8082                	ret
	return (s32_t)ceiling_fraction(ms, ms_per_tick);
80043768:	0425                	addi	s0,s0,9
8004376a:	4629                	li	a2,10
8004376c:	02c44633          	div	a2,s0,a2
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
80043770:	800435b7          	lui	a1,0x80043
80043774:	c4a58593          	addi	a1,a1,-950 # 80042c4a <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042c4b>
80043778:	01848513          	addi	a0,s1,24
8004377c:	0605                	addi	a2,a2,1
8004377e:	22fd                	jal	8004396c <z_add_timeout>
80043780:	bfd1                	j	80043754 <z_impl_k_thread_create+0x8c>

80043782 <z_init_static_threads>:
{
80043782:	7179                	addi	sp,sp,-48
	_FOREACH_STATIC_THREAD(thread_data) {
80043784:	800457b7          	lui	a5,0x80045
{
80043788:	d04a                	sw	s2,32(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
8004378a:	80045937          	lui	s2,0x80045
{
8004378e:	d422                	sw	s0,40(sp)
80043790:	d226                	sw	s1,36(sp)
80043792:	d606                	sw	ra,44(sp)
80043794:	ce4e                	sw	s3,28(sp)
80043796:	cc52                	sw	s4,24(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
80043798:	d9878413          	addi	s0,a5,-616 # 80044d98 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d99>
8004379c:	d9878493          	addi	s1,a5,-616
800437a0:	d9890913          	addi	s2,s2,-616 # 80044d98 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d99>
800437a4:	03246463          	bltu	s0,s2,800437cc <z_init_static_threads+0x4a>
	_FOREACH_STATIC_THREAD(thread_data) {
800437a8:	8426                	mv	s0,s1
	k_sched_lock();
800437aa:	d87fe0ef          	jal	ra,80042530 <k_sched_lock>
		if (thread_data->init_delay != K_FOREVER) {
800437ae:	54fd                	li	s1,-1
800437b0:	49a9                	li	s3,10
800437b2:	80043a37          	lui	s4,0x80043
	_FOREACH_STATIC_THREAD(thread_data) {
800437b6:	05246063          	bltu	s0,s2,800437f6 <z_init_static_threads+0x74>
}
800437ba:	5422                	lw	s0,40(sp)
800437bc:	50b2                	lw	ra,44(sp)
800437be:	5492                	lw	s1,36(sp)
800437c0:	5902                	lw	s2,32(sp)
800437c2:	49f2                	lw	s3,28(sp)
800437c4:	4a62                	lw	s4,24(sp)
800437c6:	6145                	addi	sp,sp,48
	k_sched_unlock();
800437c8:	a58ff06f          	j	80042a20 <k_sched_unlock>
		z_setup_new_thread(
800437cc:	545c                	lw	a5,44(s0)
800437ce:	c23e                	sw	a5,4(sp)
800437d0:	501c                	lw	a5,32(s0)
800437d2:	c03e                	sw	a5,0(sp)
800437d4:	485c                	lw	a5,20(s0)
800437d6:	01c42883          	lw	a7,28(s0)
800437da:	01842803          	lw	a6,24(s0)
800437de:	4818                	lw	a4,16(s0)
800437e0:	4454                	lw	a3,12(s0)
800437e2:	4410                	lw	a2,8(s0)
800437e4:	404c                	lw	a1,4(s0)
800437e6:	4008                	lw	a0,0(s0)
800437e8:	d25ff0ef          	jal	ra,8004350c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
800437ec:	401c                	lw	a5,0(s0)
800437ee:	cfe0                	sw	s0,92(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
800437f0:	03040413          	addi	s0,s0,48
800437f4:	bf45                	j	800437a4 <z_init_static_threads+0x22>
		if (thread_data->init_delay != K_FOREVER) {
800437f6:	5050                	lw	a2,36(s0)
800437f8:	00960663          	beq	a2,s1,80043804 <z_init_static_threads+0x82>
			schedule_new_thread(thread_data->init_thread,
800437fc:	4008                	lw	a0,0(s0)
	if (delay == 0) {
800437fe:	e611                	bnez	a2,8004380a <z_init_static_threads+0x88>
80043800:	de3ff0ef          	jal	ra,800435e2 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
80043804:	03040413          	addi	s0,s0,48
80043808:	b77d                	j	800437b6 <z_init_static_threads+0x34>
8004380a:	0625                	addi	a2,a2,9
8004380c:	03364633          	div	a2,a2,s3
80043810:	c4aa0593          	addi	a1,s4,-950 # 80042c4a <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042c4b>
80043814:	0561                	addi	a0,a0,24
80043816:	0605                	addi	a2,a2,1
80043818:	2a91                	jal	8004396c <z_add_timeout>
8004381a:	b7ed                	j	80043804 <z_init_static_threads+0x82>

8004381c <z_impl_k_thread_abort>:

extern void z_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
8004381c:	1101                	addi	sp,sp,-32
8004381e:	cc22                	sw	s0,24(sp)
80043820:	ca26                	sw	s1,20(sp)
80043822:	ce06                	sw	ra,28(sp)
80043824:	c84a                	sw	s2,16(sp)
80043826:	84aa                	mv	s1,a0
	 * to have been in place to prevent the thread from waking up
	 * due to a delivered interrupt.  Leave a dummy spinlock in
	 * place to do that.  This API should be revisted though, it
	 * doesn't look SMP-safe as it stands.
	 */
	struct k_spinlock lock = {};
80043828:	c602                	sw	zero,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
8004382a:	4421                	li	s0,8
8004382c:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80043830:	0068                	addi	a0,sp,12
	key = (mstatus & SOC_MSTATUS_IEN);
80043832:	8821                	andi	s0,s0,8
80043834:	d5fff0ef          	jal	ra,80043592 <z_spin_lock_valid>
80043838:	ed0d                	bnez	a0,80043872 <z_impl_k_thread_abort+0x56>
8004383a:	80045937          	lui	s2,0x80045
8004383e:	800455b7          	lui	a1,0x80045
80043842:	80045537          	lui	a0,0x80045
80043846:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
8004384a:	04e00693          	li	a3,78
8004384e:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043852:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043856:	ec1fd0ef          	jal	ra,80041716 <printk>
8004385a:	80045537          	lui	a0,0x80045
8004385e:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80043862:	eb5fd0ef          	jal	ra,80041716 <printk>
80043866:	04e00593          	li	a1,78
8004386a:	99090513          	addi	a0,s2,-1648
8004386e:	ec7fd0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80043872:	0068                	addi	a0,sp,12
80043874:	d5bff0ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);

	__ASSERT((thread->base.user_options & K_ESSENTIAL) == 0U,
80043878:	00c4c783          	lbu	a5,12(s1)
8004387c:	8b85                	andi	a5,a5,1
8004387e:	cf8d                	beqz	a5,800438b8 <z_impl_k_thread_abort+0x9c>
80043880:	80045937          	lui	s2,0x80045
80043884:	800455b7          	lui	a1,0x80045
80043888:	80045537          	lui	a0,0x80045
8004388c:	ca458593          	addi	a1,a1,-860 # 80044ca4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044ca5>
80043890:	02900693          	li	a3,41
80043894:	c7890613          	addi	a2,s2,-904 # 80044c78 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044c79>
80043898:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
8004389c:	e7bfd0ef          	jal	ra,80041716 <printk>
800438a0:	80045537          	lui	a0,0x80045
800438a4:	cd850513          	addi	a0,a0,-808 # 80044cd8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044cd9>
800438a8:	e6ffd0ef          	jal	ra,80041716 <printk>
800438ac:	02900593          	li	a1,41
800438b0:	c7890513          	addi	a0,s2,-904
800438b4:	e81fd0ef          	jal	ra,80041734 <assert_post_action>
		 "essential thread aborted");

	z_thread_single_abort(thread);
800438b8:	8526                	mv	a0,s1
800438ba:	c77ff0ef          	jal	ra,80043530 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	z_reschedule(&lock, key);
800438be:	85a2                	mv	a1,s0
800438c0:	0068                	addi	a0,sp,12
800438c2:	b9ffe0ef          	jal	ra,80042460 <z_reschedule>
}
800438c6:	40f2                	lw	ra,28(sp)
800438c8:	4462                	lw	s0,24(sp)
800438ca:	44d2                	lw	s1,20(sp)
800438cc:	4942                	lw	s2,16(sp)
800438ce:	6105                	addi	sp,sp,32
800438d0:	8082                	ret

800438d2 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
800438d2:	800457b7          	lui	a5,0x80045
800438d6:	de47a783          	lw	a5,-540(a5) # 80044de4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044de5>
800438da:	e399                	bnez	a5,800438e0 <elapsed+0xe>
800438dc:	96efe06f          	j	80041a4a <z_clock_elapsed>
}
800438e0:	4501                	li	a0,0
800438e2:	8082                	ret

800438e4 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
800438e4:	411c                	lw	a5,0(a0)
800438e6:	cd01                	beqz	a0,800438fe <remove_timeout+0x1a>
800438e8:	80045737          	lui	a4,0x80045
	return (node == list->tail) ? NULL : node->next;
800438ec:	d5472703          	lw	a4,-684(a4) # 80044d54 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d55>
800438f0:	00e50763          	beq	a0,a4,800438fe <remove_timeout+0x1a>
	if (next(t) != NULL) {
800438f4:	c789                	beqz	a5,800438fe <remove_timeout+0x1a>
		next(t)->dticks += t->dticks;
800438f6:	4798                	lw	a4,8(a5)
800438f8:	4514                	lw	a3,8(a0)
800438fa:	9736                	add	a4,a4,a3
800438fc:	c798                	sw	a4,8(a5)
	node->prev->next = node->next;
800438fe:	4158                	lw	a4,4(a0)
80043900:	c31c                	sw	a5,0(a4)
	node->next->prev = node->prev;
80043902:	c3d8                	sw	a4,4(a5)
	node->next = NULL;
80043904:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
80043908:	00052223          	sw	zero,4(a0)
}
8004390c:	8082                	ret

8004390e <next_timeout>:

static s32_t next_timeout(void)
{
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
8004390e:	800457b7          	lui	a5,0x80045
80043912:	dec7c783          	lbu	a5,-532(a5) # 80044dec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044ded>
{
80043916:	1141                	addi	sp,sp,-16
80043918:	c606                	sw	ra,12(sp)
8004391a:	c422                	sw	s0,8(sp)
8004391c:	c226                	sw	s1,4(sp)
8004391e:	557d                	li	a0,-1
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
80043920:	e789                	bnez	a5,8004392a <next_timeout+0x1c>
80043922:	80000537          	lui	a0,0x80000
80043926:	fff54513          	not	a0,a0
	return list->head == list;
8004392a:	800457b7          	lui	a5,0x80045
8004392e:	d5078793          	addi	a5,a5,-688 # 80044d50 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d51>
80043932:	4380                	lw	s0,0(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80043934:	00f40f63          	beq	s0,a5,80043952 <next_timeout+0x44>
	struct _timeout *to = first();
	s32_t ret = to == NULL ? maxw : MAX(0, to->dticks - elapsed());
80043938:	cc09                	beqz	s0,80043952 <next_timeout+0x44>
8004393a:	4404                	lw	s1,8(s0)
8004393c:	f97ff0ef          	jal	ra,800438d2 <elapsed>
80043940:	8c89                	sub	s1,s1,a0
80043942:	4501                	li	a0,0
80043944:	0004c763          	bltz	s1,80043952 <next_timeout+0x44>
80043948:	4400                	lw	s0,8(s0)
8004394a:	f89ff0ef          	jal	ra,800438d2 <elapsed>
8004394e:	40a40533          	sub	a0,s0,a0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
80043952:	800457b7          	lui	a5,0x80045
80043956:	1f87a783          	lw	a5,504(a5) # 800451f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451f9>
8004395a:	c781                	beqz	a5,80043962 <next_timeout+0x54>
8004395c:	00a7d363          	bge	a5,a0,80043962 <next_timeout+0x54>
80043960:	853e                	mv	a0,a5
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
80043962:	40b2                	lw	ra,12(sp)
80043964:	4422                	lw	s0,8(sp)
80043966:	4492                	lw	s1,4(sp)
80043968:	0141                	addi	sp,sp,16
8004396a:	8082                	ret

8004396c <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
8004396c:	411c                	lw	a5,0(a0)
{
8004396e:	7179                	addi	sp,sp,-48
80043970:	d422                	sw	s0,40(sp)
80043972:	d226                	sw	s1,36(sp)
80043974:	ce4e                	sw	s3,28(sp)
80043976:	d606                	sw	ra,44(sp)
80043978:	d04a                	sw	s2,32(sp)
8004397a:	cc52                	sw	s4,24(sp)
8004397c:	ca56                	sw	s5,20(sp)
8004397e:	c85a                	sw	s6,16(sp)
80043980:	c65e                	sw	s7,12(sp)
80043982:	c462                	sw	s8,8(sp)
80043984:	842a                	mv	s0,a0
80043986:	89ae                	mv	s3,a1
80043988:	84b2                	mv	s1,a2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
8004398a:	cf8d                	beqz	a5,800439c4 <z_add_timeout+0x58>
8004398c:	80045937          	lui	s2,0x80045
80043990:	800455b7          	lui	a1,0x80045
80043994:	80045537          	lui	a0,0x80045
80043998:	d1c58593          	addi	a1,a1,-740 # 80044d1c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d1d>
8004399c:	04d00693          	li	a3,77
800439a0:	cf490613          	addi	a2,s2,-780 # 80044cf4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044cf5>
800439a4:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
800439a8:	d6ffd0ef          	jal	ra,80041716 <printk>
800439ac:	80045537          	lui	a0,0x80045
800439b0:	b3050513          	addi	a0,a0,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
800439b4:	d63fd0ef          	jal	ra,80041716 <printk>
800439b8:	04d00593          	li	a1,77
800439bc:	cf490513          	addi	a0,s2,-780
800439c0:	d75fd0ef          	jal	ra,80041734 <assert_post_action>
	to->fn = fn;
800439c4:	01342623          	sw	s3,12(s0)
	ticks = MAX(1, ticks);
800439c8:	00904363          	bgtz	s1,800439ce <z_add_timeout+0x62>
800439cc:	4485                	li	s1,1
	__asm__ volatile ("csrrc %0, mstatus, %1"
800439ce:	49a1                	li	s3,8
800439d0:	3009b9f3          	csrrc	s3,mstatus,s3
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
800439d4:	80045a37          	lui	s4,0x80045
800439d8:	de8a0513          	addi	a0,s4,-536 # 80044de8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044de9>
	key = (mstatus & SOC_MSTATUS_IEN);
800439dc:	0089f993          	andi	s3,s3,8
800439e0:	bb3ff0ef          	jal	ra,80043592 <z_spin_lock_valid>
800439e4:	ed0d                	bnez	a0,80043a1e <z_add_timeout+0xb2>
800439e6:	80045937          	lui	s2,0x80045
800439ea:	800455b7          	lui	a1,0x80045
800439ee:	80045537          	lui	a0,0x80045
800439f2:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
800439f6:	04e00693          	li	a3,78
800439fa:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
800439fe:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043a02:	d15fd0ef          	jal	ra,80041716 <printk>
80043a06:	80045537          	lui	a0,0x80045
80043a0a:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80043a0e:	d09fd0ef          	jal	ra,80041716 <printk>
80043a12:	04e00593          	li	a1,78
80043a16:	99090513          	addi	a0,s2,-1648
80043a1a:	d1bfd0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80043a1e:	de8a0513          	addi	a0,s4,-536
80043a22:	badff0ef          	jal	ra,800435ce <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
80043a26:	eadff0ef          	jal	ra,800438d2 <elapsed>
80043a2a:	9526                	add	a0,a0,s1
	return list->head == list;
80043a2c:	800454b7          	lui	s1,0x80045
80043a30:	d504a903          	lw	s2,-688(s1) # 80044d50 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d51>
80043a34:	c408                	sw	a0,8(s0)
80043a36:	d5048493          	addi	s1,s1,-688
	return sys_dlist_is_empty(list) ? NULL : list->head;
80043a3a:	00990c63          	beq	s2,s1,80043a52 <z_add_timeout+0xe6>
		for (t = first(); t != NULL; t = next(t)) {
			__ASSERT(t->dticks >= 0, "");
80043a3e:	80045ab7          	lui	s5,0x80045
80043a42:	80045b37          	lui	s6,0x80045
80043a46:	80045bb7          	lui	s7,0x80045
80043a4a:	80045c37          	lui	s8,0x80045
		for (t = first(); t != NULL; t = next(t)) {
80043a4e:	00091963          	bnez	s2,80043a60 <z_add_timeout+0xf4>
	node->prev = list->tail;
80043a52:	40dc                	lw	a5,4(s1)
	node->next = list;
80043a54:	c004                	sw	s1,0(s0)
	node->prev = list->tail;
80043a56:	c05c                	sw	a5,4(s0)
	list->tail->next = node;
80043a58:	40dc                	lw	a5,4(s1)
80043a5a:	c380                	sw	s0,0(a5)
	list->tail = node;
80043a5c:	c0c0                	sw	s0,4(s1)
80043a5e:	a891                	j	80043ab2 <z_add_timeout+0x146>
			__ASSERT(t->dticks >= 0, "");
80043a60:	00892783          	lw	a5,8(s2)
80043a64:	0207d663          	bgez	a5,80043a90 <z_add_timeout+0x124>
80043a68:	d3cb0593          	addi	a1,s6,-708 # 80044d3c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d3d>
80043a6c:	05600693          	li	a3,86
80043a70:	cf4a8613          	addi	a2,s5,-780 # 80044cf4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044cf5>
80043a74:	8f8b8513          	addi	a0,s7,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043a78:	c9ffd0ef          	jal	ra,80041716 <printk>
80043a7c:	b30c0513          	addi	a0,s8,-1232 # 80044b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044b31>
80043a80:	c97fd0ef          	jal	ra,80041716 <printk>
80043a84:	05600593          	li	a1,86
80043a88:	cf4a8513          	addi	a0,s5,-780
80043a8c:	ca9fd0ef          	jal	ra,80041734 <assert_post_action>

			if (t->dticks > to->dticks) {
80043a90:	00892703          	lw	a4,8(s2)
80043a94:	441c                	lw	a5,8(s0)
80043a96:	08e7d763          	bge	a5,a4,80043b24 <z_add_timeout+0x1b8>
				t->dticks -= to->dticks;
80043a9a:	40f707b3          	sub	a5,a4,a5
80043a9e:	00f92423          	sw	a5,8(s2)
	node->prev = successor->prev;
80043aa2:	00492783          	lw	a5,4(s2)
	node->next = successor;
80043aa6:	01242023          	sw	s2,0(s0)
	node->prev = successor->prev;
80043aaa:	c05c                	sw	a5,4(s0)
	successor->prev->next = node;
80043aac:	c380                	sw	s0,0(a5)
	successor->prev = node;
80043aae:	00892223          	sw	s0,4(s2)
	return list->head == list;
80043ab2:	409c                	lw	a5,0(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80043ab4:	00978963          	beq	a5,s1,80043ac6 <z_add_timeout+0x15a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
80043ab8:	00f41763          	bne	s0,a5,80043ac6 <z_add_timeout+0x15a>
			z_clock_set_timeout(next_timeout(), false);
80043abc:	e53ff0ef          	jal	ra,8004390e <next_timeout>
80043ac0:	4581                	li	a1,0
80043ac2:	e61fd0ef          	jal	ra,80041922 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043ac6:	de8a0513          	addi	a0,s4,-536
80043aca:	ae3ff0ef          	jal	ra,800435ac <z_spin_unlock_valid>
80043ace:	ed0d                	bnez	a0,80043b08 <z_add_timeout+0x19c>
80043ad0:	80045437          	lui	s0,0x80045
80043ad4:	800455b7          	lui	a1,0x80045
80043ad8:	80045537          	lui	a0,0x80045
80043adc:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80043ae0:	06100693          	li	a3,97
80043ae4:	99040613          	addi	a2,s0,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043ae8:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043aec:	c2bfd0ef          	jal	ra,80041716 <printk>
80043af0:	80045537          	lui	a0,0x80045
80043af4:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80043af8:	c1ffd0ef          	jal	ra,80041716 <printk>
80043afc:	06100593          	li	a1,97
80043b00:	99040513          	addi	a0,s0,-1648
80043b04:	c31fd0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80043b08:	3009a9f3          	csrrs	s3,mstatus,s3
		}
	}
}
80043b0c:	50b2                	lw	ra,44(sp)
80043b0e:	5422                	lw	s0,40(sp)
80043b10:	5492                	lw	s1,36(sp)
80043b12:	5902                	lw	s2,32(sp)
80043b14:	49f2                	lw	s3,28(sp)
80043b16:	4a62                	lw	s4,24(sp)
80043b18:	4ad2                	lw	s5,20(sp)
80043b1a:	4b42                	lw	s6,16(sp)
80043b1c:	4bb2                	lw	s7,12(sp)
80043b1e:	4c22                	lw	s8,8(sp)
80043b20:	6145                	addi	sp,sp,48
80043b22:	8082                	ret
			to->dticks -= t->dticks;
80043b24:	8f99                	sub	a5,a5,a4
80043b26:	c41c                	sw	a5,8(s0)
	return (node == list->tail) ? NULL : node->next;
80043b28:	40dc                	lw	a5,4(s1)
80043b2a:	f32784e3          	beq	a5,s2,80043a52 <z_add_timeout+0xe6>
80043b2e:	00092903          	lw	s2,0(s2)
80043b32:	bf31                	j	80043a4e <z_add_timeout+0xe2>

80043b34 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
80043b34:	1101                	addi	sp,sp,-32
80043b36:	cc22                	sw	s0,24(sp)
80043b38:	c64e                	sw	s3,12(sp)
80043b3a:	ce06                	sw	ra,28(sp)
80043b3c:	ca26                	sw	s1,20(sp)
80043b3e:	c84a                	sw	s2,16(sp)
80043b40:	89aa                	mv	s3,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80043b42:	4421                	li	s0,8
80043b44:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80043b48:	800454b7          	lui	s1,0x80045
80043b4c:	de848513          	addi	a0,s1,-536 # 80044de8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044de9>
	key = (mstatus & SOC_MSTATUS_IEN);
80043b50:	8821                	andi	s0,s0,8
80043b52:	a41ff0ef          	jal	ra,80043592 <z_spin_lock_valid>
80043b56:	ed0d                	bnez	a0,80043b90 <z_abort_timeout+0x5c>
80043b58:	80045937          	lui	s2,0x80045
80043b5c:	800455b7          	lui	a1,0x80045
80043b60:	80045537          	lui	a0,0x80045
80043b64:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80043b68:	04e00693          	li	a3,78
80043b6c:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043b70:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043b74:	ba3fd0ef          	jal	ra,80041716 <printk>
80043b78:	80045537          	lui	a0,0x80045
80043b7c:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80043b80:	b97fd0ef          	jal	ra,80041716 <printk>
80043b84:	04e00593          	li	a1,78
80043b88:	99090513          	addi	a0,s2,-1648
80043b8c:	ba9fd0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80043b90:	de848513          	addi	a0,s1,-536
80043b94:	a3bff0ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
80043b98:	0009a783          	lw	a5,0(s3)
	int ret = -EINVAL;
80043b9c:	5929                	li	s2,-22
		if (sys_dnode_is_linked(&to->node)) {
80043b9e:	c789                	beqz	a5,80043ba8 <z_abort_timeout+0x74>
			remove_timeout(to);
80043ba0:	854e                	mv	a0,s3
80043ba2:	d43ff0ef          	jal	ra,800438e4 <remove_timeout>
			ret = 0;
80043ba6:	4901                	li	s2,0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043ba8:	de848513          	addi	a0,s1,-536
80043bac:	a01ff0ef          	jal	ra,800435ac <z_spin_unlock_valid>
80043bb0:	ed0d                	bnez	a0,80043bea <z_abort_timeout+0xb6>
80043bb2:	800454b7          	lui	s1,0x80045
80043bb6:	800455b7          	lui	a1,0x80045
80043bba:	80045537          	lui	a0,0x80045
80043bbe:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80043bc2:	06100693          	li	a3,97
80043bc6:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043bca:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043bce:	b49fd0ef          	jal	ra,80041716 <printk>
80043bd2:	80045537          	lui	a0,0x80045
80043bd6:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80043bda:	b3dfd0ef          	jal	ra,80041716 <printk>
80043bde:	06100593          	li	a1,97
80043be2:	99048513          	addi	a0,s1,-1648
80043be6:	b4ffd0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80043bea:	30042473          	csrrs	s0,mstatus,s0
		}
	}

	return ret;
}
80043bee:	40f2                	lw	ra,28(sp)
80043bf0:	4462                	lw	s0,24(sp)
80043bf2:	854a                	mv	a0,s2
80043bf4:	44d2                	lw	s1,20(sp)
80043bf6:	4942                	lw	s2,16(sp)
80043bf8:	49b2                	lw	s3,12(sp)
80043bfa:	6105                	addi	sp,sp,32
80043bfc:	8082                	ret

80043bfe <z_get_next_timeout_expiry>:

	return ticks - elapsed();
}

s32_t z_get_next_timeout_expiry(void)
{
80043bfe:	1141                	addi	sp,sp,-16
80043c00:	c422                	sw	s0,8(sp)
80043c02:	c606                	sw	ra,12(sp)
80043c04:	c226                	sw	s1,4(sp)
80043c06:	c04a                	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80043c08:	4421                	li	s0,8
80043c0a:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80043c0e:	800454b7          	lui	s1,0x80045
80043c12:	de848513          	addi	a0,s1,-536 # 80044de8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044de9>
	key = (mstatus & SOC_MSTATUS_IEN);
80043c16:	8821                	andi	s0,s0,8
80043c18:	97bff0ef          	jal	ra,80043592 <z_spin_lock_valid>
80043c1c:	ed0d                	bnez	a0,80043c56 <z_get_next_timeout_expiry+0x58>
80043c1e:	80045937          	lui	s2,0x80045
80043c22:	800455b7          	lui	a1,0x80045
80043c26:	80045537          	lui	a0,0x80045
80043c2a:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80043c2e:	04e00693          	li	a3,78
80043c32:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043c36:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043c3a:	addfd0ef          	jal	ra,80041716 <printk>
80043c3e:	80045537          	lui	a0,0x80045
80043c42:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80043c46:	ad1fd0ef          	jal	ra,80041716 <printk>
80043c4a:	04e00593          	li	a1,78
80043c4e:	99090513          	addi	a0,s2,-1648
80043c52:	ae3fd0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80043c56:	de848513          	addi	a0,s1,-536
80043c5a:	975ff0ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	s32_t ret = K_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
80043c5e:	cb1ff0ef          	jal	ra,8004390e <next_timeout>
80043c62:	892a                	mv	s2,a0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043c64:	de848513          	addi	a0,s1,-536
80043c68:	945ff0ef          	jal	ra,800435ac <z_spin_unlock_valid>
80043c6c:	ed0d                	bnez	a0,80043ca6 <z_get_next_timeout_expiry+0xa8>
80043c6e:	800454b7          	lui	s1,0x80045
80043c72:	800455b7          	lui	a1,0x80045
80043c76:	80045537          	lui	a0,0x80045
80043c7a:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80043c7e:	06100693          	li	a3,97
80043c82:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043c86:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043c8a:	a8dfd0ef          	jal	ra,80041716 <printk>
80043c8e:	80045537          	lui	a0,0x80045
80043c92:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80043c96:	a81fd0ef          	jal	ra,80041716 <printk>
80043c9a:	06100593          	li	a1,97
80043c9e:	99048513          	addi	a0,s1,-1648
80043ca2:	a93fd0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80043ca6:	30042473          	csrrs	s0,mstatus,s0
	}
	return ret;
}
80043caa:	40b2                	lw	ra,12(sp)
80043cac:	4422                	lw	s0,8(sp)
80043cae:	854a                	mv	a0,s2
80043cb0:	4492                	lw	s1,4(sp)
80043cb2:	4902                	lw	s2,0(sp)
80043cb4:	0141                	addi	sp,sp,16
80043cb6:	8082                	ret

80043cb8 <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
80043cb8:	1101                	addi	sp,sp,-32
80043cba:	cc22                	sw	s0,24(sp)
80043cbc:	c84a                	sw	s2,16(sp)
80043cbe:	c452                	sw	s4,8(sp)
80043cc0:	ce06                	sw	ra,28(sp)
80043cc2:	ca26                	sw	s1,20(sp)
80043cc4:	c64e                	sw	s3,12(sp)
80043cc6:	892a                	mv	s2,a0
80043cc8:	8a2e                	mv	s4,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
80043cca:	4421                	li	s0,8
80043ccc:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80043cd0:	800454b7          	lui	s1,0x80045
80043cd4:	de848513          	addi	a0,s1,-536 # 80044de8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044de9>
	key = (mstatus & SOC_MSTATUS_IEN);
80043cd8:	8821                	andi	s0,s0,8
80043cda:	8b9ff0ef          	jal	ra,80043592 <z_spin_lock_valid>
80043cde:	ed0d                	bnez	a0,80043d18 <z_set_timeout_expiry+0x60>
80043ce0:	800459b7          	lui	s3,0x80045
80043ce4:	800455b7          	lui	a1,0x80045
80043ce8:	80045537          	lui	a0,0x80045
80043cec:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80043cf0:	04e00693          	li	a3,78
80043cf4:	99098613          	addi	a2,s3,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043cf8:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043cfc:	a1bfd0ef          	jal	ra,80041716 <printk>
80043d00:	80045537          	lui	a0,0x80045
80043d04:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80043d08:	a0ffd0ef          	jal	ra,80041716 <printk>
80043d0c:	04e00593          	li	a1,78
80043d10:	99098513          	addi	a0,s3,-1648
80043d14:	a21fd0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80043d18:	de848513          	addi	a0,s1,-536
80043d1c:	8b3ff0ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next = next_timeout();
80043d20:	befff0ef          	jal	ra,8004390e <next_timeout>
		 * what we have.  Also don't try to set a timeout when
		 * one is about to expire: drivers have internal logic
		 * that will bump the timeout to the "next" tick if
		 * it's not considered to be settable as directed.
		 */
		if (sooner && !imminent) {
80043d24:	00a95963          	bge	s2,a0,80043d36 <z_set_timeout_expiry+0x7e>
80043d28:	4785                	li	a5,1
80043d2a:	00a7d663          	bge	a5,a0,80043d36 <z_set_timeout_expiry+0x7e>
			z_clock_set_timeout(ticks, idle);
80043d2e:	85d2                	mv	a1,s4
80043d30:	854a                	mv	a0,s2
80043d32:	bf1fd0ef          	jal	ra,80041922 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043d36:	de848513          	addi	a0,s1,-536
80043d3a:	873ff0ef          	jal	ra,800435ac <z_spin_unlock_valid>
80043d3e:	ed0d                	bnez	a0,80043d78 <z_set_timeout_expiry+0xc0>
80043d40:	800454b7          	lui	s1,0x80045
80043d44:	800455b7          	lui	a1,0x80045
80043d48:	80045537          	lui	a0,0x80045
80043d4c:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80043d50:	06100693          	li	a3,97
80043d54:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043d58:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043d5c:	9bbfd0ef          	jal	ra,80041716 <printk>
80043d60:	80045537          	lui	a0,0x80045
80043d64:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80043d68:	9affd0ef          	jal	ra,80041716 <printk>
80043d6c:	06100593          	li	a1,97
80043d70:	99048513          	addi	a0,s1,-1648
80043d74:	9c1fd0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80043d78:	30042473          	csrrs	s0,mstatus,s0
		}
	}
}
80043d7c:	40f2                	lw	ra,28(sp)
80043d7e:	4462                	lw	s0,24(sp)
80043d80:	44d2                	lw	s1,20(sp)
80043d82:	4942                	lw	s2,16(sp)
80043d84:	49b2                	lw	s3,12(sp)
80043d86:	4a22                	lw	s4,8(sp)
80043d88:	6105                	addi	sp,sp,32
80043d8a:	8082                	ret

80043d8c <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
80043d8c:	7179                	addi	sp,sp,-48
80043d8e:	d422                	sw	s0,40(sp)
80043d90:	cc52                	sw	s4,24(sp)
80043d92:	d606                	sw	ra,44(sp)
80043d94:	d226                	sw	s1,36(sp)
80043d96:	d04a                	sw	s2,32(sp)
80043d98:	ce4e                	sw	s3,28(sp)
80043d9a:	ca56                	sw	s5,20(sp)
80043d9c:	c85a                	sw	s6,16(sp)
80043d9e:	c65e                	sw	s7,12(sp)
80043da0:	c462                	sw	s8,8(sp)
80043da2:	c266                	sw	s9,4(sp)
80043da4:	c06a                	sw	s10,0(sp)
80043da6:	8a2a                	mv	s4,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80043da8:	4421                	li	s0,8
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
80043daa:	89aff0ef          	jal	ra,80042e44 <z_time_slice>
80043dae:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80043db2:	80045937          	lui	s2,0x80045
80043db6:	de890513          	addi	a0,s2,-536 # 80044de8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044de9>
	key = (mstatus & SOC_MSTATUS_IEN);
80043dba:	8821                	andi	s0,s0,8
80043dbc:	fd6ff0ef          	jal	ra,80043592 <z_spin_lock_valid>
80043dc0:	ed0d                	bnez	a0,80043dfa <z_clock_announce+0x6e>
80043dc2:	800454b7          	lui	s1,0x80045
80043dc6:	800455b7          	lui	a1,0x80045
80043dca:	80045537          	lui	a0,0x80045
80043dce:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80043dd2:	04e00693          	li	a3,78
80043dd6:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043dda:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043dde:	939fd0ef          	jal	ra,80041716 <printk>
80043de2:	80045537          	lui	a0,0x80045
80043de6:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80043dea:	92dfd0ef          	jal	ra,80041716 <printk>
80043dee:	04e00593          	li	a1,78
80043df2:	99048513          	addi	a0,s1,-1648
80043df6:	93ffd0ef          	jal	ra,80041734 <assert_post_action>
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
80043dfa:	800459b7          	lui	s3,0x80045
	z_spin_lock_set_owner(l);
80043dfe:	de890513          	addi	a0,s2,-536
80043e02:	fccff0ef          	jal	ra,800435ce <z_spin_lock_set_owner>
80043e06:	800454b7          	lui	s1,0x80045
80043e0a:	df49a223          	sw	s4,-540(s3) # 80044de4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044de5>
	return list->head == list;
80043e0e:	80045a37          	lui	s4,0x80045
80043e12:	de498993          	addi	s3,s3,-540
80043e16:	d50a0a13          	addi	s4,s4,-688 # 80044d50 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d51>
80043e1a:	db848493          	addi	s1,s1,-584 # 80044db8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044db9>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043e1e:	80045ab7          	lui	s5,0x80045
80043e22:	80045bb7          	lui	s7,0x80045
80043e26:	80045b37          	lui	s6,0x80045
80043e2a:	80045c37          	lui	s8,0x80045
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80043e2e:	80045cb7          	lui	s9,0x80045
80043e32:	000a2d03          	lw	s10,0(s4)
80043e36:	0009a783          	lw	a5,0(s3)
80043e3a:	4094                	lw	a3,0(s1)
80043e3c:	40c8                	lw	a0,4(s1)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80043e3e:	014d0b63          	beq	s10,s4,80043e54 <z_clock_announce+0xc8>

	while (first() != NULL && first()->dticks <= announce_remaining) {
80043e42:	000d0963          	beqz	s10,80043e54 <z_clock_announce+0xc8>
80043e46:	008d2703          	lw	a4,8(s10)
80043e4a:	08e7d663          	bge	a5,a4,80043ed6 <z_clock_announce+0x14a>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
80043e4e:	8f1d                	sub	a4,a4,a5
80043e50:	00ed2423          	sw	a4,8(s10)
	}

	curr_tick += announce_remaining;
80043e54:	96be                	add	a3,a3,a5
80043e56:	41f7d713          	srai	a4,a5,0x1f
80043e5a:	972a                	add	a4,a4,a0
80043e5c:	00f6b7b3          	sltu	a5,a3,a5
80043e60:	97ba                	add	a5,a5,a4
80043e62:	c094                	sw	a3,0(s1)
80043e64:	c0dc                	sw	a5,4(s1)
	announce_remaining = 0;
80043e66:	0009a023          	sw	zero,0(s3)

	z_clock_set_timeout(next_timeout(), false);
80043e6a:	aa5ff0ef          	jal	ra,8004390e <next_timeout>
80043e6e:	4581                	li	a1,0
80043e70:	ab3fd0ef          	jal	ra,80041922 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043e74:	de890513          	addi	a0,s2,-536
80043e78:	f34ff0ef          	jal	ra,800435ac <z_spin_unlock_valid>
80043e7c:	ed0d                	bnez	a0,80043eb6 <z_clock_announce+0x12a>
80043e7e:	800454b7          	lui	s1,0x80045
80043e82:	800455b7          	lui	a1,0x80045
80043e86:	80045537          	lui	a0,0x80045
80043e8a:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80043e8e:	06100693          	li	a3,97
80043e92:	99048613          	addi	a2,s1,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043e96:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043e9a:	87dfd0ef          	jal	ra,80041716 <printk>
80043e9e:	80045537          	lui	a0,0x80045
80043ea2:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80043ea6:	871fd0ef          	jal	ra,80041716 <printk>
80043eaa:	06100593          	li	a1,97
80043eae:	99048513          	addi	a0,s1,-1648
80043eb2:	883fd0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80043eb6:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
80043eba:	50b2                	lw	ra,44(sp)
80043ebc:	5422                	lw	s0,40(sp)
80043ebe:	5492                	lw	s1,36(sp)
80043ec0:	5902                	lw	s2,32(sp)
80043ec2:	49f2                	lw	s3,28(sp)
80043ec4:	4a62                	lw	s4,24(sp)
80043ec6:	4ad2                	lw	s5,20(sp)
80043ec8:	4b42                	lw	s6,16(sp)
80043eca:	4bb2                	lw	s7,12(sp)
80043ecc:	4c22                	lw	s8,8(sp)
80043ece:	4c92                	lw	s9,4(sp)
80043ed0:	4d02                	lw	s10,0(sp)
80043ed2:	6145                	addi	sp,sp,48
80043ed4:	8082                	ret
		curr_tick += dt;
80043ed6:	96ba                	add	a3,a3,a4
80043ed8:	41f75593          	srai	a1,a4,0x1f
80043edc:	95aa                	add	a1,a1,a0
80043ede:	00e6b633          	sltu	a2,a3,a4
80043ee2:	962e                	add	a2,a2,a1
		announce_remaining -= dt;
80043ee4:	8f99                	sub	a5,a5,a4
		remove_timeout(t);
80043ee6:	856a                	mv	a0,s10
		t->dticks = 0;
80043ee8:	000d2423          	sw	zero,8(s10)
		curr_tick += dt;
80043eec:	c094                	sw	a3,0(s1)
80043eee:	c0d0                	sw	a2,4(s1)
		announce_remaining -= dt;
80043ef0:	00f9a023          	sw	a5,0(s3)
		remove_timeout(t);
80043ef4:	9f1ff0ef          	jal	ra,800438e4 <remove_timeout>
80043ef8:	de890513          	addi	a0,s2,-536
80043efc:	eb0ff0ef          	jal	ra,800435ac <z_spin_unlock_valid>
80043f00:	e50d                	bnez	a0,80043f2a <z_clock_announce+0x19e>
80043f02:	9e8b8593          	addi	a1,s7,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80043f06:	06100693          	li	a3,97
80043f0a:	990a8613          	addi	a2,s5,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043f0e:	8f8b0513          	addi	a0,s6,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043f12:	805fd0ef          	jal	ra,80041716 <printk>
80043f16:	a00c0513          	addi	a0,s8,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
80043f1a:	ffcfd0ef          	jal	ra,80041716 <printk>
80043f1e:	06100593          	li	a1,97
80043f22:	990a8513          	addi	a0,s5,-1648
80043f26:	80ffd0ef          	jal	ra,80041734 <assert_post_action>
80043f2a:	30042473          	csrrs	s0,mstatus,s0
		t->fn(t);
80043f2e:	00cd2783          	lw	a5,12(s10)
80043f32:	856a                	mv	a0,s10
	__asm__ volatile ("csrrc %0, mstatus, %1"
80043f34:	4421                	li	s0,8
80043f36:	9782                	jalr	a5
80043f38:	30043473          	csrrc	s0,mstatus,s0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80043f3c:	de890513          	addi	a0,s2,-536
	key = (mstatus & SOC_MSTATUS_IEN);
80043f40:	8821                	andi	s0,s0,8
80043f42:	e50ff0ef          	jal	ra,80043592 <z_spin_lock_valid>
80043f46:	e51d                	bnez	a0,80043f74 <z_clock_announce+0x1e8>
80043f48:	9b8c8593          	addi	a1,s9,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80043f4c:	04e00693          	li	a3,78
80043f50:	990a8613          	addi	a2,s5,-1648
80043f54:	8f8b0513          	addi	a0,s6,-1800
80043f58:	fbefd0ef          	jal	ra,80041716 <printk>
80043f5c:	80045537          	lui	a0,0x80045
80043f60:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80043f64:	fb2fd0ef          	jal	ra,80041716 <printk>
80043f68:	04e00593          	li	a1,78
80043f6c:	990a8513          	addi	a0,s5,-1648
80043f70:	fc4fd0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80043f74:	de890513          	addi	a0,s2,-536
80043f78:	e56ff0ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	return k;
80043f7c:	bd5d                	j	80043e32 <z_clock_announce+0xa6>

80043f7e <z_tick_get>:
{
	can_wait_forever = 1;
}

s64_t z_tick_get(void)
{
80043f7e:	1101                	addi	sp,sp,-32
80043f80:	ca26                	sw	s1,20(sp)
80043f82:	ce06                	sw	ra,28(sp)
80043f84:	cc22                	sw	s0,24(sp)
80043f86:	c84a                	sw	s2,16(sp)
80043f88:	c64e                	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80043f8a:	44a1                	li	s1,8
80043f8c:	3004b4f3          	csrrc	s1,mstatus,s1
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock");
80043f90:	80045937          	lui	s2,0x80045
80043f94:	de890513          	addi	a0,s2,-536 # 80044de8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044de9>
	key = (mstatus & SOC_MSTATUS_IEN);
80043f98:	88a1                	andi	s1,s1,8
80043f9a:	df8ff0ef          	jal	ra,80043592 <z_spin_lock_valid>
80043f9e:	ed0d                	bnez	a0,80043fd8 <z_tick_get+0x5a>
80043fa0:	80045437          	lui	s0,0x80045
80043fa4:	800455b7          	lui	a1,0x80045
80043fa8:	80045537          	lui	a0,0x80045
80043fac:	9b858593          	addi	a1,a1,-1608 # 800449b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449b9>
80043fb0:	04e00693          	li	a3,78
80043fb4:	99040613          	addi	a2,s0,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
80043fb8:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80043fbc:	f5afd0ef          	jal	ra,80041716 <printk>
80043fc0:	80045537          	lui	a0,0x80045
80043fc4:	9d050513          	addi	a0,a0,-1584 # 800449d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449d1>
80043fc8:	f4efd0ef          	jal	ra,80041716 <printk>
80043fcc:	04e00593          	li	a1,78
80043fd0:	99040513          	addi	a0,s0,-1648
80043fd4:	f60fd0ef          	jal	ra,80041734 <assert_post_action>
	z_spin_lock_set_owner(l);
80043fd8:	de890513          	addi	a0,s2,-536
80043fdc:	df2ff0ef          	jal	ra,800435ce <z_spin_lock_set_owner>
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
80043fe0:	a6bfd0ef          	jal	ra,80041a4a <z_clock_elapsed>
80043fe4:	800457b7          	lui	a5,0x80045
80043fe8:	db878793          	addi	a5,a5,-584 # 80044db8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044db9>
80043fec:	0007a983          	lw	s3,0(a5)
80043ff0:	43c0                	lw	s0,4(a5)
80043ff2:	99aa                	add	s3,s3,a0
80043ff4:	00a9b533          	sltu	a0,s3,a0
80043ff8:	942a                	add	s0,s0,a0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock!");
80043ffa:	de890513          	addi	a0,s2,-536
80043ffe:	daeff0ef          	jal	ra,800435ac <z_spin_unlock_valid>
80044002:	ed0d                	bnez	a0,8004403c <z_tick_get+0xbe>
80044004:	80045937          	lui	s2,0x80045
80044008:	800455b7          	lui	a1,0x80045
8004400c:	80045537          	lui	a0,0x80045
80044010:	9e858593          	addi	a1,a1,-1560 # 800449e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800449e9>
80044014:	06100693          	li	a3,97
80044018:	99090613          	addi	a2,s2,-1648 # 80044990 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044991>
8004401c:	8f850513          	addi	a0,a0,-1800 # 800448f8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800448f9>
80044020:	ef6fd0ef          	jal	ra,80041716 <printk>
80044024:	80045537          	lui	a0,0x80045
80044028:	a0050513          	addi	a0,a0,-1536 # 80044a00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044a01>
8004402c:	eeafd0ef          	jal	ra,80041716 <printk>
80044030:	06100593          	li	a1,97
80044034:	99090513          	addi	a0,s2,-1648
80044038:	efcfd0ef          	jal	ra,80041734 <assert_post_action>
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004403c:	3004a4f3          	csrrs	s1,mstatus,s1
	}
	return t;
}
80044040:	85a2                	mv	a1,s0
80044042:	40f2                	lw	ra,28(sp)
80044044:	4462                	lw	s0,24(sp)
80044046:	854e                	mv	a0,s3
80044048:	44d2                	lw	s1,20(sp)
8004404a:	4942                	lw	s2,16(sp)
8004404c:	49b2                	lw	s3,12(sp)
8004404e:	6105                	addi	sp,sp,32
80044050:	8082                	ret

80044052 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
80044052:	1141                	addi	sp,sp,-16
80044054:	c606                	sw	ra,12(sp)
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
80044056:	f29ff0ef          	jal	ra,80043f7e <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
8004405a:	40b2                	lw	ra,12(sp)
8004405c:	0141                	addi	sp,sp,16
8004405e:	8082                	ret

80044060 <z_impl_k_uptime_get_32>:

u32_t z_impl_k_uptime_get_32(void)
{
80044060:	1141                	addi	sp,sp,-16
80044062:	c606                	sw	ra,12(sp)
	return __ticks_to_ms(z_tick_get_32());
80044064:	fefff0ef          	jal	ra,80044052 <z_tick_get_32>
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
80044068:	3e800793          	li	a5,1000
8004406c:	02f535b3          	mulhu	a1,a0,a5
80044070:	06400613          	li	a2,100
80044074:	4681                	li	a3,0
80044076:	02f50533          	mul	a0,a0,a5
8004407a:	9cefc0ef          	jal	ra,80040248 <__udivdi3>
}
8004407e:	40b2                	lw	ra,12(sp)
80044080:	0141                	addi	sp,sp,16
80044082:	8082                	ret

80044084 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
80044084:	1141                	addi	sp,sp,-16
80044086:	c422                	sw	s0,8(sp)
80044088:	c226                	sw	s1,4(sp)
	ARG_UNUSED(unused);
	struct k_mem_pool *p;

	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
8004408a:	80045437          	lui	s0,0x80045
8004408e:	800454b7          	lui	s1,0x80045
{
80044092:	c606                	sw	ra,12(sp)
	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
80044094:	d9840413          	addi	s0,s0,-616 # 80044d98 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d99>
80044098:	d9848493          	addi	s1,s1,-616 # 80044d98 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044d99>
8004409c:	00946863          	bltu	s0,s1,800440ac <init_static_pools+0x28>
		k_mem_pool_init(p);
	}

	return 0;
}
800440a0:	40b2                	lw	ra,12(sp)
800440a2:	4422                	lw	s0,8(sp)
800440a4:	4492                	lw	s1,4(sp)
800440a6:	4501                	li	a0,0
800440a8:	0141                	addi	sp,sp,16
800440aa:	8082                	ret
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
800440ac:	01440793          	addi	a5,s0,20
	z_sys_mem_pool_base_init(&p->base);
800440b0:	8522                	mv	a0,s0
	list->head = (sys_dnode_t *)list;
800440b2:	c85c                	sw	a5,20(s0)
	list->tail = (sys_dnode_t *)list;
800440b4:	cc1c                	sw	a5,24(s0)
800440b6:	b21fc0ef          	jal	ra,80040bd6 <z_sys_mem_pool_base_init>
	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
800440ba:	0471                	addi	s0,s0,28
800440bc:	b7c5                	j	8004409c <init_static_pools+0x18>

800440be <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
800440be:	8082                	ret
