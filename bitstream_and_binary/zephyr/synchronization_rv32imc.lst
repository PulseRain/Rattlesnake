
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

80040000 <__start>:

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
80040000:	00000297          	auipc	t0,0x0
80040004:	01428293          	addi	t0,t0,20 # 80040014 <__irq_wrapper>
	csrw mtvec, t0
80040008:	30529073          	csrw	mtvec,t0

	/* Jump to __initialize */
	tail __initialize
8004000c:	ad85                	j	8004067c <__initialize>
	...

Disassembly of section reset:

80040010 <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
80040010:	25b5                	jal	8004067c <__initialize>
	...

Disassembly of section exceptions:

80040014 <__irq_wrapper>:
 * In this architecture, system call (ECALL) is used to perform context
 * switching or IRQ offloading (when enabled).
 */
SECTION_FUNC(exception.entry, __irq_wrapper)
	/* Allocate space on thread stack to save registers */
	addi sp, sp, -__NANO_ESF_SIZEOF
80040014:	715d                	addi	sp,sp,-80
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	sw ra, __NANO_ESF_ra_OFFSET(sp)
80040016:	c006                	sw	ra,0(sp)
	sw gp, __NANO_ESF_gp_OFFSET(sp)
80040018:	c20e                	sw	gp,4(sp)
	sw tp, __NANO_ESF_tp_OFFSET(sp)
8004001a:	c412                	sw	tp,8(sp)
	sw t0, __NANO_ESF_t0_OFFSET(sp)
8004001c:	c616                	sw	t0,12(sp)
	sw t1, __NANO_ESF_t1_OFFSET(sp)
8004001e:	c81a                	sw	t1,16(sp)
	sw t2, __NANO_ESF_t2_OFFSET(sp)
80040020:	ca1e                	sw	t2,20(sp)
	sw t3, __NANO_ESF_t3_OFFSET(sp)
80040022:	cc72                	sw	t3,24(sp)
	sw t4, __NANO_ESF_t4_OFFSET(sp)
80040024:	ce76                	sw	t4,28(sp)
	sw t5, __NANO_ESF_t5_OFFSET(sp)
80040026:	d07a                	sw	t5,32(sp)
	sw t6, __NANO_ESF_t6_OFFSET(sp)
80040028:	d27e                	sw	t6,36(sp)
	sw a0, __NANO_ESF_a0_OFFSET(sp)
8004002a:	d42a                	sw	a0,40(sp)
	sw a1, __NANO_ESF_a1_OFFSET(sp)
8004002c:	d62e                	sw	a1,44(sp)
	sw a2, __NANO_ESF_a2_OFFSET(sp)
8004002e:	d832                	sw	a2,48(sp)
	sw a3, __NANO_ESF_a3_OFFSET(sp)
80040030:	da36                	sw	a3,52(sp)
	sw a4, __NANO_ESF_a4_OFFSET(sp)
80040032:	dc3a                	sw	a4,56(sp)
	sw a5, __NANO_ESF_a5_OFFSET(sp)
80040034:	de3e                	sw	a5,60(sp)
	sw a6, __NANO_ESF_a6_OFFSET(sp)
80040036:	c0c2                	sw	a6,64(sp)
	sw a7, __NANO_ESF_a7_OFFSET(sp)
80040038:	c2c6                	sw	a7,68(sp)

	/* Save MEPC register */
	csrr t0, mepc
8004003a:	341022f3          	csrr	t0,mepc
	sw t0, __NANO_ESF_mepc_OFFSET(sp)
8004003e:	c496                	sw	t0,72(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, SOC_MSTATUS_REG
80040040:	300022f3          	csrr	t0,mstatus
	sw t0, __NANO_ESF_mstatus_OFFSET(sp)
80040044:	c696                	sw	t0,76(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
80040046:	1ae000ef          	jal	ra,800401f4 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
8004004a:	00000313          	li	t1,0
	bnez a0, is_interrupt
8004004e:	e905                	bnez	a0,8004007e <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
80040050:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
80040054:	800003b7          	lui	t2,0x80000
80040058:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
8004005c:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
80040060:	432d                	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call,
	 * otherwise handle fault
	 */
	beq t0, t1, is_syscall
80040062:	00628a63          	beq	t0,t1,80040076 <is_syscall>
	 * Stack pointer is pointing to a NANO_ESF structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to no_reschedule
	 * to restore stack.
	 */
	addi a0, sp, 0
80040066:	00010513          	mv	a0,sp
	la ra, no_reschedule
8004006a:	00000097          	auipc	ra,0x0
8004006e:	11e08093          	addi	ra,ra,286 # 80040188 <no_reschedule>
	tail _Fault
80040072:	7ea0006f          	j	8004085c <_Fault>

80040076 <is_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	lw t0, __NANO_ESF_mepc_OFFSET(sp)
80040076:	42a6                	lw	t0,72(sp)
	addi t0, t0, 4
80040078:	0291                	addi	t0,t0,4
	sw t0, __NANO_ESF_mepc_OFFSET(sp)
8004007a:	c496                	sw	t0,72(sp)
#endif

	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
8004007c:	a041                	j	800400fc <reschedule>

8004007e <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
8004007e:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
80040082:	00002397          	auipc	t2,0x2
80040086:	70a38393          	addi	t2,t2,1802 # 8004278c <_kernel>
	lw sp, _kernel_offset_to_irq_stack(t2)
8004008a:	0043a103          	lw	sp,4(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
8004008e:	1141                	addi	sp,sp,-16
	sw t0, 0x00(sp)
80040090:	c016                	sw	t0,0(sp)

80040092 <on_irq_stack>:

on_irq_stack:
	/* Increment _kernel.nested variable */
	lw t3, _kernel_offset_to_nested(t2)
80040092:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
80040096:	0e05                	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
80040098:	01c3a023          	sw	t3,0(t2)

	/*
	 * If we are here due to a system call, t1 register should != 0.
	 * In this case, perform IRQ offloading, otherwise jump to call_irq
	 */
	beqz t1, call_irq
8004009c:	00030863          	beqz	t1,800400ac <call_irq>
	/*
	 * Call z_irq_do_offload to handle IRQ offloading.
	 * Set return address to on_thread_stack in order to jump there
	 * upon returning from z_irq_do_offload
	 */
	la ra, on_thread_stack
800400a0:	00000097          	auipc	ra,0x0
800400a4:	03808093          	addi	ra,ra,56 # 800400d8 <on_thread_stack>
	tail z_irq_do_offload
800400a8:	0170006f          	j	800408be <z_irq_do_offload>

800400ac <call_irq>:
#ifdef CONFIG_TRACING
	call z_sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
800400ac:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
800400b0:	800002b7          	lui	t0,0x80000
800400b4:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
800400b8:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
800400bc:	128000ef          	jal	ra,800401e4 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 8-bytes wide, we should shift index by 3)
	 */
	la t0, _sw_isr_table
800400c0:	00002297          	auipc	t0,0x2
800400c4:	de828293          	addi	t0,t0,-536 # 80041ea8 <_sw_isr_table>
	slli a0, a0, 3
800400c8:	050e                	slli	a0,a0,0x3
	add t0, t0, a0
800400ca:	92aa                	add	t0,t0,a0

	/* Load argument in a0 register */
	lw a0, 0x00(t0)
800400cc:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	lw t1, 0x04(t0)
800400d0:	0042a303          	lw	t1,4(t0)
	lw t1, 0x04(sp)
	lw a0, 0x00(sp)
	addi sp, sp, 16
#endif
	/* Call ISR function */
	jalr ra, t1
800400d4:	000300e7          	jalr	t1

800400d8 <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
800400d8:	00002317          	auipc	t1,0x2
800400dc:	6b430313          	addi	t1,t1,1716 # 8004278c <_kernel>

	/* Decrement _kernel.nested variable */
	lw t2, _kernel_offset_to_nested(t1)
800400e0:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
800400e4:	13fd                	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
800400e6:	00732023          	sw	t2,0(t1)

	/* Restore thread stack pointer */
	lw t0, 0x00(sp)
800400ea:	4282                	lw	t0,0(sp)
	addi sp, t0, 0
800400ec:	00028113          	mv	sp,t0
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	lw t2, _kernel_offset_to_current(t1)
800400f0:	00832383          	lw	t2,8(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	lw t3, _kernel_offset_to_ready_q_cache(t1)
800400f4:	02032e03          	lw	t3,32(t1)
	beq t3, t2, no_reschedule
800400f8:	087e0863          	beq	t3,t2,80040188 <no_reschedule>

800400fc <reschedule>:
reschedule:
#if CONFIG_TRACING
	call z_sys_trace_thread_switched_in
#endif
	/* Get reference to _kernel */
	la t0, _kernel
800400fc:	00002297          	auipc	t0,0x2
80040100:	69028293          	addi	t0,t0,1680 # 8004278c <_kernel>

	/* Get pointer to _kernel.current */
	lw t1, _kernel_offset_to_current(t0)
80040104:	0082a303          	lw	t1,8(t0)

	/*
	 * Save callee-saved registers of current thread
	 * prior to handle context-switching
	 */
	sw s0, _thread_offset_to_s0(t1)
80040108:	02832623          	sw	s0,44(t1)
	sw s1, _thread_offset_to_s1(t1)
8004010c:	02932823          	sw	s1,48(t1)
	sw s2, _thread_offset_to_s2(t1)
80040110:	03232a23          	sw	s2,52(t1)
	sw s3, _thread_offset_to_s3(t1)
80040114:	03332c23          	sw	s3,56(t1)
	sw s4, _thread_offset_to_s4(t1)
80040118:	03432e23          	sw	s4,60(t1)
	sw s5, _thread_offset_to_s5(t1)
8004011c:	05532023          	sw	s5,64(t1)
	sw s6, _thread_offset_to_s6(t1)
80040120:	05632223          	sw	s6,68(t1)
	sw s7, _thread_offset_to_s7(t1)
80040124:	05732423          	sw	s7,72(t1)
	sw s8, _thread_offset_to_s8(t1)
80040128:	05832623          	sw	s8,76(t1)
	sw s9, _thread_offset_to_s9(t1)
8004012c:	05932823          	sw	s9,80(t1)
	sw s10, _thread_offset_to_s10(t1)
80040130:	05a32a23          	sw	s10,84(t1)
	sw s11, _thread_offset_to_s11(t1)
80040134:	05b32c23          	sw	s11,88(t1)

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	sw sp, _thread_offset_to_sp(t1)
80040138:	02232423          	sw	sp,40(t1)
	la t2, _k_neg_eagain
8004013c:	00002397          	auipc	t2,0x2
80040140:	3c838393          	addi	t2,t2,968 # 80042504 <_k_neg_eagain>
	lw t3, 0x00(t2)
80040144:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
80040148:	07c32623          	sw	t3,108(t1)

	/* Get next thread to schedule. */
	lw t1, _kernel_offset_to_ready_q_cache(t0)
8004014c:	0202a303          	lw	t1,32(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	sw t1, _kernel_offset_to_current(t0)
80040150:	0062a423          	sw	t1,8(t0)

	/* Switch to new thread stack */
	lw sp, _thread_offset_to_sp(t1)
80040154:	02832103          	lw	sp,40(t1)

	/* Restore callee-saved registers of new thread */
	lw s0, _thread_offset_to_s0(t1)
80040158:	02c32403          	lw	s0,44(t1)
	lw s1, _thread_offset_to_s1(t1)
8004015c:	03032483          	lw	s1,48(t1)
	lw s2, _thread_offset_to_s2(t1)
80040160:	03432903          	lw	s2,52(t1)
	lw s3, _thread_offset_to_s3(t1)
80040164:	03832983          	lw	s3,56(t1)
	lw s4, _thread_offset_to_s4(t1)
80040168:	03c32a03          	lw	s4,60(t1)
	lw s5, _thread_offset_to_s5(t1)
8004016c:	04032a83          	lw	s5,64(t1)
	lw s6, _thread_offset_to_s6(t1)
80040170:	04432b03          	lw	s6,68(t1)
	lw s7, _thread_offset_to_s7(t1)
80040174:	04832b83          	lw	s7,72(t1)
	lw s8, _thread_offset_to_s8(t1)
80040178:	04c32c03          	lw	s8,76(t1)
	lw s9, _thread_offset_to_s9(t1)
8004017c:	05032c83          	lw	s9,80(t1)
	lw s10, _thread_offset_to_s10(t1)
80040180:	05432d03          	lw	s10,84(t1)
	lw s11, _thread_offset_to_s11(t1)
80040184:	05832d83          	lw	s11,88(t1)

80040188 <no_reschedule>:
	addi a0, sp, __NANO_ESF_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	lw t0, __NANO_ESF_mepc_OFFSET(sp)
80040188:	42a6                	lw	t0,72(sp)
	csrw mepc, t0
8004018a:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	lw t0, __NANO_ESF_mstatus_OFFSET(sp)
8004018e:	42b6                	lw	t0,76(sp)
	csrw SOC_MSTATUS_REG, t0
80040190:	30029073          	csrw	mstatus,t0

	/* Restore caller-saved registers from thread stack */
	lw ra, __NANO_ESF_ra_OFFSET(sp)
80040194:	4082                	lw	ra,0(sp)
	lw gp, __NANO_ESF_gp_OFFSET(sp)
80040196:	4192                	lw	gp,4(sp)
	lw tp, __NANO_ESF_tp_OFFSET(sp)
80040198:	4222                	lw	tp,8(sp)
	lw t0, __NANO_ESF_t0_OFFSET(sp)
8004019a:	42b2                	lw	t0,12(sp)
	lw t1, __NANO_ESF_t1_OFFSET(sp)
8004019c:	4342                	lw	t1,16(sp)
	lw t2, __NANO_ESF_t2_OFFSET(sp)
8004019e:	43d2                	lw	t2,20(sp)
	lw t3, __NANO_ESF_t3_OFFSET(sp)
800401a0:	4e62                	lw	t3,24(sp)
	lw t4, __NANO_ESF_t4_OFFSET(sp)
800401a2:	4ef2                	lw	t4,28(sp)
	lw t5, __NANO_ESF_t5_OFFSET(sp)
800401a4:	5f02                	lw	t5,32(sp)
	lw t6, __NANO_ESF_t6_OFFSET(sp)
800401a6:	5f92                	lw	t6,36(sp)
	lw a0, __NANO_ESF_a0_OFFSET(sp)
800401a8:	5522                	lw	a0,40(sp)
	lw a1, __NANO_ESF_a1_OFFSET(sp)
800401aa:	55b2                	lw	a1,44(sp)
	lw a2, __NANO_ESF_a2_OFFSET(sp)
800401ac:	5642                	lw	a2,48(sp)
	lw a3, __NANO_ESF_a3_OFFSET(sp)
800401ae:	56d2                	lw	a3,52(sp)
	lw a4, __NANO_ESF_a4_OFFSET(sp)
800401b0:	5762                	lw	a4,56(sp)
	lw a5, __NANO_ESF_a5_OFFSET(sp)
800401b2:	57f2                	lw	a5,60(sp)
	lw a6, __NANO_ESF_a6_OFFSET(sp)
800401b4:	4806                	lw	a6,64(sp)
	lw a7, __NANO_ESF_a7_OFFSET(sp)
800401b6:	4896                	lw	a7,68(sp)

	/* Release stack space */
	addi sp, sp, __NANO_ESF_SIZEOF
800401b8:	6161                	addi	sp,sp,80

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
800401ba:	30200073          	mret
	...

800401c0 <__swap>:
	lw a7, __NANO_ESF_a7_OFFSET(sp)

	/* Release stack space */
	addi sp, sp, __NANO_ESF_SIZEOF
#endif
	ecall
800401c0:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * __swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called z_set_thread_return_value(..).
	 */
	la t0, _kernel
800401c4:	00002297          	auipc	t0,0x2
800401c8:	5c828293          	addi	t0,t0,1480 # 8004278c <_kernel>

	/* Get pointer to _kernel.current */
	lw t1, _kernel_offset_to_current(t0)
800401cc:	0082a303          	lw	t1,8(t0)

	/* Load return value of __swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
800401d0:	06c32383          	lw	t2,108(t1)

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, SOC_MSTATUS_IEN
800401d4:	8921                	andi	a0,a0,8
	csrrs t0, mstatus, a0
800401d6:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
800401da:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
800401de:	00008067          	ret
	...

800401e4 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
800401e4:	4305                	li	t1,1
	sll t0, t1, a0
800401e6:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
800401ea:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
800401ee:	00008067          	ret
	...

800401f4 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
800401f4:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
800401f8:	80000337          	lui	t1,0x80000
	and t0, t0, t1
800401fc:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
80040200:	00000513          	li	a0,0
	beqz t0, not_interrupt
80040204:	00028363          	beqz	t0,8004020a <not_interrupt>
	addi a0, a0, 1
80040208:	0505                	addi	a0,a0,1

8004020a <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
8004020a:	00008067          	ret

Disassembly of section text:

80040210 <__lshrdi3>:
80040210:	02060063          	beqz	a2,80040230 <__lshrdi3+0x20>
80040214:	02000793          	li	a5,32
80040218:	40c787b3          	sub	a5,a5,a2
8004021c:	00f04c63          	bgtz	a5,80040234 <__lshrdi3+0x24>
80040220:	fe060513          	addi	a0,a2,-32
80040224:	00000713          	li	a4,0
80040228:	00a5d533          	srl	a0,a1,a0
8004022c:	00070593          	mv	a1,a4
80040230:	00008067          	ret
80040234:	00c5d733          	srl	a4,a1,a2
80040238:	00c55533          	srl	a0,a0,a2
8004023c:	00f595b3          	sll	a1,a1,a5
80040240:	00b56533          	or	a0,a0,a1
80040244:	fe9ff06f          	j	8004022c <__lshrdi3+0x1c>

80040248 <__udivdi3>:
80040248:	00058793          	mv	a5,a1
8004024c:	00060813          	mv	a6,a2
80040250:	00068713          	mv	a4,a3
80040254:	00050313          	mv	t1,a0
80040258:	28069663          	bnez	a3,800404e4 <__udivdi3+0x29c>
8004025c:	800428b7          	lui	a7,0x80042
80040260:	fd888893          	addi	a7,a7,-40 # 80041fd8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041fd9>
80040264:	0ec5f663          	bgeu	a1,a2,80040350 <__udivdi3+0x108>
80040268:	00010737          	lui	a4,0x10
8004026c:	0ce67863          	bgeu	a2,a4,8004033c <__udivdi3+0xf4>
80040270:	0ff00693          	li	a3,255
80040274:	00c6b6b3          	sltu	a3,a3,a2
80040278:	00369693          	slli	a3,a3,0x3
8004027c:	00d65733          	srl	a4,a2,a3
80040280:	00e888b3          	add	a7,a7,a4
80040284:	0008c703          	lbu	a4,0(a7)
80040288:	00d706b3          	add	a3,a4,a3
8004028c:	02000713          	li	a4,32
80040290:	40d70733          	sub	a4,a4,a3
80040294:	00070c63          	beqz	a4,800402ac <__udivdi3+0x64>
80040298:	00e797b3          	sll	a5,a5,a4
8004029c:	00d556b3          	srl	a3,a0,a3
800402a0:	00e61833          	sll	a6,a2,a4
800402a4:	00f6e5b3          	or	a1,a3,a5
800402a8:	00e51333          	sll	t1,a0,a4
800402ac:	01085513          	srli	a0,a6,0x10
800402b0:	02a5f733          	remu	a4,a1,a0
800402b4:	01081613          	slli	a2,a6,0x10
800402b8:	01065613          	srli	a2,a2,0x10
800402bc:	01035693          	srli	a3,t1,0x10
800402c0:	02a5d5b3          	divu	a1,a1,a0
800402c4:	01071713          	slli	a4,a4,0x10
800402c8:	00d766b3          	or	a3,a4,a3
800402cc:	02b607b3          	mul	a5,a2,a1
800402d0:	00058713          	mv	a4,a1
800402d4:	00f6fe63          	bgeu	a3,a5,800402f0 <__udivdi3+0xa8>
800402d8:	010686b3          	add	a3,a3,a6
800402dc:	fff58713          	addi	a4,a1,-1
800402e0:	0106e863          	bltu	a3,a6,800402f0 <__udivdi3+0xa8>
800402e4:	00f6f663          	bgeu	a3,a5,800402f0 <__udivdi3+0xa8>
800402e8:	ffe58713          	addi	a4,a1,-2
800402ec:	010686b3          	add	a3,a3,a6
800402f0:	40f686b3          	sub	a3,a3,a5
800402f4:	02a6f7b3          	remu	a5,a3,a0
800402f8:	01031313          	slli	t1,t1,0x10
800402fc:	01035313          	srli	t1,t1,0x10
80040300:	02a6d6b3          	divu	a3,a3,a0
80040304:	01079793          	slli	a5,a5,0x10
80040308:	0067e333          	or	t1,a5,t1
8004030c:	02d605b3          	mul	a1,a2,a3
80040310:	00068513          	mv	a0,a3
80040314:	00b37c63          	bgeu	t1,a1,8004032c <__udivdi3+0xe4>
80040318:	00680333          	add	t1,a6,t1
8004031c:	fff68513          	addi	a0,a3,-1
80040320:	01036663          	bltu	t1,a6,8004032c <__udivdi3+0xe4>
80040324:	00b37463          	bgeu	t1,a1,8004032c <__udivdi3+0xe4>
80040328:	ffe68513          	addi	a0,a3,-2
8004032c:	01071713          	slli	a4,a4,0x10
80040330:	00a76733          	or	a4,a4,a0
80040334:	00000593          	li	a1,0
80040338:	0e40006f          	j	8004041c <__udivdi3+0x1d4>
8004033c:	01000737          	lui	a4,0x1000
80040340:	01000693          	li	a3,16
80040344:	f2e66ce3          	bltu	a2,a4,8004027c <__udivdi3+0x34>
80040348:	01800693          	li	a3,24
8004034c:	f31ff06f          	j	8004027c <__udivdi3+0x34>
80040350:	00061663          	bnez	a2,8004035c <__udivdi3+0x114>
80040354:	00100693          	li	a3,1
80040358:	02c6d833          	divu	a6,a3,a2
8004035c:	000106b7          	lui	a3,0x10
80040360:	0cd87263          	bgeu	a6,a3,80040424 <__udivdi3+0x1dc>
80040364:	0ff00693          	li	a3,255
80040368:	0106f463          	bgeu	a3,a6,80040370 <__udivdi3+0x128>
8004036c:	00800713          	li	a4,8
80040370:	00e856b3          	srl	a3,a6,a4
80040374:	00d888b3          	add	a7,a7,a3
80040378:	0008c683          	lbu	a3,0(a7)
8004037c:	00e686b3          	add	a3,a3,a4
80040380:	02000713          	li	a4,32
80040384:	40d70733          	sub	a4,a4,a3
80040388:	0a071863          	bnez	a4,80040438 <__udivdi3+0x1f0>
8004038c:	410787b3          	sub	a5,a5,a6
80040390:	00100593          	li	a1,1
80040394:	01085613          	srli	a2,a6,0x10
80040398:	01081893          	slli	a7,a6,0x10
8004039c:	0108d893          	srli	a7,a7,0x10
800403a0:	01035693          	srli	a3,t1,0x10
800403a4:	02c7f733          	remu	a4,a5,a2
800403a8:	02c7d7b3          	divu	a5,a5,a2
800403ac:	01071713          	slli	a4,a4,0x10
800403b0:	00d766b3          	or	a3,a4,a3
800403b4:	02f88533          	mul	a0,a7,a5
800403b8:	00078713          	mv	a4,a5
800403bc:	00a6fe63          	bgeu	a3,a0,800403d8 <__udivdi3+0x190>
800403c0:	010686b3          	add	a3,a3,a6
800403c4:	fff78713          	addi	a4,a5,-1
800403c8:	0106e863          	bltu	a3,a6,800403d8 <__udivdi3+0x190>
800403cc:	00a6f663          	bgeu	a3,a0,800403d8 <__udivdi3+0x190>
800403d0:	ffe78713          	addi	a4,a5,-2
800403d4:	010686b3          	add	a3,a3,a6
800403d8:	40a686b3          	sub	a3,a3,a0
800403dc:	02c6f7b3          	remu	a5,a3,a2
800403e0:	01031313          	slli	t1,t1,0x10
800403e4:	01035313          	srli	t1,t1,0x10
800403e8:	02c6d6b3          	divu	a3,a3,a2
800403ec:	01079793          	slli	a5,a5,0x10
800403f0:	0067e333          	or	t1,a5,t1
800403f4:	02d888b3          	mul	a7,a7,a3
800403f8:	00068513          	mv	a0,a3
800403fc:	01137c63          	bgeu	t1,a7,80040414 <__udivdi3+0x1cc>
80040400:	00680333          	add	t1,a6,t1
80040404:	fff68513          	addi	a0,a3,-1 # ffff <CONFIG_ISR_STACK_SIZE+0xf7ff>
80040408:	01036663          	bltu	t1,a6,80040414 <__udivdi3+0x1cc>
8004040c:	01137463          	bgeu	t1,a7,80040414 <__udivdi3+0x1cc>
80040410:	ffe68513          	addi	a0,a3,-2
80040414:	01071713          	slli	a4,a4,0x10
80040418:	00a76733          	or	a4,a4,a0
8004041c:	00070513          	mv	a0,a4
80040420:	00008067          	ret
80040424:	010006b7          	lui	a3,0x1000
80040428:	01000713          	li	a4,16
8004042c:	f4d862e3          	bltu	a6,a3,80040370 <__udivdi3+0x128>
80040430:	01800713          	li	a4,24
80040434:	f3dff06f          	j	80040370 <__udivdi3+0x128>
80040438:	00e81833          	sll	a6,a6,a4
8004043c:	00d7d5b3          	srl	a1,a5,a3
80040440:	00e51333          	sll	t1,a0,a4
80040444:	00d556b3          	srl	a3,a0,a3
80040448:	01085513          	srli	a0,a6,0x10
8004044c:	00e797b3          	sll	a5,a5,a4
80040450:	02a5f733          	remu	a4,a1,a0
80040454:	00f6e8b3          	or	a7,a3,a5
80040458:	01081793          	slli	a5,a6,0x10
8004045c:	0107d793          	srli	a5,a5,0x10
80040460:	0108d613          	srli	a2,a7,0x10
80040464:	02a5d5b3          	divu	a1,a1,a0
80040468:	01071713          	slli	a4,a4,0x10
8004046c:	00c76733          	or	a4,a4,a2
80040470:	02b786b3          	mul	a3,a5,a1
80040474:	00058613          	mv	a2,a1
80040478:	00d77e63          	bgeu	a4,a3,80040494 <__udivdi3+0x24c>
8004047c:	01070733          	add	a4,a4,a6
80040480:	fff58613          	addi	a2,a1,-1
80040484:	01076863          	bltu	a4,a6,80040494 <__udivdi3+0x24c>
80040488:	00d77663          	bgeu	a4,a3,80040494 <__udivdi3+0x24c>
8004048c:	ffe58613          	addi	a2,a1,-2
80040490:	01070733          	add	a4,a4,a6
80040494:	40d706b3          	sub	a3,a4,a3
80040498:	02a6f733          	remu	a4,a3,a0
8004049c:	01089893          	slli	a7,a7,0x10
800404a0:	0108d893          	srli	a7,a7,0x10
800404a4:	02a6d6b3          	divu	a3,a3,a0
800404a8:	01071713          	slli	a4,a4,0x10
800404ac:	02d785b3          	mul	a1,a5,a3
800404b0:	011767b3          	or	a5,a4,a7
800404b4:	00068713          	mv	a4,a3
800404b8:	00b7fe63          	bgeu	a5,a1,800404d4 <__udivdi3+0x28c>
800404bc:	010787b3          	add	a5,a5,a6
800404c0:	fff68713          	addi	a4,a3,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xf0bdbf>
800404c4:	0107e863          	bltu	a5,a6,800404d4 <__udivdi3+0x28c>
800404c8:	00b7f663          	bgeu	a5,a1,800404d4 <__udivdi3+0x28c>
800404cc:	ffe68713          	addi	a4,a3,-2
800404d0:	010787b3          	add	a5,a5,a6
800404d4:	40b787b3          	sub	a5,a5,a1
800404d8:	01061593          	slli	a1,a2,0x10
800404dc:	00e5e5b3          	or	a1,a1,a4
800404e0:	eb5ff06f          	j	80040394 <__udivdi3+0x14c>
800404e4:	18d5e663          	bltu	a1,a3,80040670 <__udivdi3+0x428>
800404e8:	00010737          	lui	a4,0x10
800404ec:	04e6f463          	bgeu	a3,a4,80040534 <__udivdi3+0x2ec>
800404f0:	0ff00813          	li	a6,255
800404f4:	00d835b3          	sltu	a1,a6,a3
800404f8:	00359593          	slli	a1,a1,0x3
800404fc:	80042737          	lui	a4,0x80042
80040500:	00b6d833          	srl	a6,a3,a1
80040504:	fd870713          	addi	a4,a4,-40 # 80041fd8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041fd9>
80040508:	01070733          	add	a4,a4,a6
8004050c:	00074803          	lbu	a6,0(a4)
80040510:	00b80833          	add	a6,a6,a1
80040514:	02000593          	li	a1,32
80040518:	410585b3          	sub	a1,a1,a6
8004051c:	02059663          	bnez	a1,80040548 <__udivdi3+0x300>
80040520:	00100713          	li	a4,1
80040524:	eef6ece3          	bltu	a3,a5,8004041c <__udivdi3+0x1d4>
80040528:	00c53633          	sltu	a2,a0,a2
8004052c:	00164713          	xori	a4,a2,1
80040530:	eedff06f          	j	8004041c <__udivdi3+0x1d4>
80040534:	01000737          	lui	a4,0x1000
80040538:	01000593          	li	a1,16
8004053c:	fce6e0e3          	bltu	a3,a4,800404fc <__udivdi3+0x2b4>
80040540:	01800593          	li	a1,24
80040544:	fb9ff06f          	j	800404fc <__udivdi3+0x2b4>
80040548:	01065733          	srl	a4,a2,a6
8004054c:	00b696b3          	sll	a3,a3,a1
80040550:	00d766b3          	or	a3,a4,a3
80040554:	0106de93          	srli	t4,a3,0x10
80040558:	0107d733          	srl	a4,a5,a6
8004055c:	03d778b3          	remu	a7,a4,t4
80040560:	00b797b3          	sll	a5,a5,a1
80040564:	01055833          	srl	a6,a0,a6
80040568:	00f86333          	or	t1,a6,a5
8004056c:	01069793          	slli	a5,a3,0x10
80040570:	0107d793          	srli	a5,a5,0x10
80040574:	01035813          	srli	a6,t1,0x10
80040578:	00b61633          	sll	a2,a2,a1
8004057c:	03d75733          	divu	a4,a4,t4
80040580:	01089893          	slli	a7,a7,0x10
80040584:	0108e833          	or	a6,a7,a6
80040588:	02e78f33          	mul	t5,a5,a4
8004058c:	00070e13          	mv	t3,a4
80040590:	01e87e63          	bgeu	a6,t5,800405ac <__udivdi3+0x364>
80040594:	00d80833          	add	a6,a6,a3
80040598:	fff70e13          	addi	t3,a4,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xf0bdbf>
8004059c:	00d86863          	bltu	a6,a3,800405ac <__udivdi3+0x364>
800405a0:	01e87663          	bgeu	a6,t5,800405ac <__udivdi3+0x364>
800405a4:	ffe70e13          	addi	t3,a4,-2
800405a8:	00d80833          	add	a6,a6,a3
800405ac:	41e80833          	sub	a6,a6,t5
800405b0:	03d878b3          	remu	a7,a6,t4
800405b4:	03d85833          	divu	a6,a6,t4
800405b8:	01089893          	slli	a7,a7,0x10
800405bc:	03078eb3          	mul	t4,a5,a6
800405c0:	01031793          	slli	a5,t1,0x10
800405c4:	0107d793          	srli	a5,a5,0x10
800405c8:	00f8e7b3          	or	a5,a7,a5
800405cc:	00080713          	mv	a4,a6
800405d0:	01d7fe63          	bgeu	a5,t4,800405ec <__udivdi3+0x3a4>
800405d4:	00d787b3          	add	a5,a5,a3
800405d8:	fff80713          	addi	a4,a6,-1
800405dc:	00d7e863          	bltu	a5,a3,800405ec <__udivdi3+0x3a4>
800405e0:	01d7f663          	bgeu	a5,t4,800405ec <__udivdi3+0x3a4>
800405e4:	ffe80713          	addi	a4,a6,-2
800405e8:	00d787b3          	add	a5,a5,a3
800405ec:	010e1e13          	slli	t3,t3,0x10
800405f0:	41d787b3          	sub	a5,a5,t4
800405f4:	00010eb7          	lui	t4,0x10
800405f8:	00ee6733          	or	a4,t3,a4
800405fc:	fffe8813          	addi	a6,t4,-1 # ffff <CONFIG_ISR_STACK_SIZE+0xf7ff>
80040600:	01077333          	and	t1,a4,a6
80040604:	01075893          	srli	a7,a4,0x10
80040608:	01067833          	and	a6,a2,a6
8004060c:	01065613          	srli	a2,a2,0x10
80040610:	03030e33          	mul	t3,t1,a6
80040614:	03088833          	mul	a6,a7,a6
80040618:	010e5693          	srli	a3,t3,0x10
8004061c:	02c30333          	mul	t1,t1,a2
80040620:	01030333          	add	t1,t1,a6
80040624:	006686b3          	add	a3,a3,t1
80040628:	02c888b3          	mul	a7,a7,a2
8004062c:	0106f463          	bgeu	a3,a6,80040634 <__udivdi3+0x3ec>
80040630:	01d888b3          	add	a7,a7,t4
80040634:	0106d613          	srli	a2,a3,0x10
80040638:	011608b3          	add	a7,a2,a7
8004063c:	0317e663          	bltu	a5,a7,80040668 <__udivdi3+0x420>
80040640:	cf179ae3          	bne	a5,a7,80040334 <__udivdi3+0xec>
80040644:	000107b7          	lui	a5,0x10
80040648:	fff78793          	addi	a5,a5,-1 # ffff <CONFIG_ISR_STACK_SIZE+0xf7ff>
8004064c:	00f6f6b3          	and	a3,a3,a5
80040650:	01069693          	slli	a3,a3,0x10
80040654:	00fe7e33          	and	t3,t3,a5
80040658:	00b51533          	sll	a0,a0,a1
8004065c:	01c686b3          	add	a3,a3,t3
80040660:	00000593          	li	a1,0
80040664:	dad57ce3          	bgeu	a0,a3,8004041c <__udivdi3+0x1d4>
80040668:	fff70713          	addi	a4,a4,-1
8004066c:	cc9ff06f          	j	80040334 <__udivdi3+0xec>
80040670:	00000593          	li	a1,0
80040674:	00000713          	li	a4,0
80040678:	da5ff06f          	j	8004041c <__udivdi3+0x1d4>

8004067c <__initialize>:

	/*
	 * Initially, setup stack pointer to
	 * _interrupt_stack + CONFIG_ISR_STACK_SIZE
	 */
	la sp, _interrupt_stack
8004067c:	00003117          	auipc	sp,0x3
80040680:	f4410113          	addi	sp,sp,-188 # 800435c0 <_interrupt_stack>
	li t0, CONFIG_ISR_STACK_SIZE
80040684:	000012b7          	lui	t0,0x1
80040688:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
8004068c:	9116                	add	sp,sp,t0

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
8004068e:	2c81                	jal	800408de <_PrepC>

80040690 <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
80040690:	3a80006f          	j	80040a38 <z_thread_entry>
	...

80040696 <helloLoop>:
 * @param my_sem       thread's own semaphore
 * @param other_sem    other thread's semaphore
 */
void helloLoop(const char *my_name,
	       struct k_sem *my_sem, struct k_sem *other_sem)
{
80040696:	1101                	addi	sp,sp,-32
80040698:	cc22                	sw	s0,24(sp)
8004069a:	ca26                	sw	s1,20(sp)
8004069c:	c84a                	sw	s2,16(sp)
8004069e:	c64e                	sw	s3,12(sp)
800406a0:	c452                	sw	s4,8(sp)
800406a2:	ce06                	sw	ra,28(sp)
800406a4:	89aa                	mv	s3,a0
800406a6:	8a2e                	mv	s4,a1
800406a8:	8932                	mv	s2,a2
800406aa:	80042437          	lui	s0,0x80042
800406ae:	800424b7          	lui	s1,0x80042

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_MUTEX_UNLOCK, k_mutex_unlock, struct k_mutex *, mutex)

K_SYSCALL_DECLARE3_VOID(K_SYSCALL_K_SEM_INIT, k_sem_init, struct k_sem *, sem, unsigned int, initial_count, unsigned int, limit)

K_SYSCALL_DECLARE2(K_SYSCALL_K_SEM_TAKE, k_sem_take, int, struct k_sem *, sem, s32_t, timeout)
800406b2:	55fd                	li	a1,-1
800406b4:	8552                	mv	a0,s4
800406b6:	2b4010ef          	jal	ra,8004196a <z_impl_k_sem_take>
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
800406ba:	24e010ef          	jal	ra,80041908 <z_impl_k_current_get>
	while (1) {
		/* take my semaphore */
		k_sem_take(my_sem, K_FOREVER);

		/* say "hello" */
		tname = k_thread_name_get(k_current_get());
800406be:	316010ef          	jal	ra,800419d4 <k_thread_name_get>
800406c2:	85aa                	mv	a1,a0
		if (tname == NULL) {
			printk("%s: Hello World from %s!\n",
800406c4:	0d840613          	addi	a2,s0,216 # 800420d8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800420d9>
		if (tname == NULL) {
800406c8:	e111                	bnez	a0,800406cc <helloLoop+0x36>
			printk("%s: Hello World from %s!\n",
800406ca:	85ce                	mv	a1,s3
				my_name, CONFIG_BOARD);
		} else {
			printk("%s: Hello World from %s!\n",
800406cc:	0e448513          	addi	a0,s1,228 # 800420e4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800420e5>
800406d0:	7a6000ef          	jal	ra,80040e76 <printk>
K_SYSCALL_DECLARE1(K_SYSCALL_K_SLEEP, k_sleep, s32_t, s32_t, duration)
800406d4:	1f400513          	li	a0,500
800406d8:	19c010ef          	jal	ra,80041874 <z_impl_k_sleep>

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_SEM_GIVE, k_sem_give, struct k_sem *, sem)
800406dc:	854a                	mv	a0,s2
800406de:	234010ef          	jal	ra,80041912 <z_impl_k_sem_give>
800406e2:	bfc1                	j	800406b2 <helloLoop+0x1c>

800406e4 <threadB>:
	ARG_UNUSED(dummy1);
	ARG_UNUSED(dummy2);
	ARG_UNUSED(dummy3);

	/* invoke routine to ping-pong hello messages with threadA */
	helloLoop(__func__, &threadB_sem, &threadA_sem);
800406e4:	80042637          	lui	a2,0x80042
800406e8:	800425b7          	lui	a1,0x80042
800406ec:	80042537          	lui	a0,0x80042
{
800406f0:	1141                	addi	sp,sp,-16
	helloLoop(__func__, &threadB_sem, &threadA_sem);
800406f2:	56c60613          	addi	a2,a2,1388 # 8004256c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004256d>
800406f6:	57c58593          	addi	a1,a1,1404 # 8004257c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004257d>
800406fa:	4ec50513          	addi	a0,a0,1260 # 800424ec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424ed>
{
800406fe:	c606                	sw	ra,12(sp)
	helloLoop(__func__, &threadB_sem, &threadA_sem);
80040700:	3f59                	jal	80040696 <helloLoop>

80040702 <threadA>:
static struct k_thread threadB_data;

/* threadA is a static thread that is spawned automatically */

void threadA(void *dummy1, void *dummy2, void *dummy3)
{
80040702:	1101                	addi	sp,sp,-32
K_SYSCALL_DECLARE10(K_SYSCALL_K_THREAD_CREATE, k_thread_create, k_tid_t, struct k_thread *, new_thread, k_thread_stack_t *, stack, size_t, stack_size, k_thread_entry_t, entry, void *, p1, void *, p2, void *, p3, int, prio, u32_t, options, s32_t, delay)
80040704:	800406b7          	lui	a3,0x80040
80040708:	800425b7          	lui	a1,0x80042
8004070c:	80042537          	lui	a0,0x80042
80040710:	40000613          	li	a2,1024
80040714:	489d                	li	a7,7
80040716:	4801                	li	a6,0
80040718:	4781                	li	a5,0
8004071a:	4701                	li	a4,0
8004071c:	6e468693          	addi	a3,a3,1764 # 800406e4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800406e5>
80040720:	7c058593          	addi	a1,a1,1984 # 800427c0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800427c1>
80040724:	c202                	sw	zero,4(sp)
80040726:	c002                	sw	zero,0(sp)
80040728:	63c50513          	addi	a0,a0,1596 # 8004263c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004263d>
8004072c:	ce06                	sw	ra,28(sp)
8004072e:	31c010ef          	jal	ra,80041a4a <z_impl_k_thread_create>
K_SYSCALL_DECLARE2(K_SYSCALL_K_THREAD_NAME_SET, k_thread_name_set, int, k_tid_t, thread_id, const char *, value)
80040732:	800425b7          	lui	a1,0x80042
80040736:	10c58593          	addi	a1,a1,268 # 8004210c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004210d>
8004073a:	294010ef          	jal	ra,800419ce <z_impl_k_thread_name_set>
			PRIORITY, 0, K_NO_WAIT);

	k_thread_name_set(tid, "thread_b");

	/* invoke routine to ping-pong hello messages with threadB */
	helloLoop(__func__, &threadA_sem, &threadB_sem);
8004073e:	80042637          	lui	a2,0x80042
80040742:	800425b7          	lui	a1,0x80042
80040746:	80042537          	lui	a0,0x80042
8004074a:	57c60613          	addi	a2,a2,1404 # 8004257c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004257d>
8004074e:	56c58593          	addi	a1,a1,1388 # 8004256c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004256d>
80040752:	4f450513          	addi	a0,a0,1268 # 800424f4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424f5>
80040756:	3781                	jal	80040696 <helloLoop>

80040758 <z_SysFatalErrorHandler>:
 *
 * @return N/A
 */
FUNC_NORETURN __weak void z_SysFatalErrorHandler(unsigned int reason,
						const NANO_ESF *esf)
{
80040758:	1141                	addi	sp,sp,-16
8004075a:	c606                	sw	ra,12(sp)
8004075c:	c422                	sw	s0,8(sp)
#ifdef CONFIG_STACK_SENTINEL
	if (reason == _NANO_ERR_STACK_CHK_FAIL) {
		goto hang_system;
	}
#endif
	if (reason == _NANO_ERR_KERNEL_PANIC) {
8004075e:	4799                	li	a5,6
80040760:	02f50163          	beq	a0,a5,80040782 <z_SysFatalErrorHandler+0x2a>
		goto hang_system;
	}
	if (k_is_in_isr() || z_is_thread_essential()) {
80040764:	24c010ef          	jal	ra,800419b0 <k_is_in_isr>
80040768:	cd19                	beqz	a0,80040786 <z_SysFatalErrorHandler+0x2e>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
8004076a:	246010ef          	jal	ra,800419b0 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
8004076e:	ed0d                	bnez	a0,800407a8 <z_SysFatalErrorHandler+0x50>
80040770:	800425b7          	lui	a1,0x80042
80040774:	3c858593          	addi	a1,a1,968 # 800423c8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800423c9>
80040778:	80042537          	lui	a0,0x80042
8004077c:	3dc50513          	addi	a0,a0,988 # 800423dc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800423dd>
80040780:	2ddd                	jal	80040e76 <printk>
#else
	ARG_UNUSED(reason);
#endif

	for (;;) {
		k_cpu_idle();
80040782:	2f11                	jal	80040e96 <k_cpu_idle>
80040784:	bffd                	j	80040782 <z_SysFatalErrorHandler+0x2a>
	if (k_is_in_isr() || z_is_thread_essential()) {
80040786:	238010ef          	jal	ra,800419be <z_is_thread_essential>
8004078a:	f165                	bnez	a0,8004076a <z_SysFatalErrorHandler+0x12>
	printk("Fatal fault in thread %p! Aborting.\n", _current);
8004078c:	80042437          	lui	s0,0x80042
80040790:	78c40413          	addi	s0,s0,1932 # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
80040794:	440c                	lw	a1,8(s0)
80040796:	80042537          	lui	a0,0x80042
8004079a:	3fc50513          	addi	a0,a0,1020 # 800423fc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800423fd>
8004079e:	2de1                	jal	80040e76 <printk>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
800407a0:	4408                	lw	a0,8(s0)
800407a2:	3e4010ef          	jal	ra,80041b86 <z_impl_k_thread_abort>
800407a6:	bff1                	j	80040782 <z_SysFatalErrorHandler+0x2a>
		printk("Fatal fault in %s! Spinning...\n",
800407a8:	800425b7          	lui	a1,0x80042
800407ac:	3c458593          	addi	a1,a1,964 # 800423c4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800423c5>
800407b0:	b7e1                	j	80040778 <z_SysFatalErrorHandler+0x20>

800407b2 <z_NanoFatalErrorHandler>:
{
800407b2:	715d                	addi	sp,sp,-80
800407b4:	c4a2                	sw	s0,72(sp)
800407b6:	c2a6                	sw	s1,68(sp)
800407b8:	c686                	sw	ra,76(sp)
	switch (reason) {
800407ba:	4799                	li	a5,6
{
800407bc:	84aa                	mv	s1,a0
800407be:	842e                	mv	s0,a1
	switch (reason) {
800407c0:	08a7e763          	bltu	a5,a0,8004084e <z_NanoFatalErrorHandler+0x9c>
800407c4:	80042737          	lui	a4,0x80042
800407c8:	00251793          	slli	a5,a0,0x2
800407cc:	11870713          	addi	a4,a4,280 # 80042118 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042119>
800407d0:	97ba                	add	a5,a5,a4
800407d2:	439c                	lw	a5,0(a5)
800407d4:	8782                	jr	a5
		printk("**** Kernel Allocation Failure! ****\n");
800407d6:	80042537          	lui	a0,0x80042
800407da:	24850513          	addi	a0,a0,584 # 80042248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042249>
		printk("***** Kernel OOPS! *****\n");
800407de:	2d61                	jal	80040e76 <printk>
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
800407e0:	128010ef          	jal	ra,80041908 <z_impl_k_current_get>
	printk("Current thread ID = %p\n"
800407e4:	407c                	lw	a5,68(s0)
800407e6:	01042883          	lw	a7,16(s0)
800407ea:	00c42803          	lw	a6,12(s0)
800407ee:	d83e                	sw	a5,48(sp)
800407f0:	403c                	lw	a5,64(s0)
800407f2:	4058                	lw	a4,4(s0)
800407f4:	4014                	lw	a3,0(s0)
800407f6:	d63e                	sw	a5,44(sp)
800407f8:	5c5c                	lw	a5,60(s0)
800407fa:	4430                	lw	a2,72(s0)
800407fc:	85aa                	mv	a1,a0
800407fe:	d43e                	sw	a5,40(sp)
80040800:	5c1c                	lw	a5,56(s0)
80040802:	80042537          	lui	a0,0x80042
80040806:	2cc50513          	addi	a0,a0,716 # 800422cc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422cd>
8004080a:	d23e                	sw	a5,36(sp)
8004080c:	585c                	lw	a5,52(s0)
8004080e:	d03e                	sw	a5,32(sp)
80040810:	581c                	lw	a5,48(s0)
80040812:	ce3e                	sw	a5,28(sp)
80040814:	545c                	lw	a5,44(s0)
80040816:	cc3e                	sw	a5,24(sp)
80040818:	541c                	lw	a5,40(s0)
8004081a:	ca3e                	sw	a5,20(sp)
8004081c:	505c                	lw	a5,36(s0)
8004081e:	c83e                	sw	a5,16(sp)
80040820:	501c                	lw	a5,32(s0)
80040822:	c63e                	sw	a5,12(sp)
80040824:	4c5c                	lw	a5,28(s0)
80040826:	c43e                	sw	a5,8(sp)
80040828:	4c1c                	lw	a5,24(s0)
8004082a:	c23e                	sw	a5,4(sp)
8004082c:	485c                	lw	a5,20(s0)
8004082e:	c03e                	sw	a5,0(sp)
80040830:	441c                	lw	a5,8(s0)
80040832:	2591                	jal	80040e76 <printk>
	z_SysFatalErrorHandler(reason, esf);
80040834:	85a2                	mv	a1,s0
80040836:	8526                	mv	a0,s1
80040838:	3705                	jal	80040758 <z_SysFatalErrorHandler>
		printk("***** Kernel OOPS! *****\n");
8004083a:	80042537          	lui	a0,0x80042
8004083e:	27050513          	addi	a0,a0,624 # 80042270 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042271>
80040842:	bf71                	j	800407de <z_NanoFatalErrorHandler+0x2c>
		printk("***** Kernel Panic! *****\n");
80040844:	80042537          	lui	a0,0x80042
80040848:	28c50513          	addi	a0,a0,652 # 8004228c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004228d>
8004084c:	bf49                	j	800407de <z_NanoFatalErrorHandler+0x2c>
		printk("**** Unknown Fatal Error %d! ****\n", reason);
8004084e:	80042537          	lui	a0,0x80042
80040852:	85a6                	mv	a1,s1
80040854:	2a850513          	addi	a0,a0,680 # 800422a8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422a9>
80040858:	2d39                	jal	80040e76 <printk>
		break;
8004085a:	b759                	j	800407e0 <z_NanoFatalErrorHandler+0x2e>

8004085c <_Fault>:
	}
}


FUNC_NORETURN void _Fault(const NANO_ESF *esf)
{
8004085c:	1141                	addi	sp,sp,-16
8004085e:	c422                	sw	s0,8(sp)
80040860:	c606                	sw	ra,12(sp)
80040862:	842a                	mv	s0,a0
	u32_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
80040864:	34202673          	csrr	a2,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;
80040868:	0606                	slli	a2,a2,0x1
8004086a:	8205                	srli	a2,a2,0x1
	switch (cause) {
8004086c:	4795                	li	a5,5
8004086e:	02c7e263          	bltu	a5,a2,80040892 <_Fault+0x36>
80040872:	80042737          	lui	a4,0x80042
80040876:	00261793          	slli	a5,a2,0x2
8004087a:	13470713          	addi	a4,a4,308 # 80042134 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042135>
8004087e:	97ba                	add	a5,a5,a4
80040880:	438c                	lw	a1,0(a5)
	printk("Exception cause %s (%d)\n", cause_str(mcause), (int)mcause);
80040882:	80042537          	lui	a0,0x80042
80040886:	15450513          	addi	a0,a0,340 # 80042154 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042155>
8004088a:	23f5                	jal	80040e76 <printk>

	z_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, esf);
8004088c:	85a2                	mv	a1,s0
8004088e:	4501                	li	a0,0
80040890:	370d                	jal	800407b2 <z_NanoFatalErrorHandler>
	mcause &= SOC_MCAUSE_EXP_MASK;
80040892:	800425b7          	lui	a1,0x80042
80040896:	14c58593          	addi	a1,a1,332 # 8004214c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004214d>
8004089a:	b7e5                	j	80040882 <_Fault+0x26>

8004089c <z_irq_spurious>:
#include <toolchain.h>
#include <kernel_structs.h>
#include <misc/printk.h>

void z_irq_spurious(void *unused)
{
8004089c:	1141                	addi	sp,sp,-16
8004089e:	c606                	sw	ra,12(sp)
	u32_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
800408a0:	342025f3          	csrr	a1,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;

	printk("Spurious interrupt detected! IRQ: %d\n", (int)mcause);
800408a4:	80042537          	lui	a0,0x80042
	mcause &= SOC_MCAUSE_EXP_MASK;
800408a8:	0586                	slli	a1,a1,0x1
	printk("Spurious interrupt detected! IRQ: %d\n", (int)mcause);
800408aa:	8185                	srli	a1,a1,0x1
800408ac:	42450513          	addi	a0,a0,1060 # 80042424 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042425>
800408b0:	23d9                	jal	80040e76 <printk>
		printk("PLIC interrupt line causing the IRQ: %d\n",
		       riscv_plic_get_irq());
	}
#endif

	z_NanoFatalErrorHandler(_NANO_ERR_SPURIOUS_INT, &_default_esf);
800408b2:	800425b7          	lui	a1,0x80042
800408b6:	17058593          	addi	a1,a1,368 # 80042170 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042171>
800408ba:	4511                	li	a0,4
800408bc:	3ddd                	jal	800407b2 <z_NanoFatalErrorHandler>

800408be <z_irq_do_offload>:
 */
void z_irq_do_offload(void)
{
	irq_offload_routine_t tmp;

	if (!_offload_routine)
800408be:	800427b7          	lui	a5,0x80042
800408c2:	5b078793          	addi	a5,a5,1456 # 800425b0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425b1>
800408c6:	4398                	lw	a4,0(a5)
800408c8:	cb11                	beqz	a4,800408dc <z_irq_do_offload+0x1e>
		return;

	tmp = _offload_routine;
800408ca:	0007a303          	lw	t1,0(a5)
	_offload_routine = NULL;
800408ce:	0007a023          	sw	zero,0(a5)

	tmp((void *)offload_param);
800408d2:	800427b7          	lui	a5,0x80042
800408d6:	5b47a503          	lw	a0,1460(a5) # 800425b4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425b5>
800408da:	8302                	jr	t1
}
800408dc:	8082                	ret

800408de <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
800408de:	1141                	addi	sp,sp,-16
800408e0:	c606                	sw	ra,12(sp)
	z_bss_zero();
800408e2:	117000ef          	jal	ra,800411f8 <z_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
800408e6:	23e1                	jal	80040eae <soc_interrupt_init>
#endif
	z_cstart();
800408e8:	165000ef          	jal	ra,8004124c <z_cstart>

800408ec <z_new_thread>:

void z_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		 size_t stack_size, k_thread_entry_t thread_func,
		 void *arg1, void *arg2, void *arg3,
		 int priority, unsigned int options)
{
800408ec:	7179                	addi	sp,sp,-48
800408ee:	ce4e                	sw	s3,28(sp)
800408f0:	89b6                	mv	s3,a3
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
800408f2:	56c2                	lw	a3,48(sp)
800408f4:	d422                	sw	s0,40(sp)
800408f6:	d04a                	sw	s2,32(sp)
800408f8:	842e                	mv	s0,a1
800408fa:	8932                	mv	s2,a2
800408fc:	85c6                	mv	a1,a7
800408fe:	4611                	li	a2,4
80040900:	d226                	sw	s1,36(sp)
80040902:	d606                	sw	ra,44(sp)
80040904:	84aa                	mv	s1,a0
80040906:	c63a                	sw	a4,12(sp)
80040908:	c43e                	sw	a5,8(sp)
8004090a:	c242                	sw	a6,4(sp)
8004090c:	260010ef          	jal	ra,80041b6c <z_init_thread_base>
				 stack_size - sizeof(struct __esf));

	/* Setup the initial stack frame */
	stack_init->a0 = (u32_t)thread_func;
	stack_init->a1 = (u32_t)arg1;
	stack_init->a2 = (u32_t)arg2;
80040910:	47a2                	lw	a5,8(sp)
		STACK_ROUND_DOWN(stack_memory +
80040912:	fb090593          	addi	a1,s2,-80
80040916:	95a2                	add	a1,a1,s0

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
80040918:	0404ae23          	sw	zero,92(s1)
	thread->fn_abort = NULL;
8004091c:	0604a023          	sw	zero,96(s1)
80040920:	99c1                	andi	a1,a1,-16
	stack_init->a2 = (u32_t)arg2;
80040922:	d99c                	sw	a5,48(a1)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
80040924:	6789                	lui	a5,0x2
	stack_init->a1 = (u32_t)arg1;
80040926:	4732                	lw	a4,12(sp)
	stack_init->a3 = (u32_t)arg3;
80040928:	4812                	lw	a6,4(sp)
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
8004092a:	88078793          	addi	a5,a5,-1920 # 1880 <CONFIG_ISR_STACK_SIZE+0x1080>
8004092e:	c5fc                	sw	a5,76(a1)
	stack_init->mepc = (u32_t)z_thread_entry_wrapper;
80040930:	800407b7          	lui	a5,0x80040

	thread->callee_saved.sp = (u32_t)stack_init;
}
80040934:	50b2                	lw	ra,44(sp)
80040936:	5422                	lw	s0,40(sp)
	stack_init->mepc = (u32_t)z_thread_entry_wrapper;
80040938:	69078793          	addi	a5,a5,1680 # 80040690 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80040691>
	stack_init->a0 = (u32_t)thread_func;
8004093c:	0335a423          	sw	s3,40(a1)
	stack_init->a1 = (u32_t)arg1;
80040940:	d5d8                	sw	a4,44(a1)
	stack_init->a3 = (u32_t)arg3;
80040942:	0305aa23          	sw	a6,52(a1)
	stack_init->mepc = (u32_t)z_thread_entry_wrapper;
80040946:	c5bc                	sw	a5,72(a1)
	thread->callee_saved.sp = (u32_t)stack_init;
80040948:	d48c                	sw	a1,40(s1)
}
8004094a:	5902                	lw	s2,32(sp)
8004094c:	5492                	lw	s1,36(sp)
8004094e:	49f2                	lw	s3,28(sp)
80040950:	6145                	addi	sp,sp,48
80040952:	8082                	ret

80040954 <get_bit_ptr>:
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
	u32_t *bitarray = level <= p->max_inline_level ?
80040954:	47b1                	li	a5,12
80040956:	02f58733          	mul	a4,a1,a5
8004095a:	455c                	lw	a5,12(a0)
8004095c:	97ba                	add	a5,a5,a4
8004095e:	00b50703          	lb	a4,11(a0)
		&p->levels[level].bits : p->levels[level].bits_p;
80040962:	00b75363          	bge	a4,a1,80040968 <get_bit_ptr+0x14>
80040966:	439c                	lw	a5,0(a5)

	*word = &bitarray[bn / 32];
80040968:	02000713          	li	a4,32
8004096c:	02e64733          	div	a4,a2,a4

	return bn & 0x1f;
}
80040970:	01f67513          	andi	a0,a2,31
	*word = &bitarray[bn / 32];
80040974:	070a                	slli	a4,a4,0x2
80040976:	97ba                	add	a5,a5,a4
80040978:	c29c                	sw	a5,0(a3)
}
8004097a:	8082                	ret

8004097c <set_free_bit>:

static void set_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
8004097c:	1101                	addi	sp,sp,-32
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
8004097e:	0074                	addi	a3,sp,12
{
80040980:	ce06                	sw	ra,28(sp)
	int bit = get_bit_ptr(p, level, bn, &word);
80040982:	3fc9                	jal	80040954 <get_bit_ptr>

	*word |= (1<<bit);
80040984:	4732                	lw	a4,12(sp)
80040986:	4785                	li	a5,1
80040988:	00a79533          	sll	a0,a5,a0
8004098c:	431c                	lw	a5,0(a4)
}
8004098e:	40f2                	lw	ra,28(sp)
	*word |= (1<<bit);
80040990:	8fc9                	or	a5,a5,a0
80040992:	c31c                	sw	a5,0(a4)
}
80040994:	6105                	addi	sp,sp,32
80040996:	8082                	ret

80040998 <z_sys_mem_pool_base_init>:
}

void z_sys_mem_pool_base_init(struct sys_mem_pool_base *p)
{
	int i;
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
80040998:	415c                	lw	a5,4(a0)
8004099a:	00855803          	lhu	a6,8(a0)
{
8004099e:	1141                	addi	sp,sp,-16
800409a0:	c422                	sw	s0,8(sp)
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
800409a2:	02f80833          	mul	a6,a6,a5
{
800409a6:	842a                	mv	s0,a0
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
800409a8:	4108                	lw	a0,0(a0)

	p->max_inline_level = -1;

	for (i = 0; i < p->n_levels; i++) {
800409aa:	00a44883          	lbu	a7,10(s0)
	p->max_inline_level = -1;
800409ae:	577d                	li	a4,-1
{
800409b0:	c606                	sw	ra,12(sp)
800409b2:	c226                	sw	s1,4(sp)
	p->max_inline_level = -1;
800409b4:	00e405a3          	sb	a4,11(s0)
	for (i = 0; i < p->n_levels; i++) {
800409b8:	4581                	li	a1,0
		int nblocks = buflen / sz;

		sys_dlist_init(&p->levels[i].free_list);
800409ba:	4331                	li	t1,12
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
800409bc:	9542                	add	a0,a0,a6

		if (nblocks < 32) {
800409be:	4e7d                	li	t3,31
			p->max_inline_level = i;
		} else {
			p->levels[i].bits_p = bits;
			bits += (nblocks + 31)/32;
800409c0:	02000e93          	li	t4,32
	for (i = 0; i < p->n_levels; i++) {
800409c4:	0115cc63          	blt	a1,a7,800409dc <z_sys_mem_pool_base_init+0x44>
		}

		sz = _ALIGN4(sz / 4);
	}

	for (i = 0; i < p->n_max; i++) {
800409c8:	4481                	li	s1,0
800409ca:	00845783          	lhu	a5,8(s0)
800409ce:	04f4c163          	blt	s1,a5,80040a10 <z_sys_mem_pool_base_init+0x78>
		void *block = block_ptr(p, p->max_sz, i);

		sys_dlist_append(&p->levels[0].free_list, block);
		set_free_bit(p, 0, i);
	}
}
800409d2:	40b2                	lw	ra,12(sp)
800409d4:	4422                	lw	s0,8(sp)
800409d6:	4492                	lw	s1,4(sp)
800409d8:	0141                	addi	sp,sp,16
800409da:	8082                	ret
		int nblocks = buflen / sz;
800409dc:	02f85733          	divu	a4,a6,a5
		sys_dlist_init(&p->levels[i].free_list);
800409e0:	4450                	lw	a2,12(s0)
800409e2:	026586b3          	mul	a3,a1,t1
800409e6:	96b2                	add	a3,a3,a2
800409e8:	00468613          	addi	a2,a3,4
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
800409ec:	c2d0                	sw	a2,4(a3)
	list->tail = (sys_dnode_t *)list;
800409ee:	c690                	sw	a2,8(a3)
		if (nblocks < 32) {
800409f0:	00ee4963          	blt	t3,a4,80040a02 <z_sys_mem_pool_base_init+0x6a>
			p->max_inline_level = i;
800409f4:	00b405a3          	sb	a1,11(s0)
		sz = _ALIGN4(sz / 4);
800409f8:	8389                	srli	a5,a5,0x2
800409fa:	078d                	addi	a5,a5,3
800409fc:	9bf1                	andi	a5,a5,-4
	for (i = 0; i < p->n_levels; i++) {
800409fe:	0585                	addi	a1,a1,1
80040a00:	b7d1                	j	800409c4 <z_sys_mem_pool_base_init+0x2c>
			bits += (nblocks + 31)/32;
80040a02:	077d                	addi	a4,a4,31
80040a04:	03d74733          	div	a4,a4,t4
			p->levels[i].bits_p = bits;
80040a08:	c288                	sw	a0,0(a3)
			bits += (nblocks + 31)/32;
80040a0a:	070a                	slli	a4,a4,0x2
80040a0c:	953a                	add	a0,a0,a4
80040a0e:	b7ed                	j	800409f8 <z_sys_mem_pool_base_init+0x60>
	return (u8_t *)p->buf + lsz * block;
80040a10:	405c                	lw	a5,4(s0)
		set_free_bit(p, 0, i);
80040a12:	8626                	mv	a2,s1
80040a14:	4581                	li	a1,0
	return (u8_t *)p->buf + lsz * block;
80040a16:	02f48733          	mul	a4,s1,a5
80040a1a:	401c                	lw	a5,0(s0)
		set_free_bit(p, 0, i);
80040a1c:	8522                	mv	a0,s0
	for (i = 0; i < p->n_max; i++) {
80040a1e:	0485                	addi	s1,s1,1
	return (u8_t *)p->buf + lsz * block;
80040a20:	97ba                	add	a5,a5,a4
		sys_dlist_append(&p->levels[0].free_list, block);
80040a22:	4458                	lw	a4,12(s0)
80040a24:	00470693          	addi	a3,a4,4
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
80040a28:	c394                	sw	a3,0(a5)
	node->prev = list->tail;
80040a2a:	4714                	lw	a3,8(a4)
80040a2c:	c3d4                	sw	a3,4(a5)

	list->tail->next = node;
80040a2e:	4714                	lw	a3,8(a4)
80040a30:	c29c                	sw	a5,0(a3)
	list->tail = node;
80040a32:	c71c                	sw	a5,8(a4)
		set_free_bit(p, 0, i);
80040a34:	37a1                	jal	8004097c <set_free_bit>
80040a36:	bf51                	j	800409ca <z_sys_mem_pool_base_init+0x32>

80040a38 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
80040a38:	1141                	addi	sp,sp,-16
80040a3a:	87aa                	mv	a5,a0
80040a3c:	852e                	mv	a0,a1
80040a3e:	85b2                	mv	a1,a2
	entry(p1, p2, p3);
80040a40:	8636                	mv	a2,a3
{
80040a42:	c606                	sw	ra,12(sp)
	entry(p1, p2, p3);
80040a44:	9782                	jalr	a5
80040a46:	6c3000ef          	jal	ra,80041908 <z_impl_k_current_get>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
80040a4a:	13c010ef          	jal	ra,80041b86 <z_impl_k_thread_abort>

80040a4e <z_arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
80040a4e:	4501                	li	a0,0
80040a50:	8082                	ret

80040a52 <print_err>:
{
	return _char_out;
}

static void print_err(out_func_t out, void *ctx)
{
80040a52:	1141                	addi	sp,sp,-16
80040a54:	c422                	sw	s0,8(sp)
80040a56:	842a                	mv	s0,a0
	out('E', ctx);
80040a58:	04500513          	li	a0,69
{
80040a5c:	c606                	sw	ra,12(sp)
80040a5e:	c226                	sw	s1,4(sp)
80040a60:	84ae                	mv	s1,a1
	out('E', ctx);
80040a62:	9402                	jalr	s0
	out('R', ctx);
80040a64:	85a6                	mv	a1,s1
80040a66:	05200513          	li	a0,82
80040a6a:	9402                	jalr	s0
	out('R', ctx);
80040a6c:	8322                	mv	t1,s0
}
80040a6e:	4422                	lw	s0,8(sp)
80040a70:	40b2                	lw	ra,12(sp)
	out('R', ctx);
80040a72:	85a6                	mv	a1,s1
}
80040a74:	4492                	lw	s1,4(sp)
	out('R', ctx);
80040a76:	05200513          	li	a0,82
}
80040a7a:	0141                	addi	sp,sp,16
	out('R', ctx);
80040a7c:	8302                	jr	t1

80040a7e <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
80040a7e:	419c                	lw	a5,0(a1)
80040a80:	0785                	addi	a5,a5,1
80040a82:	c19c                	sw	a5,0(a1)
	return _char_out(c);
80040a84:	800427b7          	lui	a5,0x80042
80040a88:	4dc7a303          	lw	t1,1244(a5) # 800424dc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424dd>
80040a8c:	8302                	jr	t1

80040a8e <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
80040a8e:	715d                	addi	sp,sp,-80
80040a90:	c4a2                	sw	s0,72(sp)
80040a92:	de4e                	sw	s3,60(sp)
80040a94:	dc52                	sw	s4,56(sp)
80040a96:	da56                	sw	s5,52(sp)
80040a98:	d85a                	sw	s6,48(sp)
80040a9a:	c686                	sw	ra,76(sp)
80040a9c:	c2a6                	sw	s1,68(sp)
80040a9e:	c0ca                	sw	s2,64(sp)
80040aa0:	d65e                	sw	s7,44(sp)
80040aa2:	d462                	sw	s8,40(sp)
80040aa4:	d266                	sw	s9,36(sp)
80040aa6:	d06a                	sw	s10,32(sp)
80040aa8:	ce6e                	sw	s11,28(sp)
80040aaa:	8a2a                	mv	s4,a0
80040aac:	8aae                	mv	s5,a1
80040aae:	89b2                	mv	s3,a2
80040ab0:	8b36                	mv	s6,a3
80040ab2:	4405                	li	s0,1
80040ab4:	00e05363          	blez	a4,80040aba <_printk_dec_ulong+0x2c>
80040ab8:	843a                	mv	s0,a4
80040aba:	4785                	li	a5,1
80040abc:	02000c13          	li	s8,32
80040ac0:	00fb1463          	bne	s6,a5,80040ac8 <_printk_dec_ulong+0x3a>
80040ac4:	03000c13          	li	s8,48
80040ac8:	3b9ad4b7          	lui	s1,0x3b9ad
80040acc:	4905                	li	s2,1
80040ace:	4ca9                	li	s9,10
80040ad0:	4701                	li	a4,0
80040ad2:	9ff48493          	addi	s1,s1,-1537 # 3b9ac9ff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3b8b87bf>
		if (found_largest_digit != 0 || remainder > pos) {
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
			digits++;
		} else if (remaining <= min_width
				&& padding < PAD_SPACE_AFTER) {
80040ad6:	4d89                	li	s11,2
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= (pos + 1);
		pos /= 10;
80040ad8:	4d29                	li	s10,10
		if (found_largest_digit != 0 || remainder > pos) {
80040ada:	00148b93          	addi	s7,s1,1
80040ade:	e319                	bnez	a4,80040ae4 <_printk_dec_ulong+0x56>
80040ae0:	0534fa63          	bgeu	s1,s3,80040b34 <_printk_dec_ulong+0xa6>
			out((int)((remainder / (pos + 1)) + 48), ctx);
80040ae4:	0379d533          	divu	a0,s3,s7
80040ae8:	85d6                	mv	a1,s5
			digits++;
80040aea:	0905                	addi	s2,s2,1
			out((int)((remainder / (pos + 1)) + 48), ctx);
80040aec:	03050513          	addi	a0,a0,48
80040af0:	9a02                	jalr	s4
			found_largest_digit = 1;
80040af2:	4705                	li	a4,1
		remaining--;
80040af4:	1cfd                	addi	s9,s9,-1
	while (pos >= 9) {
80040af6:	4785                	li	a5,1
		remainder %= (pos + 1);
80040af8:	0379f9b3          	remu	s3,s3,s7
		pos /= 10;
80040afc:	03a4d4b3          	divu	s1,s1,s10
	while (pos >= 9) {
80040b00:	fcfc9de3          	bne	s9,a5,80040ada <_printk_dec_ulong+0x4c>
	}
	out((int)(remainder + 48), ctx);
80040b04:	85d6                	mv	a1,s5
80040b06:	03098513          	addi	a0,s3,48
80040b0a:	9a02                	jalr	s4

	if (padding == PAD_SPACE_AFTER) {
80040b0c:	478d                	li	a5,3
		remaining = min_width - digits;
80040b0e:	41240433          	sub	s0,s0,s2
	if (padding == PAD_SPACE_AFTER) {
80040b12:	04fb0163          	beq	s6,a5,80040b54 <_printk_dec_ulong+0xc6>
		while (remaining-- > 0) {
			out(' ', ctx);
		}
	}
}
80040b16:	40b6                	lw	ra,76(sp)
80040b18:	4426                	lw	s0,72(sp)
80040b1a:	4496                	lw	s1,68(sp)
80040b1c:	4906                	lw	s2,64(sp)
80040b1e:	59f2                	lw	s3,60(sp)
80040b20:	5a62                	lw	s4,56(sp)
80040b22:	5ad2                	lw	s5,52(sp)
80040b24:	5b42                	lw	s6,48(sp)
80040b26:	5bb2                	lw	s7,44(sp)
80040b28:	5c22                	lw	s8,40(sp)
80040b2a:	5c92                	lw	s9,36(sp)
80040b2c:	5d02                	lw	s10,32(sp)
80040b2e:	4df2                	lw	s11,28(sp)
80040b30:	6161                	addi	sp,sp,80
80040b32:	8082                	ret
		} else if (remaining <= min_width
80040b34:	fd9440e3          	blt	s0,s9,80040af4 <_printk_dec_ulong+0x66>
				&& padding < PAD_SPACE_AFTER) {
80040b38:	fb6deee3          	bltu	s11,s6,80040af4 <_printk_dec_ulong+0x66>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
80040b3c:	85d6                	mv	a1,s5
80040b3e:	8562                	mv	a0,s8
80040b40:	c63a                	sw	a4,12(sp)
80040b42:	9a02                	jalr	s4
			digits++;
80040b44:	0905                	addi	s2,s2,1
80040b46:	4732                	lw	a4,12(sp)
80040b48:	b775                	j	80040af4 <_printk_dec_ulong+0x66>
			out(' ', ctx);
80040b4a:	85d6                	mv	a1,s5
80040b4c:	02000513          	li	a0,32
80040b50:	9a02                	jalr	s4
80040b52:	147d                	addi	s0,s0,-1
		while (remaining-- > 0) {
80040b54:	fe804be3          	bgtz	s0,80040b4a <_printk_dec_ulong+0xbc>
80040b58:	bf7d                	j	80040b16 <_printk_dec_ulong+0x88>

80040b5a <__printk_hook_install>:
	_char_out = fn;
80040b5a:	800427b7          	lui	a5,0x80042
80040b5e:	4ca7ae23          	sw	a0,1244(a5) # 800424dc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424dd>
}
80040b62:	8082                	ret

80040b64 <z_vprintk>:
{
80040b64:	715d                	addi	sp,sp,-80
80040b66:	c4a2                	sw	s0,72(sp)
80040b68:	c2a6                	sw	s1,68(sp)
80040b6a:	c0ca                	sw	s2,64(sp)
80040b6c:	de4e                	sw	s3,60(sp)
80040b6e:	dc52                	sw	s4,56(sp)
80040b70:	da56                	sw	s5,52(sp)
80040b72:	d266                	sw	s9,36(sp)
80040b74:	d06a                	sw	s10,32(sp)
80040b76:	ce6e                	sw	s11,28(sp)
80040b78:	c686                	sw	ra,76(sp)
80040b7a:	d85a                	sw	s6,48(sp)
80040b7c:	d65e                	sw	s7,44(sp)
80040b7e:	d462                	sw	s8,40(sp)
80040b80:	842a                	mv	s0,a0
80040b82:	84ae                	mv	s1,a1
80040b84:	8ab2                	mv	s5,a2
80040b86:	8d36                	mv	s10,a3
	int long_ctr = 0;
80040b88:	4a01                	li	s4,0
	int min_width = -1;
80040b8a:	597d                	li	s2,-1
	enum pad_type padding = PAD_NONE;
80040b8c:	4981                	li	s3,0
	int might_format = 0; /* 1 if encountered a '%' */
80040b8e:	4c81                	li	s9,0
					if (lld > INT32_MAX ||
80040b90:	80000db7          	lui	s11,0x80000
	while (*fmt) {
80040b94:	000ac503          	lbu	a0,0(s5)
80040b98:	e105                	bnez	a0,80040bb8 <z_vprintk+0x54>
}
80040b9a:	40b6                	lw	ra,76(sp)
80040b9c:	4426                	lw	s0,72(sp)
80040b9e:	4496                	lw	s1,68(sp)
80040ba0:	4906                	lw	s2,64(sp)
80040ba2:	59f2                	lw	s3,60(sp)
80040ba4:	5a62                	lw	s4,56(sp)
80040ba6:	5ad2                	lw	s5,52(sp)
80040ba8:	5b42                	lw	s6,48(sp)
80040baa:	5bb2                	lw	s7,44(sp)
80040bac:	5c22                	lw	s8,40(sp)
80040bae:	5c92                	lw	s9,36(sp)
80040bb0:	5d02                	lw	s10,32(sp)
80040bb2:	4df2                	lw	s11,28(sp)
80040bb4:	6161                	addi	sp,sp,80
80040bb6:	8082                	ret
		if (!might_format) {
80040bb8:	000c9a63          	bnez	s9,80040bcc <z_vprintk+0x68>
			if (*fmt != '%') {
80040bbc:	02500693          	li	a3,37
80040bc0:	28d50463          	beq	a0,a3,80040e48 <z_vprintk+0x2e4>
				out((int)*fmt, ctx);
80040bc4:	85a6                	mv	a1,s1
80040bc6:	9402                	jalr	s0
		++fmt;
80040bc8:	0a85                	addi	s5,s5,1
80040bca:	b7e9                	j	80040b94 <z_vprintk+0x30>
			switch (*fmt) {
80040bcc:	06400693          	li	a3,100
80040bd0:	0ed50a63          	beq	a0,a3,80040cc4 <z_vprintk+0x160>
80040bd4:	04a6eb63          	bltu	a3,a0,80040c2a <z_vprintk+0xc6>
80040bd8:	03900693          	li	a3,57
80040bdc:	02a6e763          	bltu	a3,a0,80040c0a <z_vprintk+0xa6>
80040be0:	03100693          	li	a3,49
80040be4:	0cd57563          	bgeu	a0,a3,80040cae <z_vprintk+0x14a>
80040be8:	02d00693          	li	a3,45
80040bec:	26d50363          	beq	a0,a3,80040e52 <z_vprintk+0x2ee>
80040bf0:	03000793          	li	a5,48
80040bf4:	0af50363          	beq	a0,a5,80040c9a <z_vprintk+0x136>
80040bf8:	02500713          	li	a4,37
80040bfc:	00e51f63          	bne	a0,a4,80040c1a <z_vprintk+0xb6>
				out((int)'%', ctx);
80040c00:	85a6                	mv	a1,s1
80040c02:	02500513          	li	a0,37
				out((int)*fmt, ctx);
80040c06:	9402                	jalr	s0
				break;
80040c08:	aa01                	j	80040d18 <z_vprintk+0x1b4>
			switch (*fmt) {
80040c0a:	05800693          	li	a3,88
80040c0e:	14d50a63          	beq	a0,a3,80040d62 <z_vprintk+0x1fe>
80040c12:	06300713          	li	a4,99
80040c16:	22e50263          	beq	a0,a4,80040e3a <z_vprintk+0x2d6>
				out((int)'%', ctx);
80040c1a:	85a6                	mv	a1,s1
80040c1c:	02500513          	li	a0,37
80040c20:	9402                	jalr	s0
				out((int)*fmt, ctx);
80040c22:	85a6                	mv	a1,s1
80040c24:	000ac503          	lbu	a0,0(s5)
80040c28:	bff9                	j	80040c06 <z_vprintk+0xa2>
			switch (*fmt) {
80040c2a:	07000693          	li	a3,112
80040c2e:	12d50063          	beq	a0,a3,80040d4e <z_vprintk+0x1ea>
80040c32:	00a6ef63          	bltu	a3,a0,80040c50 <z_vprintk+0xec>
80040c36:	06900693          	li	a3,105
80040c3a:	08d50563          	beq	a0,a3,80040cc4 <z_vprintk+0x160>
80040c3e:	06c00693          	li	a3,108
80040c42:	06d50f63          	beq	a0,a3,80040cc0 <z_vprintk+0x15c>
80040c46:	06800693          	li	a3,104
80040c4a:	f6d50fe3          	beq	a0,a3,80040bc8 <z_vprintk+0x64>
80040c4e:	b7f1                	j	80040c1a <z_vprintk+0xb6>
80040c50:	07500693          	li	a3,117
80040c54:	0cd50463          	beq	a0,a3,80040d1c <z_vprintk+0x1b8>
80040c58:	02a6ea63          	bltu	a3,a0,80040c8c <z_vprintk+0x128>
80040c5c:	07300713          	li	a4,115
80040c60:	fae51de3          	bne	a0,a4,80040c1a <z_vprintk+0xb6>
				char *s = va_arg(ap, char *);
80040c64:	000d2c03          	lw	s8,0(s10)
80040c68:	004d0b13          	addi	s6,s10,4
80040c6c:	8be2                	mv	s7,s8
				while (*s)
80040c6e:	000bc503          	lbu	a0,0(s7)
80040c72:	1a051a63          	bnez	a0,80040e26 <z_vprintk+0x2c2>
				if (padding == PAD_SPACE_AFTER) {
80040c76:	478d                	li	a5,3
80040c78:	00f99863          	bne	s3,a5,80040c88 <z_vprintk+0x124>
					int remaining = min_width - (s - start);
80040c7c:	418b8bb3          	sub	s7,s7,s8
80040c80:	41790bb3          	sub	s7,s2,s7
					while (remaining-- > 0) {
80040c84:	1b704563          	bgtz	s7,80040e2e <z_vprintk+0x2ca>
				char *s = va_arg(ap, char *);
80040c88:	8d5a                	mv	s10,s6
80040c8a:	a079                	j	80040d18 <z_vprintk+0x1b4>
			switch (*fmt) {
80040c8c:	07800693          	li	a3,120
80040c90:	0cd50963          	beq	a0,a3,80040d62 <z_vprintk+0x1fe>
80040c94:	07a00693          	li	a3,122
80040c98:	bf4d                	j	80040c4a <z_vprintk+0xe6>
				if (min_width < 0 && padding == PAD_NONE) {
80040c9a:	00095c63          	bgez	s2,80040cb2 <z_vprintk+0x14e>
80040c9e:	1a098c63          	beqz	s3,80040e56 <z_vprintk+0x2f2>
					min_width = *fmt - '0';
80040ca2:	fd050913          	addi	s2,a0,-48
				if (padding == PAD_NONE) {
80040ca6:	f20991e3          	bnez	s3,80040bc8 <z_vprintk+0x64>
					padding = PAD_SPACE_BEFORE;
80040caa:	4989                	li	s3,2
80040cac:	bf31                	j	80040bc8 <z_vprintk+0x64>
				if (min_width < 0) {
80040cae:	fe094ae3          	bltz	s2,80040ca2 <z_vprintk+0x13e>
					min_width = 10 * min_width + *fmt - '0';
80040cb2:	46a9                	li	a3,10
80040cb4:	02d90933          	mul	s2,s2,a3
80040cb8:	fd090913          	addi	s2,s2,-48
80040cbc:	992a                	add	s2,s2,a0
80040cbe:	b7e5                	j	80040ca6 <z_vprintk+0x142>
				long_ctr++;
80040cc0:	0a05                	addi	s4,s4,1
80040cc2:	b719                	j	80040bc8 <z_vprintk+0x64>
				if (long_ctr == 0) {
80040cc4:	020a1663          	bnez	s4,80040cf0 <z_vprintk+0x18c>
					long ld = va_arg(ap, long);
80040cc8:	000d2603          	lw	a2,0(s10)
80040ccc:	0d11                	addi	s10,s10,4
				if (d < 0) {
80040cce:	00065b63          	bgez	a2,80040ce4 <z_vprintk+0x180>
					out((int)'-', ctx);
80040cd2:	85a6                	mv	a1,s1
80040cd4:	02d00513          	li	a0,45
80040cd8:	c032                	sw	a2,0(sp)
80040cda:	9402                	jalr	s0
					d = -d;
80040cdc:	4602                	lw	a2,0(sp)
					min_width--;
80040cde:	197d                	addi	s2,s2,-1
					d = -d;
80040ce0:	40c00633          	neg	a2,a2
				_printk_dec_ulong(out, ctx, u, padding,
80040ce4:	874a                	mv	a4,s2
80040ce6:	86ce                	mv	a3,s3
80040ce8:	85a6                	mv	a1,s1
80040cea:	8522                	mv	a0,s0
80040cec:	334d                	jal	80040a8e <_printk_dec_ulong>
				break;
80040cee:	a02d                	j	80040d18 <z_vprintk+0x1b4>
				} else if (long_ctr == 1) {
80040cf0:	4705                	li	a4,1
80040cf2:	fcea0be3          	beq	s4,a4,80040cc8 <z_vprintk+0x164>
					long long lld = va_arg(ap, long long);
80040cf6:	007d0793          	addi	a5,s10,7
80040cfa:	ff87f713          	andi	a4,a5,-8
80040cfe:	4310                	lw	a2,0(a4)
80040d00:	4354                	lw	a3,4(a4)
80040d02:	00870d13          	addi	s10,a4,8
					if (lld > INT32_MAX ||
80040d06:	01b60733          	add	a4,a2,s11
80040d0a:	00c73733          	sltu	a4,a4,a2
80040d0e:	9736                	add	a4,a4,a3
80040d10:	df5d                	beqz	a4,80040cce <z_vprintk+0x16a>
						print_err(out, ctx);
80040d12:	85a6                	mv	a1,s1
80040d14:	8522                	mv	a0,s0
80040d16:	3b35                	jal	80040a52 <print_err>
			might_format = 0;
80040d18:	4c81                	li	s9,0
80040d1a:	b57d                	j	80040bc8 <z_vprintk+0x64>
				if (long_ctr == 0) {
80040d1c:	000a1663          	bnez	s4,80040d28 <z_vprintk+0x1c4>
					long lu = va_arg(ap, unsigned long);
80040d20:	000d2603          	lw	a2,0(s10)
80040d24:	0d11                	addi	s10,s10,4
80040d26:	bf7d                	j	80040ce4 <z_vprintk+0x180>
				} else if (long_ctr == 1) {
80040d28:	4705                	li	a4,1
80040d2a:	feea0be3          	beq	s4,a4,80040d20 <z_vprintk+0x1bc>
					unsigned long long llu =
80040d2e:	007d0793          	addi	a5,s10,7
80040d32:	ff87f713          	andi	a4,a5,-8
80040d36:	00870d13          	addi	s10,a4,8
80040d3a:	4310                	lw	a2,0(a4)
80040d3c:	4358                	lw	a4,4(a4)
					if (llu > INT32_MAX) {
80040d3e:	fb71                	bnez	a4,80040d12 <z_vprintk+0x1ae>
80040d40:	800007b7          	lui	a5,0x80000
80040d44:	fff7c793          	not	a5,a5
80040d48:	f8c7fee3          	bgeu	a5,a2,80040ce4 <z_vprintk+0x180>
80040d4c:	b7d9                	j	80040d12 <z_vprintk+0x1ae>
				  out('0', ctx);
80040d4e:	85a6                	mv	a1,s1
80040d50:	03000513          	li	a0,48
80040d54:	9402                	jalr	s0
				  out('x', ctx);
80040d56:	85a6                	mv	a1,s1
80040d58:	07800513          	li	a0,120
80040d5c:	9402                	jalr	s0
				  min_width = 8;
80040d5e:	4921                	li	s2,8
				  padding = PAD_ZERO_BEFORE;
80040d60:	4985                	li	s3,1
				if (long_ctr < 2) {
80040d62:	4685                	li	a3,1
80040d64:	0746c663          	blt	a3,s4,80040dd0 <z_vprintk+0x26c>
					x = va_arg(ap, unsigned long);
80040d68:	000d2783          	lw	a5,0(s10)
80040d6c:	c402                	sw	zero,8(sp)
80040d6e:	0d11                	addi	s10,s10,4
80040d70:	c23e                	sw	a5,4(sp)
	int remaining = 16; /* 16 digits max */
80040d72:	4c41                	li	s8,16
	int digits = 0;
80040d74:	4b81                	li	s7,0
	int found_largest_digit = 0;
80040d76:	c002                	sw	zero,0(sp)
	int size = sizeof(num) * 2;
80040d78:	48c1                	li	a7,16
		char nibble = (num >> ((size - 1) << 2) & 0xf);
80040d7a:	4512                	lw	a0,4(sp)
80040d7c:	45a2                	lw	a1,8(sp)
80040d7e:	fff88b13          	addi	s6,a7,-1
80040d82:	002b1613          	slli	a2,s6,0x2
80040d86:	c646                	sw	a7,12(sp)
80040d88:	c88ff0ef          	jal	ra,80040210 <__lshrdi3>
80040d8c:	893d                	andi	a0,a0,15
		if (nibble != 0 || found_largest_digit != 0 || size == 1) {
80040d8e:	ed39                	bnez	a0,80040dec <z_vprintk+0x288>
80040d90:	4782                	lw	a5,0(sp)
			nibble += nibble > 9 ? 87 : 48;
80040d92:	03000693          	li	a3,48
		if (nibble != 0 || found_largest_digit != 0 || size == 1) {
80040d96:	e789                	bnez	a5,80040da0 <z_vprintk+0x23c>
80040d98:	48b2                	lw	a7,12(sp)
80040d9a:	4785                	li	a5,1
80040d9c:	06f89063          	bne	a7,a5,80040dfc <z_vprintk+0x298>
			nibble += nibble > 9 ? 87 : 48;
80040da0:	9536                	add	a0,a0,a3
			out((int)nibble, ctx);
80040da2:	0562                	slli	a0,a0,0x18
80040da4:	85a6                	mv	a1,s1
80040da6:	8561                	srai	a0,a0,0x18
80040da8:	9402                	jalr	s0
			digits++;
80040daa:	0b85                	addi	s7,s7,1
	for (; size != 0; size--) {
80040dac:	020b1d63          	bnez	s6,80040de6 <z_vprintk+0x282>
	if (padding == PAD_SPACE_AFTER) {
80040db0:	468d                	li	a3,3
			might_format = 0;
80040db2:	4c81                	li	s9,0
	if (padding == PAD_SPACE_AFTER) {
80040db4:	e0d99ae3          	bne	s3,a3,80040bc8 <z_vprintk+0x64>
		remaining = min_width * 2 - digits;
80040db8:	00191713          	slli	a4,s2,0x1
80040dbc:	41770bb3          	sub	s7,a4,s7
		while (remaining-- > 0) {
80040dc0:	f5705ce3          	blez	s7,80040d18 <z_vprintk+0x1b4>
			out(' ', ctx);
80040dc4:	85a6                	mv	a1,s1
80040dc6:	02000513          	li	a0,32
80040dca:	9402                	jalr	s0
80040dcc:	1bfd                	addi	s7,s7,-1
80040dce:	bfcd                	j	80040dc0 <z_vprintk+0x25c>
					x = va_arg(ap, unsigned long long);
80040dd0:	007d0793          	addi	a5,s10,7
80040dd4:	ff87f693          	andi	a3,a5,-8
80040dd8:	429c                	lw	a5,0(a3)
80040dda:	00868d13          	addi	s10,a3,8
80040dde:	c23e                	sw	a5,4(sp)
80040de0:	42dc                	lw	a5,4(a3)
80040de2:	c43e                	sw	a5,8(sp)
80040de4:	b779                	j	80040d72 <z_vprintk+0x20e>
			found_largest_digit = 1;
80040de6:	c066                	sw	s9,0(sp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
80040de8:	88da                	mv	a7,s6
80040dea:	bf41                	j	80040d7a <z_vprintk+0x216>
			nibble += nibble > 9 ? 87 : 48;
80040dec:	47a5                	li	a5,9
80040dee:	05700693          	li	a3,87
80040df2:	faa7e7e3          	bltu	a5,a0,80040da0 <z_vprintk+0x23c>
80040df6:	03000693          	li	a3,48
80040dfa:	b75d                	j	80040da0 <z_vprintk+0x23c>
		if (remaining-- <= min_width) {
80040dfc:	fffc0793          	addi	a5,s8,-1
80040e00:	c63e                	sw	a5,12(sp)
80040e02:	01894963          	blt	s2,s8,80040e14 <z_vprintk+0x2b0>
			if (padding == PAD_ZERO_BEFORE) {
80040e06:	4785                	li	a5,1
80040e08:	00f99863          	bne	s3,a5,80040e18 <z_vprintk+0x2b4>
				out('0', ctx);
80040e0c:	85a6                	mv	a1,s1
80040e0e:	03000513          	li	a0,48
				out(' ', ctx);
80040e12:	9402                	jalr	s0
					x = va_arg(ap, unsigned long);
80040e14:	4c32                	lw	s8,12(sp)
80040e16:	bfc9                	j	80040de8 <z_vprintk+0x284>
			} else if (padding == PAD_SPACE_BEFORE) {
80040e18:	4789                	li	a5,2
80040e1a:	fef99de3          	bne	s3,a5,80040e14 <z_vprintk+0x2b0>
				out(' ', ctx);
80040e1e:	85a6                	mv	a1,s1
80040e20:	02000513          	li	a0,32
80040e24:	b7fd                	j	80040e12 <z_vprintk+0x2ae>
					out((int)(*s++), ctx);
80040e26:	85a6                	mv	a1,s1
80040e28:	0b85                	addi	s7,s7,1
80040e2a:	9402                	jalr	s0
80040e2c:	b589                	j	80040c6e <z_vprintk+0x10a>
						out(' ', ctx);
80040e2e:	85a6                	mv	a1,s1
80040e30:	02000513          	li	a0,32
80040e34:	9402                	jalr	s0
80040e36:	1bfd                	addi	s7,s7,-1
80040e38:	b5b1                	j	80040c84 <z_vprintk+0x120>
				out(c, ctx);
80040e3a:	000d2503          	lw	a0,0(s10)
80040e3e:	85a6                	mv	a1,s1
				int c = va_arg(ap, int);
80040e40:	004d0b13          	addi	s6,s10,4
				out(c, ctx);
80040e44:	9402                	jalr	s0
				break;
80040e46:	b589                	j	80040c88 <z_vprintk+0x124>
				long_ctr = 0;
80040e48:	4a01                	li	s4,0
				min_width = -1;
80040e4a:	597d                	li	s2,-1
				padding = PAD_NONE;
80040e4c:	4981                	li	s3,0
				might_format = 1;
80040e4e:	4c85                	li	s9,1
80040e50:	bba5                	j	80040bc8 <z_vprintk+0x64>
				padding = PAD_SPACE_AFTER;
80040e52:	498d                	li	s3,3
80040e54:	bb95                	j	80040bc8 <z_vprintk+0x64>
					padding = PAD_ZERO_BEFORE;
80040e56:	4985                	li	s3,1
80040e58:	bb85                	j	80040bc8 <z_vprintk+0x64>

80040e5a <vprintk>:
{
80040e5a:	1101                	addi	sp,sp,-32
	z_vprintk(char_out, &ctx, fmt, ap);
80040e5c:	862a                	mv	a2,a0
80040e5e:	80041537          	lui	a0,0x80041
80040e62:	86ae                	mv	a3,a1
80040e64:	a7e50513          	addi	a0,a0,-1410 # 80040a7e <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80040a7f>
80040e68:	006c                	addi	a1,sp,12
{
80040e6a:	ce06                	sw	ra,28(sp)
	struct out_context ctx = { 0 };
80040e6c:	c602                	sw	zero,12(sp)
	z_vprintk(char_out, &ctx, fmt, ap);
80040e6e:	39dd                	jal	80040b64 <z_vprintk>
}
80040e70:	40f2                	lw	ra,28(sp)
80040e72:	6105                	addi	sp,sp,32
80040e74:	8082                	ret

80040e76 <printk>:
{
80040e76:	7139                	addi	sp,sp,-64
80040e78:	d22e                	sw	a1,36(sp)
	va_start(ap, fmt);
80040e7a:	104c                	addi	a1,sp,36
{
80040e7c:	ce06                	sw	ra,28(sp)
80040e7e:	d432                	sw	a2,40(sp)
80040e80:	d636                	sw	a3,44(sp)
80040e82:	d83a                	sw	a4,48(sp)
80040e84:	da3e                	sw	a5,52(sp)
80040e86:	dc42                	sw	a6,56(sp)
80040e88:	de46                	sw	a7,60(sp)
	va_start(ap, fmt);
80040e8a:	c62e                	sw	a1,12(sp)
		vprintk(fmt, ap);
80040e8c:	37f9                	jal	80040e5a <vprintk>
}
80040e8e:	40f2                	lw	ra,28(sp)
80040e90:	6121                	addi	sp,sp,64
80040e92:	8082                	ret

80040e94 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);

GEN_ABS_SYM_END
80040e94:	8082                	ret

80040e96 <k_cpu_idle>:
 */
static ALWAYS_INLINE void z_arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
80040e96:	47a1                	li	a5,8
80040e98:	3007a7f3          	csrrs	a5,mstatus,a5
	z_sys_trace_idle();
	/* unlock interrupts */
	irq_unlock(key);

	/* Wait for interrupt */
	__asm__ volatile("wfi");
80040e9c:	10500073          	wfi
 * @return N/A
 */
void k_cpu_idle(void)
{
	riscv_idle(SOC_MSTATUS_IEN);
}
80040ea0:	8082                	ret

80040ea2 <z_arch_irq_enable>:
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
80040ea2:	4785                	li	a5,1
80040ea4:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
80040ea8:	30452573          	csrrs	a0,mie,a0
}
80040eac:	8082                	ret

80040eae <soc_interrupt_init>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
80040eae:	47a1                	li	a5,8
80040eb0:	3007b7f3          	csrrc	a5,mstatus,a5
void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
80040eb4:	30405073          	csrwi	mie,0
80040eb8:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
80040ebc:	8082                	ret

80040ebe <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
80040ebe:	1141                	addi	sp,sp,-16
80040ec0:	c422                	sw	s0,8(sp)
80040ec2:	c226                	sw	s1,4(sp)
80040ec4:	80042437          	lui	s0,0x80042
80040ec8:	c606                	sw	ra,12(sp)
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
80040eca:	47a9                	li	a5,10
{
80040ecc:	84aa                	mv	s1,a0
80040ece:	5b840413          	addi	s0,s0,1464 # 800425b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425b9>
	if ('\n' == c) {
80040ed2:	00f51763          	bne	a0,a5,80040ee0 <console_out+0x22>
80040ed6:	4008                	lw	a0,0(s0)
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
80040ed8:	45b5                	li	a1,13
80040eda:	415c                	lw	a5,4(a0)
80040edc:	43dc                	lw	a5,4(a5)
80040ede:	9782                	jalr	a5
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
80040ee0:	4008                	lw	a0,0(s0)
80040ee2:	0ff4f593          	andi	a1,s1,255
80040ee6:	415c                	lw	a5,4(a0)
80040ee8:	43dc                	lw	a5,4(a5)
80040eea:	9782                	jalr	a5

	return c;
}
80040eec:	40b2                	lw	ra,12(sp)
80040eee:	4422                	lw	s0,8(sp)
80040ef0:	8526                	mv	a0,s1
80040ef2:	4492                	lw	s1,4(sp)
80040ef4:	0141                	addi	sp,sp,16
80040ef6:	8082                	ret

80040ef8 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
80040ef8:	1141                	addi	sp,sp,-16
80040efa:	c422                	sw	s0,8(sp)
	__stdout_hook_install(console_out);
80040efc:	80041437          	lui	s0,0x80041
80040f00:	ebe40513          	addi	a0,s0,-322 # 80040ebe <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80040ebf>
{
80040f04:	c606                	sw	ra,12(sp)
	__stdout_hook_install(console_out);
80040f06:	2415                	jal	8004112a <__stdout_hook_install>
	__printk_hook_install(console_out);
80040f08:	ebe40513          	addi	a0,s0,-322
}
80040f0c:	4422                	lw	s0,8(sp)
80040f0e:	40b2                	lw	ra,12(sp)
80040f10:	0141                	addi	sp,sp,16
	__printk_hook_install(console_out);
80040f12:	b1a1                	j	80040b5a <__printk_hook_install>

80040f14 <uart_console_init>:

#ifdef __cplusplus
extern "C" {
#endif

K_SYSCALL_DECLARE1(K_SYSCALL_DEVICE_GET_BINDING, device_get_binding, struct device *, const char *, name)
80040f14:	80042537          	lui	a0,0x80042
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
80040f18:	1141                	addi	sp,sp,-16
80040f1a:	44c50513          	addi	a0,a0,1100 # 8004244c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004244d>
80040f1e:	c606                	sw	ra,12(sp)
80040f20:	2cad                	jal	8004119a <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
80040f22:	800427b7          	lui	a5,0x80042
80040f26:	5aa7ac23          	sw	a0,1464(a5) # 800425b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425b9>
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
80040f2a:	37f9                	jal	80040ef8 <uart_console_hook_install>

	return 0;
}
80040f2c:	40b2                	lw	ra,12(sp)
80040f2e:	4501                	li	a0,0
80040f30:	0141                	addi	sp,sp,16
80040f32:	8082                	ret

80040f34 <mtime>:
	volatile u32_t *r = (u32_t *)RISCV_MTIME_BASE;
	u32_t lo, hi;

	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
80040f34:	200007b7          	lui	a5,0x20000
80040f38:	43d8                	lw	a4,4(a5)
		lo = r[0];
80040f3a:	4388                	lw	a0,0(a5)
	} while (r[1] != hi);
80040f3c:	43cc                	lw	a1,4(a5)
80040f3e:	fee59de3          	bne	a1,a4,80040f38 <mtime+0x4>

	return (((u64_t)hi) << 32) | lo;
}
80040f42:	8082                	ret

80040f44 <timer_isr>:

static void timer_isr(void *arg)
{
80040f44:	1101                	addi	sp,sp,-32
80040f46:	cc22                	sw	s0,24(sp)
80040f48:	ce06                	sw	ra,28(sp)
80040f4a:	ca26                	sw	s1,20(sp)
80040f4c:	c84a                	sw	s2,16(sp)
80040f4e:	c64e                	sw	s3,12(sp)
80040f50:	4421                	li	s0,8
80040f52:	30043473          	csrrc	s0,mstatus,s0
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u64_t now = mtime();
	u32_t dticks = (u32_t)((now - last_count) / CYC_PER_TICK);
80040f56:	800424b7          	lui	s1,0x80042
80040f5a:	5a048493          	addi	s1,s1,1440 # 800425a0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425a1>
	u64_t now = mtime();
80040f5e:	3fd9                	jal	80040f34 <mtime>
	u32_t dticks = (u32_t)((now - last_count) / CYC_PER_TICK);
80040f60:	0004a903          	lw	s2,0(s1)
80040f64:	0044a983          	lw	s3,4(s1)
	u64_t now = mtime();
80040f68:	872a                	mv	a4,a0
	u32_t dticks = (u32_t)((now - last_count) / CYC_PER_TICK);
80040f6a:	41250533          	sub	a0,a0,s2
80040f6e:	00a73733          	sltu	a4,a4,a0
80040f72:	413585b3          	sub	a1,a1,s3
80040f76:	6609                	lui	a2,0x2
80040f78:	71060613          	addi	a2,a2,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
80040f7c:	4681                	li	a3,0
80040f7e:	8d99                	sub	a1,a1,a4
80040f80:	ac8ff0ef          	jal	ra,80040248 <__udivdi3>

	last_count += dticks * CYC_PER_TICK;
80040f84:	6789                	lui	a5,0x2
80040f86:	71078793          	addi	a5,a5,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
80040f8a:	02a787b3          	mul	a5,a5,a0
	key = (mstatus & SOC_MSTATUS_IEN);
80040f8e:	8821                	andi	s0,s0,8
80040f90:	993e                	add	s2,s2,a5
80040f92:	00f937b3          	sltu	a5,s2,a5
80040f96:	97ce                	add	a5,a5,s3
80040f98:	0124a023          	sw	s2,0(s1)
80040f9c:	c0dc                	sw	a5,4(s1)
	__asm__ volatile ("csrrs %0, mstatus, %1"
80040f9e:	30042473          	csrrs	s0,mstatus,s0
		set_mtimecmp(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
80040fa2:	4462                	lw	s0,24(sp)
80040fa4:	40f2                	lw	ra,28(sp)
80040fa6:	44d2                	lw	s1,20(sp)
80040fa8:	4942                	lw	s2,16(sp)
80040faa:	49b2                	lw	s3,12(sp)
80040fac:	6105                	addi	sp,sp,32
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
80040fae:	5910006f          	j	80041d3e <z_clock_announce>

80040fb2 <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
80040fb2:	1141                	addi	sp,sp,-16
80040fb4:	c606                	sw	ra,12(sp)
	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
	set_mtimecmp(mtime() + CYC_PER_TICK);
80040fb6:	3fbd                	jal	80040f34 <mtime>
80040fb8:	6789                	lui	a5,0x2
80040fba:	71078793          	addi	a5,a5,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
	r[1] = 0xffffffff;
80040fbe:	20000737          	lui	a4,0x20000
	set_mtimecmp(mtime() + CYC_PER_TICK);
80040fc2:	97aa                	add	a5,a5,a0
	r[1] = 0xffffffff;
80040fc4:	56fd                	li	a3,-1
80040fc6:	c754                	sw	a3,12(a4)
	set_mtimecmp(mtime() + CYC_PER_TICK);
80040fc8:	00a7b533          	sltu	a0,a5,a0
80040fcc:	952e                	add	a0,a0,a1
	r[0] = (u32_t)time;
80040fce:	c71c                	sw	a5,8(a4)
	r[1] = (u32_t)(time >> 32);
80040fd0:	c748                	sw	a0,12(a4)
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
80040fd2:	451d                	li	a0,7
80040fd4:	35f9                	jal	80040ea2 <z_arch_irq_enable>
	return 0;
}
80040fd6:	40b2                	lw	ra,12(sp)
80040fd8:	4501                	li	a0,0
80040fda:	0141                	addi	sp,sp,16
80040fdc:	8082                	ret

80040fde <z_clock_set_timeout>:
	 * logic below to reset the comparator, we'll always bump it
	 * forward to the "next tick" due to MIN_DELAY handling and
	 * the interrupt will never fire!  Just rely on the fact that
	 * the OS gave us the proper timeout already.
	 */
	if (idle) {
80040fde:	edc9                	bnez	a1,80041078 <z_clock_set_timeout+0x9a>
{
80040fe0:	1141                	addi	sp,sp,-16
80040fe2:	c422                	sw	s0,8(sp)
80040fe4:	c606                	sw	ra,12(sp)
80040fe6:	c226                	sw	s1,4(sp)
		return;
	}

	ticks = ticks == K_FOREVER ? MAX_TICKS : ticks;
80040fe8:	57fd                	li	a5,-1
80040fea:	842a                	mv	s0,a0
80040fec:	00f51663          	bne	a0,a5,80040ff8 <z_clock_set_timeout+0x1a>
80040ff0:	000697b7          	lui	a5,0x69
80040ff4:	db778413          	addi	s0,a5,-585 # 68db7 <CONFIG_RISCV_RAM_SIZE+0x28db7>
	__asm__ volatile ("csrrc %0, mstatus, %1"
80040ff8:	44a1                	li	s1,8
80040ffa:	3004b4f3          	csrrc	s1,mstatus,s1
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u64_t now = mtime();
80040ffe:	3f1d                	jal	80040f34 <mtime>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
80041000:	00069737          	lui	a4,0x69
80041004:	fff40793          	addi	a5,s0,-1
80041008:	db770713          	addi	a4,a4,-585 # 68db7 <CONFIG_RISCV_RAM_SIZE+0x28db7>
	key = (mstatus & SOC_MSTATUS_IEN);
8004100c:	88a1                	andi	s1,s1,8
8004100e:	06f75163          	bge	a4,a5,80041070 <z_clock_set_timeout+0x92>
80041012:	87ba                	mv	a5,a4
	u32_t cyc = ticks * CYC_PER_TICK;
80041014:	6709                	lui	a4,0x2
80041016:	71070593          	addi	a1,a4,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
8004101a:	02b786b3          	mul	a3,a5,a1

	/* Round up to next tick boundary.  Note use of 32 bit math,
	 * max_ticks is calibrated to permit this.
	 */
	cyc += (u32_t)(now - last_count) + (CYC_PER_TICK - 1);
8004101e:	800427b7          	lui	a5,0x80042
80041022:	5a078793          	addi	a5,a5,1440 # 800425a0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425a1>
80041026:	4390                	lw	a2,0(a5)
80041028:	0047a803          	lw	a6,4(a5)
8004102c:	70f70793          	addi	a5,a4,1807
80041030:	8f91                	sub	a5,a5,a2
80041032:	97aa                	add	a5,a5,a0
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;

	if ((s32_t)(cyc + last_count - now) < MIN_DELAY) {
80041034:	40a60533          	sub	a0,a2,a0
80041038:	3e700713          	li	a4,999
	cyc += (u32_t)(now - last_count) + (CYC_PER_TICK - 1);
8004103c:	97b6                	add	a5,a5,a3
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
8004103e:	02b7d7b3          	divu	a5,a5,a1
80041042:	02b787b3          	mul	a5,a5,a1
	if ((s32_t)(cyc + last_count - now) < MIN_DELAY) {
80041046:	953e                	add	a0,a0,a5
80041048:	00a74363          	blt	a4,a0,8004104e <z_clock_set_timeout+0x70>
		cyc += CYC_PER_TICK;
8004104c:	97ae                	add	a5,a5,a1
	r[1] = 0xffffffff;
8004104e:	20000737          	lui	a4,0x20000
	}

	set_mtimecmp(cyc + last_count);
80041052:	963e                	add	a2,a2,a5
	r[1] = 0xffffffff;
80041054:	56fd                	li	a3,-1
80041056:	c754                	sw	a3,12(a4)
	set_mtimecmp(cyc + last_count);
80041058:	00f637b3          	sltu	a5,a2,a5
8004105c:	97c2                	add	a5,a5,a6
	r[0] = (u32_t)time;
8004105e:	c710                	sw	a2,8(a4)
	r[1] = (u32_t)(time >> 32);
80041060:	c75c                	sw	a5,12(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041062:	3004a4f3          	csrrs	s1,mstatus,s1
	k_spin_unlock(&lock, key);
#endif
}
80041066:	40b2                	lw	ra,12(sp)
80041068:	4422                	lw	s0,8(sp)
8004106a:	4492                	lw	s1,4(sp)
8004106c:	0141                	addi	sp,sp,16
8004106e:	8082                	ret
	u32_t cyc = ticks * CYC_PER_TICK;
80041070:	fa07d2e3          	bgez	a5,80041014 <z_clock_set_timeout+0x36>
80041074:	4781                	li	a5,0
80041076:	bf79                	j	80041014 <z_clock_set_timeout+0x36>
80041078:	8082                	ret

8004107a <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
8004107a:	1141                	addi	sp,sp,-16
8004107c:	c422                	sw	s0,8(sp)
8004107e:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041080:	4421                	li	s0,8
80041082:	30043473          	csrrc	s0,mstatus,s0
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = ((u32_t)mtime() - (u32_t)last_count) / CYC_PER_TICK;
80041086:	357d                	jal	80040f34 <mtime>
80041088:	800427b7          	lui	a5,0x80042
8004108c:	5a07a783          	lw	a5,1440(a5) # 800425a0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425a1>
	key = (mstatus & SOC_MSTATUS_IEN);
80041090:	8821                	andi	s0,s0,8
80041092:	8d1d                	sub	a0,a0,a5
80041094:	6789                	lui	a5,0x2
80041096:	71078793          	addi	a5,a5,1808 # 2710 <CONFIG_ISR_STACK_SIZE+0x1f10>
8004109a:	02f55533          	divu	a0,a0,a5
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004109e:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&lock, key);
	return ret;
}
800410a2:	40b2                	lw	ra,12(sp)
800410a4:	4422                	lw	s0,8(sp)
800410a6:	0141                	addi	sp,sp,16
800410a8:	8082                	ret

800410aa <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
800410aa:	00054783          	lbu	a5,0(a0)
800410ae:	0005c703          	lbu	a4,0(a1)
800410b2:	00e79363          	bne	a5,a4,800410b8 <strcmp+0xe>
800410b6:	e781                	bnez	a5,800410be <strcmp+0x14>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
800410b8:	40e78533          	sub	a0,a5,a4
800410bc:	8082                	ret
		s1++;
800410be:	0505                	addi	a0,a0,1
		s2++;
800410c0:	0585                	addi	a1,a1,1
800410c2:	b7e5                	j	800410aa <strcmp>

800410c4 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
800410c4:	0ff5f693          	andi	a3,a1,255
	unsigned char *d_byte = (unsigned char *)buf;
800410c8:	87aa                	mv	a5,a0

	while (((unsigned int)d_byte) & 0x3) {
800410ca:	0037f713          	andi	a4,a5,3
800410ce:	ef15                	bnez	a4,8004110a <memset+0x46>
	};

	/* do word-sized initialization as long as possible */

	unsigned int *d_word = (unsigned int *)d_byte;
	unsigned int c_word = (unsigned int)(unsigned char)c;
800410d0:	0ff5f593          	andi	a1,a1,255

	c_word |= c_word << 8;
800410d4:	00859713          	slli	a4,a1,0x8
800410d8:	8dd9                	or	a1,a1,a4
	c_word |= c_word << 16;
800410da:	01059713          	slli	a4,a1,0x10
800410de:	8dd9                	or	a1,a1,a4

	while (n >= sizeof(unsigned int)) {
800410e0:	00c78333          	add	t1,a5,a2
800410e4:	873e                	mv	a4,a5
800410e6:	480d                	li	a6,3
800410e8:	40e308b3          	sub	a7,t1,a4
800410ec:	03186563          	bltu	a6,a7,80041116 <memset+0x52>
800410f0:	00265713          	srli	a4,a2,0x2
800410f4:	00271593          	slli	a1,a4,0x2
800410f8:	97ae                	add	a5,a5,a1
800410fa:	55f1                	li	a1,-4
800410fc:	02b70733          	mul	a4,a4,a1
80041100:	9732                	add	a4,a4,a2
80041102:	973e                	add	a4,a4,a5

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
80041104:	00e79d63          	bne	a5,a4,8004111e <memset+0x5a>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
80041108:	8082                	ret
		if (n == 0) {
8004110a:	de7d                	beqz	a2,80041108 <memset+0x44>
		*(d_byte++) = c_byte;
8004110c:	0785                	addi	a5,a5,1
8004110e:	fed78fa3          	sb	a3,-1(a5)
		n--;
80041112:	167d                	addi	a2,a2,-1
80041114:	bf5d                	j	800410ca <memset+0x6>
		*(d_word++) = c_word;
80041116:	0711                	addi	a4,a4,4
80041118:	feb72e23          	sw	a1,-4(a4) # 1ffffffc <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x1ff0bdbc>
		n -= sizeof(unsigned int);
8004111c:	b7f1                	j	800410e8 <memset+0x24>
		*(d_byte++) = c_byte;
8004111e:	0785                	addi	a5,a5,1
80041120:	fed78fa3          	sb	a3,-1(a5)
		n--;
80041124:	b7c5                	j	80041104 <memset+0x40>

80041126 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
80041126:	557d                	li	a0,-1
80041128:	8082                	ret

8004112a <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
8004112a:	800427b7          	lui	a5,0x80042
8004112e:	4ea7a023          	sw	a0,1248(a5) # 800424e0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424e1>
}
80041132:	8082                	ret

80041134 <uart_pulserain_rattlesnake_poll_out>:
static unsigned char uart_pulserain_rattlesnake_poll_out(struct device *dev,
					      unsigned char c)
{
    volatile unsigned int *uart = (unsigned int*)PULSERAIN_RATTLESNAKE_UART_BASE;
   
    while ((*uart) & 0x80000000){};
80041134:	200007b7          	lui	a5,0x20000
80041138:	4b94                	lw	a3,16(a5)
8004113a:	fe06cfe3          	bltz	a3,80041138 <uart_pulserain_rattlesnake_poll_out+0x4>
        *uart = c;
8004113e:	cb8c                	sw	a1,16(a5)
    while ((*uart) & 0x80000000){};
80041140:	20000737          	lui	a4,0x20000
80041144:	4b1c                	lw	a5,16(a4)
80041146:	fe07cfe3          	bltz	a5,80041144 <uart_pulserain_rattlesnake_poll_out+0x10>
  
    return c;
}
8004114a:	852e                	mv	a0,a1
8004114c:	8082                	ret

8004114e <uart_pulserain_rattlesnake_poll_in>:

static int uart_pulserain_rattlesnake_poll_in(struct device *dev, unsigned char *c)
{
	*c = 0;
8004114e:	00058023          	sb	zero,0(a1)
	return 0;
}
80041152:	4501                	li	a0,0
80041154:	8082                	ret

80041156 <uart_pulserain_rattlesnake_init>:
static int uart_pulserain_rattlesnake_init(struct device *dev)
{
	/* Nothing to do */

	return 0;
}
80041156:	4501                	li	a0,0
80041158:	8082                	ret

8004115a <z_sys_device_do_config_level>:
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
8004115a:	00251713          	slli	a4,a0,0x2
8004115e:	800427b7          	lui	a5,0x80042
80041162:	0505                	addi	a0,a0,1
80041164:	47478793          	addi	a5,a5,1140 # 80042474 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042475>
80041168:	050a                	slli	a0,a0,0x2
{
8004116a:	1141                	addi	sp,sp,-16
	for (info = config_levels[level]; info < config_levels[level+1];
8004116c:	973e                	add	a4,a4,a5
8004116e:	97aa                	add	a5,a5,a0
{
80041170:	c422                	sw	s0,8(sp)
80041172:	c226                	sw	s1,4(sp)
	for (info = config_levels[level]; info < config_levels[level+1];
80041174:	4300                	lw	s0,0(a4)
80041176:	4384                	lw	s1,0(a5)
{
80041178:	c606                	sw	ra,12(sp)
	for (info = config_levels[level]; info < config_levels[level+1];
8004117a:	00946763          	bltu	s0,s1,80041188 <z_sys_device_do_config_level+0x2e>
			info->driver_api = NULL;
		} else {
			z_object_init(info);
		}
	}
}
8004117e:	40b2                	lw	ra,12(sp)
80041180:	4422                	lw	s0,8(sp)
80041182:	4492                	lw	s1,4(sp)
80041184:	0141                	addi	sp,sp,16
80041186:	8082                	ret
		retval = device_conf->init(info);
80041188:	401c                	lw	a5,0(s0)
8004118a:	8522                	mv	a0,s0
8004118c:	43dc                	lw	a5,4(a5)
8004118e:	9782                	jalr	a5
		if (retval != 0) {
80041190:	c119                	beqz	a0,80041196 <z_sys_device_do_config_level+0x3c>
			info->driver_api = NULL;
80041192:	00042223          	sw	zero,4(s0)
								info++) {
80041196:	0431                	addi	s0,s0,12
80041198:	b7cd                	j	8004117a <z_sys_device_do_config_level+0x20>

8004119a <z_impl_device_get_binding>:

struct device *z_impl_device_get_binding(const char *name)
{
8004119a:	1141                	addi	sp,sp,-16
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
8004119c:	800427b7          	lui	a5,0x80042
{
800411a0:	c226                	sw	s1,4(sp)
	for (info = __device_init_start; info != __device_init_end; info++) {
800411a2:	800424b7          	lui	s1,0x80042
{
800411a6:	c422                	sw	s0,8(sp)
800411a8:	c606                	sw	ra,12(sp)
	for (info = __device_init_start; info != __device_init_end; info++) {
800411aa:	50c78413          	addi	s0,a5,1292 # 8004250c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004250d>
{
800411ae:	c04a                	sw	s2,0(sp)
800411b0:	50c78793          	addi	a5,a5,1292
800411b4:	53c48493          	addi	s1,s1,1340 # 8004253c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004253d>
	for (info = __device_init_start; info != __device_init_end; info++) {
800411b8:	00941863          	bne	s0,s1,800411c8 <z_impl_device_get_binding+0x2e>
800411bc:	892a                	mv	s2,a0
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
800411be:	843e                	mv	s0,a5
800411c0:	00941c63          	bne	s0,s1,800411d8 <z_impl_device_get_binding+0x3e>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
800411c4:	4401                	li	s0,0
800411c6:	a015                	j	800411ea <z_impl_device_get_binding+0x50>
		if ((info->driver_api != NULL) &&
800411c8:	4058                	lw	a4,4(s0)
800411ca:	c709                	beqz	a4,800411d4 <z_impl_device_get_binding+0x3a>
		    (info->config->name == name)) {
800411cc:	4018                	lw	a4,0(s0)
		if ((info->driver_api != NULL) &&
800411ce:	4318                	lw	a4,0(a4)
800411d0:	00a70d63          	beq	a4,a0,800411ea <z_impl_device_get_binding+0x50>
	for (info = __device_init_start; info != __device_init_end; info++) {
800411d4:	0431                	addi	s0,s0,12
800411d6:	b7cd                	j	800411b8 <z_impl_device_get_binding+0x1e>
		if (info->driver_api == NULL) {
800411d8:	405c                	lw	a5,4(s0)
800411da:	e399                	bnez	a5,800411e0 <z_impl_device_get_binding+0x46>
	for (info = __device_init_start; info != __device_init_end; info++) {
800411dc:	0431                	addi	s0,s0,12
800411de:	b7cd                	j	800411c0 <z_impl_device_get_binding+0x26>
		if (strcmp(name, info->config->name) == 0) {
800411e0:	401c                	lw	a5,0(s0)
800411e2:	854a                	mv	a0,s2
800411e4:	438c                	lw	a1,0(a5)
800411e6:	35d1                	jal	800410aa <strcmp>
800411e8:	f975                	bnez	a0,800411dc <z_impl_device_get_binding+0x42>
}
800411ea:	8522                	mv	a0,s0
800411ec:	40b2                	lw	ra,12(sp)
800411ee:	4422                	lw	s0,8(sp)
800411f0:	4492                	lw	s1,4(sp)
800411f2:	4902                	lw	s2,0(sp)
800411f4:	0141                	addi	sp,sp,16
800411f6:	8082                	ret

800411f8 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(&__bss_start, 0,
800411f8:	80042537          	lui	a0,0x80042
800411fc:	800427b7          	lui	a5,0x80042
80041200:	5a050613          	addi	a2,a0,1440 # 800425a0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425a1>
80041204:	7b878793          	addi	a5,a5,1976 # 800427b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800427b9>
80041208:	40c78633          	sub	a2,a5,a2
8004120c:	4581                	li	a1,0
8004120e:	5a050513          	addi	a0,a0,1440
80041212:	bd4d                	j	800410c4 <memset>

80041214 <main>:
/**
 * @brief Explicitly nop operation.
 */
static ALWAYS_INLINE void arch_nop(void)
{
	__asm__ volatile("nop");
80041214:	0001                	nop

void __weak main(void)
{
	/* NOP default main() if the application does not provide one. */
	arch_nop();
}
80041216:	8082                	ret

80041218 <bg_thread_main>:
{
80041218:	1141                	addi	sp,sp,-16
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
8004121a:	4509                	li	a0,2
{
8004121c:	c606                	sw	ra,12(sp)
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
8004121e:	3f35                	jal	8004115a <z_sys_device_do_config_level>
	PRINT_BOOT_BANNER();
80041220:	80042537          	lui	a0,0x80042
80041224:	48850513          	addi	a0,a0,1160 # 80042488 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042489>
80041228:	31b9                	jal	80040e76 <printk>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
8004122a:	450d                	li	a0,3
8004122c:	373d                	jal	8004115a <z_sys_device_do_config_level>
	z_init_static_threads();
8004122e:	0a9000ef          	jal	ra,80041ad6 <z_init_static_threads>
	main();
80041232:	37cd                	jal	80041214 <main>
	_main_thread->base.user_options &= ~K_ESSENTIAL;
80041234:	800427b7          	lui	a5,0x80042
80041238:	71c78793          	addi	a5,a5,1820 # 8004271c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004271d>
8004123c:	00c7c703          	lbu	a4,12(a5)
80041240:	9b79                	andi	a4,a4,-2
80041242:	00e78623          	sb	a4,12(a5)
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
80041246:	40b2                	lw	ra,12(sp)
80041248:	0141                	addi	sp,sp,16
8004124a:	8082                	ret

8004124c <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
8004124c:	7135                	addi	sp,sp,-160
8004124e:	cd22                	sw	s0,152(sp)
void k_cpu_idle(void);
void k_cpu_atomic_idle(unsigned int key);

static ALWAYS_INLINE void kernel_arch_init(void)
{
	_kernel.irq_stack =
80041250:	800447b7          	lui	a5,0x80044
80041254:	80042437          	lui	s0,0x80042
80041258:	c74e                	sw	s3,140(sp)
8004125a:	dc078793          	addi	a5,a5,-576 # 80043dc0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80043dc1>
8004125e:	78c40993          	addi	s3,s0,1932 # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
80041262:	00f9a223          	sw	a5,4(s3)

	/* perform any architecture-specific initialization */
	kernel_arch_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
80041266:	081c                	addi	a5,sp,16
80041268:	07000613          	li	a2,112
8004126c:	4581                	li	a1,0
8004126e:	853e                	mv	a0,a5
{
80041270:	cf06                	sw	ra,156(sp)
80041272:	cb26                	sw	s1,148(sp)
80041274:	c94a                	sw	s2,144(sp)
80041276:	c552                	sw	s4,136(sp)
	struct k_thread dummy_thread = {
80041278:	35b1                	jal	800410c4 <memset>
8004127a:	4a05                	li	s4,1
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
8004127c:	00a9a423          	sw	a0,8(s3)
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
80041280:	4501                	li	a0,0
	struct k_thread dummy_thread = {
80041282:	01410ea3          	sb	s4,29(sp)
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
80041286:	3dd1                	jal	8004115a <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
80041288:	4505                	li	a0,1
8004128a:	3dc1                	jal	8004115a <z_sys_device_do_config_level>
	dummy_thread->base.user_options = K_ESSENTIAL;
8004128c:	10100793          	li	a5,257
80041290:	00f11e23          	sh	a5,28(sp)
	z_sched_init();
80041294:	2381                	jal	800417d4 <z_sched_init>
	z_setup_new_thread(_main_thread, _main_stack,
80041296:	800427b7          	lui	a5,0x80042
	_kernel.ready_q.cache = _main_thread;
8004129a:	80042937          	lui	s2,0x80042
	z_setup_new_thread(_main_thread, _main_stack,
8004129e:	4cc78793          	addi	a5,a5,1228 # 800424cc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424cd>
800412a2:	800416b7          	lui	a3,0x80041
800412a6:	800435b7          	lui	a1,0x80043
	_kernel.ready_q.cache = _main_thread;
800412aa:	71c90493          	addi	s1,s2,1820 # 8004271c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004271d>
	z_setup_new_thread(_main_thread, _main_stack,
800412ae:	c23e                	sw	a5,4(sp)
800412b0:	4701                	li	a4,0
800412b2:	4781                	li	a5,0
800412b4:	c052                	sw	s4,0(sp)
800412b6:	4881                	li	a7,0
800412b8:	4801                	li	a6,0
800412ba:	21868693          	addi	a3,a3,536 # 80041218 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041219>
800412be:	40000613          	li	a2,1024
800412c2:	fc058593          	addi	a1,a1,-64 # 80042fc0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042fc1>
800412c6:	71c90513          	addi	a0,s2,1820
	_kernel.ready_q.cache = _main_thread;
800412ca:	0299a023          	sw	s1,32(s3)
	z_setup_new_thread(_main_thread, _main_stack,
800412ce:	758000ef          	jal	ra,80041a26 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
800412d2:	00d4c783          	lbu	a5,13(s1)
800412d6:	78c40413          	addi	s0,s0,1932
800412da:	ffb7f713          	andi	a4,a5,-5
800412de:	00e486a3          	sb	a4,13(s1)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
800412e2:	8bed                	andi	a5,a5,27
800412e4:	e791                	bnez	a5,800412f0 <z_cstart+0xa4>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
800412e6:	4c9c                	lw	a5,24(s1)
800412e8:	e781                	bnez	a5,800412f0 <z_cstart+0xa4>
		z_add_thread_to_ready_q(thread);
800412ea:	71c90513          	addi	a0,s2,1820
800412ee:	2afd                	jal	800414ec <z_add_thread_to_ready_q>
	z_setup_new_thread(thr, stack,
800412f0:	800427b7          	lui	a5,0x80042
800412f4:	4d478793          	addi	a5,a5,1236 # 800424d4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424d5>
800412f8:	c23e                	sw	a5,4(sp)
800412fa:	80042537          	lui	a0,0x80042
800412fe:	4785                	li	a5,1
80041300:	800426b7          	lui	a3,0x80042
80041304:	800435b7          	lui	a1,0x80043
80041308:	6ac50493          	addi	s1,a0,1708 # 800426ac <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800426ad>
8004130c:	c03e                	sw	a5,0(sp)
8004130e:	48bd                	li	a7,15
80041310:	4801                	li	a6,0
80041312:	4781                	li	a5,0
80041314:	4701                	li	a4,0
80041316:	e4868693          	addi	a3,a3,-440 # 80041e48 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041e49>
8004131a:	20000613          	li	a2,512
8004131e:	3c058593          	addi	a1,a1,960 # 800433c0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800433c1>
80041322:	6ac50513          	addi	a0,a0,1708
80041326:	700000ef          	jal	ra,80041a26 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
8004132a:	00d4c783          	lbu	a5,13(s1)
	_kernel.cpus[0].idle_thread = _idle_thread;
8004132e:	c444                	sw	s1,12(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041330:	4521                	li	a0,8
80041332:	9bed                	andi	a5,a5,-5
80041334:	00f486a3          	sb	a5,13(s1)
	list->head = (sys_dnode_t *)list;
80041338:	800427b7          	lui	a5,0x80042
8004133c:	7a478793          	addi	a5,a5,1956 # 800427a4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800427a5>
80041340:	cc1c                	sw	a5,24(s0)
	list->tail = (sys_dnode_t *)list;
80041342:	cc5c                	sw	a5,28(s0)
80041344:	30053573          	csrrc	a0,mstatus,a0
#ifndef CONFIG_ARM
#ifdef CONFIG_TRACING
	sys_trace_thread_switched_out();
#endif
#endif
	ret = __swap(key);
80041348:	8921                	andi	a0,a0,8
8004134a:	e77fe0ef          	jal	ra,800401c0 <__swap>

8004134e <sys_dlist_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
8004134e:	4158                	lw	a4,4(a0)
80041350:	411c                	lw	a5,0(a0)
80041352:	c31c                	sw	a5,0(a4)
	node->next->prev = node->prev;
80041354:	c3d8                	sw	a4,4(a5)
	node->next = NULL;
80041356:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
8004135a:	00052223          	sw	zero,4(a0)
	sys_dnode_init(node);
}
8004135e:	8082                	ret

80041360 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
80041360:	00d54783          	lbu	a5,13(a0)
80041364:	8bfd                	andi	a5,a5,31
80041366:	e789                	bnez	a5,80041370 <z_is_thread_ready+0x10>
80041368:	4d08                	lw	a0,24(a0)
8004136a:	00153513          	seqz	a0,a0
8004136e:	8082                	ret
80041370:	4501                	li	a0,0
}
80041372:	8082                	ret

80041374 <reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

static void reset_time_slice(void)
{
80041374:	1141                	addi	sp,sp,-16
80041376:	c606                	sw	ra,12(sp)
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
80041378:	3309                	jal	8004107a <z_clock_elapsed>
8004137a:	800427b7          	lui	a5,0x80042
8004137e:	5c07a783          	lw	a5,1472(a5) # 800425c0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425c1>

	z_set_timeout_expiry(slice_time, false);
}
80041382:	40b2                	lw	ra,12(sp)
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
80041384:	80042737          	lui	a4,0x80042
80041388:	953e                	add	a0,a0,a5
8004138a:	78a72e23          	sw	a0,1948(a4) # 8004279c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004279d>
	z_set_timeout_expiry(slice_time, false);
8004138e:	4581                	li	a1,0
80041390:	853e                	mv	a0,a5
}
80041392:	0141                	addi	sp,sp,16
	z_set_timeout_expiry(slice_time, false);
80041394:	1750006f          	j	80041d08 <z_set_timeout_expiry>

80041398 <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
80041398:	1141                	addi	sp,sp,-16
8004139a:	c422                	sw	s0,8(sp)
8004139c:	c606                	sw	ra,12(sp)
8004139e:	4421                	li	s0,8
800413a0:	30043473          	csrrc	s0,mstatus,s0
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
800413a4:	800427b7          	lui	a5,0x80042
800413a8:	7807ae23          	sw	zero,1948(a5) # 8004279c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004279d>
		CONFIG_SYS_CLOCK_TICKS_PER_SEC);
#else
	/* simple division keeps precision */
	s32_t ms_per_tick = MSEC_PER_SEC / CONFIG_SYS_CLOCK_TICKS_PER_SEC;

	return (s32_t)ceiling_fraction(ms, ms_per_tick);
800413ac:	0525                	addi	a0,a0,9
800413ae:	47a9                	li	a5,10
800413b0:	02f54533          	div	a0,a0,a5
		slice_time = z_ms_to_ticks(slice);
800413b4:	800427b7          	lui	a5,0x80042
	key = (mstatus & SOC_MSTATUS_IEN);
800413b8:	8821                	andi	s0,s0,8
800413ba:	5ca7a023          	sw	a0,1472(a5) # 800425c0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425c1>
		slice_max_prio = prio;
800413be:	800427b7          	lui	a5,0x80042
800413c2:	5ab7ae23          	sw	a1,1468(a5) # 800425bc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425bd>
		reset_time_slice();
800413c6:	377d                	jal	80041374 <reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
800413c8:	30042473          	csrrs	s0,mstatus,s0
	}
}
800413cc:	40b2                	lw	ra,12(sp)
800413ce:	4422                	lw	s0,8(sp)
800413d0:	0141                	addi	sp,sp,16
800413d2:	8082                	ret

800413d4 <z_unpend_thread_no_timeout>:

	return ret;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
800413d4:	1141                	addi	sp,sp,-16
800413d6:	c422                	sw	s0,8(sp)
800413d8:	c226                	sw	s1,4(sp)
800413da:	c606                	sw	ra,12(sp)
800413dc:	84aa                	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
800413de:	4421                	li	s0,8
800413e0:	30043473          	csrrc	s0,mstatus,s0
	}
#endif

	__ASSERT_NO_MSG(!is_idle(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
800413e4:	37ad                	jal	8004134e <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
800413e6:	00d4c783          	lbu	a5,13(s1)
	key = (mstatus & SOC_MSTATUS_IEN);
800413ea:	8821                	andi	s0,s0,8
800413ec:	9bf5                	andi	a5,a5,-3
800413ee:	00f486a3          	sb	a5,13(s1)
	__asm__ volatile ("csrrs %0, mstatus, %1"
800413f2:	30042473          	csrrs	s0,mstatus,s0
}
800413f6:	40b2                	lw	ra,12(sp)
800413f8:	4422                	lw	s0,8(sp)
	thread->base.pended_on = NULL;
800413fa:	0004a423          	sw	zero,8(s1)
}
800413fe:	4492                	lw	s1,4(sp)
80041400:	0141                	addi	sp,sp,16
80041402:	8082                	ret

80041404 <z_reschedule>:
	if (resched()) {
80041404:	800427b7          	lui	a5,0x80042
80041408:	78c7a783          	lw	a5,1932(a5) # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
8004140c:	e781                	bnez	a5,80041414 <z_reschedule+0x10>
8004140e:	852e                	mv	a0,a1
80041410:	db1fe06f          	j	800401c0 <__swap>
			  : "r" (key & SOC_MSTATUS_IEN)
80041414:	89a1                	andi	a1,a1,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041416:	3005a5f3          	csrrs	a1,mstatus,a1
}
8004141a:	8082                	ret

8004141c <z_reschedule_irqlock>:
	if (resched()) {
8004141c:	80042737          	lui	a4,0x80042
80041420:	78c72703          	lw	a4,1932(a4) # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
80041424:	e319                	bnez	a4,8004142a <z_reschedule_irqlock+0xe>
80041426:	d9bfe06f          	j	800401c0 <__swap>
			  : "r" (key & SOC_MSTATUS_IEN)
8004142a:	00857793          	andi	a5,a0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004142e:	3007a7f3          	csrrs	a5,mstatus,a5
}
80041432:	8082                	ret

80041434 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041434:	4521                	li	a0,8
80041436:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(z_arch_irq_lock());
8004143a:	8921                	andi	a0,a0,8
8004143c:	b7c5                	j	8004141c <z_reschedule_irqlock>

8004143e <k_sched_lock>:
8004143e:	47a1                	li	a5,8
80041440:	3007b7f3          	csrrc	a5,mstatus,a5
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!z_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
80041444:	80042737          	lui	a4,0x80042
80041448:	79472683          	lw	a3,1940(a4) # 80042794 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042795>
8004144c:	00f6c703          	lbu	a4,15(a3)
80041450:	177d                	addi	a4,a4,-1
80041452:	00e687a3          	sb	a4,15(a3)
	key = (mstatus & SOC_MSTATUS_IEN);
80041456:	8ba1                	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041458:	3007a7f3          	csrrs	a5,mstatus,a5
}
8004145c:	8082                	ret

8004145e <z_priq_dumb_best>:
	return list->head == list;
8004145e:	411c                	lw	a5,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80041460:	00f51363          	bne	a0,a5,80041466 <z_priq_dumb_best+0x8>
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *t = NULL;
80041464:	4781                	li	a5,0

	if (n != NULL) {
		t = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return t;
}
80041466:	853e                	mv	a0,a5
80041468:	8082                	ret

8004146a <update_cache>:
{
8004146a:	1101                	addi	sp,sp,-32
8004146c:	cc22                	sw	s0,24(sp)
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
8004146e:	80042437          	lui	s0,0x80042
{
80041472:	ca26                	sw	s1,20(sp)
80041474:	84aa                	mv	s1,a0
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
80041476:	78c40513          	addi	a0,s0,1932 # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
8004147a:	02450513          	addi	a0,a0,36
{
8004147e:	ce06                	sw	ra,28(sp)
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
80041480:	3ff9                	jal	8004145e <z_priq_dumb_best>
	return th ? th : _current_cpu->idle_thread;
80041482:	78c40413          	addi	s0,s0,1932
80041486:	e111                	bnez	a0,8004148a <update_cache+0x20>
80041488:	4448                	lw	a0,12(s0)
	if (preempt_ok != 0) {
8004148a:	441c                	lw	a5,8(s0)
8004148c:	e08d                	bnez	s1,800414ae <update_cache+0x44>
	if (z_is_thread_prevented_from_running(_current)) {
8004148e:	00d7c703          	lbu	a4,13(a5)
80041492:	8b7d                	andi	a4,a4,31
80041494:	ef09                	bnez	a4,800414ae <update_cache+0x44>
	if (is_preempt(_current) || is_metairq(th)) {
80041496:	00e7d683          	lhu	a3,14(a5)
8004149a:	07f00713          	li	a4,127
8004149e:	00d77863          	bgeu	a4,a3,800414ae <update_cache+0x44>
		_kernel.ready_q.cache = _current;
800414a2:	d01c                	sw	a5,32(s0)
}
800414a4:	40f2                	lw	ra,28(sp)
800414a6:	4462                	lw	s0,24(sp)
800414a8:	44d2                	lw	s1,20(sp)
800414aa:	6105                	addi	sp,sp,32
800414ac:	8082                	ret
		if (th != _current) {
800414ae:	00f50563          	beq	a0,a5,800414b8 <update_cache+0x4e>
800414b2:	c62a                	sw	a0,12(sp)
			reset_time_slice();
800414b4:	35c1                	jal	80041374 <reset_time_slice>
800414b6:	4532                	lw	a0,12(sp)
		_kernel.ready_q.cache = th;
800414b8:	d008                	sw	a0,32(s0)
}
800414ba:	b7ed                	j	800414a4 <update_cache+0x3a>

800414bc <k_sched_unlock>:
{
800414bc:	1141                	addi	sp,sp,-16
800414be:	c422                	sw	s0,8(sp)
800414c0:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
800414c2:	4421                	li	s0,8
800414c4:	30043473          	csrrc	s0,mstatus,s0
		++_current->base.sched_locked;
800414c8:	800427b7          	lui	a5,0x80042
800414cc:	7947a703          	lw	a4,1940(a5) # 80042794 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042795>
		update_cache(1);
800414d0:	4505                	li	a0,1
	key = (mstatus & SOC_MSTATUS_IEN);
800414d2:	8821                	andi	s0,s0,8
		++_current->base.sched_locked;
800414d4:	00f74783          	lbu	a5,15(a4)
800414d8:	0785                	addi	a5,a5,1
800414da:	00f707a3          	sb	a5,15(a4)
		update_cache(1);
800414de:	3771                	jal	8004146a <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
800414e0:	30042473          	csrrs	s0,mstatus,s0
}
800414e4:	4422                	lw	s0,8(sp)
800414e6:	40b2                	lw	ra,12(sp)
800414e8:	0141                	addi	sp,sp,16
	z_reschedule_unlocked();
800414ea:	b7a9                	j	80041434 <z_reschedule_unlocked>

800414ec <z_add_thread_to_ready_q>:
{
800414ec:	1141                	addi	sp,sp,-16
800414ee:	c422                	sw	s0,8(sp)
800414f0:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
800414f2:	4421                	li	s0,8
800414f4:	30043473          	csrrc	s0,mstatus,s0
	return list->head == list;
800414f8:	80042737          	lui	a4,0x80042
800414fc:	78c70793          	addi	a5,a4,1932 # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
80041500:	53dc                	lw	a5,36(a5)
80041502:	800426b7          	lui	a3,0x80042
80041506:	7b068693          	addi	a3,a3,1968 # 800427b0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800427b1>
	key = (mstatus & SOC_MSTATUS_IEN);
8004150a:	8821                	andi	s0,s0,8
8004150c:	78c70713          	addi	a4,a4,1932
	return sys_dlist_is_empty(list) ? NULL : list->head;
80041510:	04d78163          	beq	a5,a3,80041552 <z_add_thread_to_ready_q+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80041514:	cf9d                	beqz	a5,80041552 <z_add_thread_to_ready_q+0x66>
80041516:	570c                	lw	a1,40(a4)
	if (t1->base.prio < t2->base.prio) {
80041518:	00e50603          	lb	a2,14(a0)
8004151c:	00e78803          	lb	a6,14(a5)
80041520:	03065563          	bge	a2,a6,8004154a <z_add_thread_to_ready_q+0x5e>
	node->prev = successor->prev;
80041524:	43d8                	lw	a4,4(a5)
	node->next = successor;
80041526:	c11c                	sw	a5,0(a0)
	node->prev = successor->prev;
80041528:	c158                	sw	a4,4(a0)
	successor->prev->next = node;
8004152a:	c308                	sw	a0,0(a4)
	successor->prev = node;
8004152c:	c3c8                	sw	a0,4(a5)
	thread->base.thread_state |= states;
8004152e:	00d54783          	lbu	a5,13(a0)
80041532:	0407e793          	ori	a5,a5,64
80041536:	00f506a3          	sb	a5,13(a0)
		update_cache(0);
8004153a:	4501                	li	a0,0
8004153c:	373d                	jal	8004146a <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004153e:	30042473          	csrrs	s0,mstatus,s0
}
80041542:	40b2                	lw	ra,12(sp)
80041544:	4422                	lw	s0,8(sp)
80041546:	0141                	addi	sp,sp,16
80041548:	8082                	ret
	return (node == list->tail) ? NULL : node->next;
8004154a:	00b78463          	beq	a5,a1,80041552 <z_add_thread_to_ready_q+0x66>
8004154e:	439c                	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80041550:	f7f1                	bnez	a5,8004151c <z_add_thread_to_ready_q+0x30>
	node->prev = list->tail;
80041552:	571c                	lw	a5,40(a4)
	node->next = list;
80041554:	c114                	sw	a3,0(a0)
	node->prev = list->tail;
80041556:	c15c                	sw	a5,4(a0)
	list->tail->next = node;
80041558:	571c                	lw	a5,40(a4)
8004155a:	c388                	sw	a0,0(a5)
	list->tail = node;
8004155c:	d708                	sw	a0,40(a4)
8004155e:	bfc1                	j	8004152e <z_add_thread_to_ready_q+0x42>

80041560 <z_thread_timeout>:
	if (th->base.pended_on != NULL) {
80041560:	ff052783          	lw	a5,-16(a0)
{
80041564:	1141                	addi	sp,sp,-16
80041566:	c422                	sw	s0,8(sp)
80041568:	c04a                	sw	s2,0(sp)
8004156a:	c606                	sw	ra,12(sp)
8004156c:	c226                	sw	s1,4(sp)
8004156e:	842a                	mv	s0,a0
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
80041570:	fe850913          	addi	s2,a0,-24
	if (th->base.pended_on != NULL) {
80041574:	c385                	beqz	a5,80041594 <z_thread_timeout+0x34>
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041576:	44a1                	li	s1,8
80041578:	3004b4f3          	csrrc	s1,mstatus,s1
	sys_dlist_remove(&thread->base.qnode_dlist);
8004157c:	854a                	mv	a0,s2
8004157e:	3bc1                	jal	8004134e <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
80041580:	ff544783          	lbu	a5,-11(s0)
	key = (mstatus & SOC_MSTATUS_IEN);
80041584:	88a1                	andi	s1,s1,8
80041586:	9bf5                	andi	a5,a5,-3
80041588:	fef40aa3          	sb	a5,-11(s0)
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004158c:	3004a4f3          	csrrs	s1,mstatus,s1
	thread->base.pended_on = NULL;
80041590:	fe042823          	sw	zero,-16(s0)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
80041594:	ff544783          	lbu	a5,-11(s0)
	if (z_is_thread_ready(thread)) {
80041598:	854a                	mv	a0,s2
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
8004159a:	9bad                	andi	a5,a5,-21
8004159c:	fef40aa3          	sb	a5,-11(s0)
	if (z_is_thread_ready(thread)) {
800415a0:	33c1                	jal	80041360 <z_is_thread_ready>
800415a2:	c901                	beqz	a0,800415b2 <z_thread_timeout+0x52>
}
800415a4:	4422                	lw	s0,8(sp)
800415a6:	40b2                	lw	ra,12(sp)
800415a8:	4492                	lw	s1,4(sp)
		z_add_thread_to_ready_q(thread);
800415aa:	854a                	mv	a0,s2
800415ac:	4902                	lw	s2,0(sp)
800415ae:	0141                	addi	sp,sp,16
800415b0:	bf35                	j	800414ec <z_add_thread_to_ready_q>
800415b2:	40b2                	lw	ra,12(sp)
800415b4:	4422                	lw	s0,8(sp)
800415b6:	4492                	lw	s1,4(sp)
800415b8:	4902                	lw	s2,0(sp)
800415ba:	0141                	addi	sp,sp,16
800415bc:	8082                	ret

800415be <z_move_thread_to_end_of_prio_q>:
{
800415be:	1141                	addi	sp,sp,-16
800415c0:	c422                	sw	s0,8(sp)
800415c2:	c226                	sw	s1,4(sp)
800415c4:	c606                	sw	ra,12(sp)
800415c6:	842a                	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
800415c8:	44a1                	li	s1,8
800415ca:	3004b4f3          	csrrc	s1,mstatus,s1
	sys_dlist_remove(&thread->base.qnode_dlist);
800415ce:	3341                	jal	8004134e <sys_dlist_remove>
	return list->head == list;
800415d0:	80042737          	lui	a4,0x80042
800415d4:	78c70793          	addi	a5,a4,1932 # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
800415d8:	53dc                	lw	a5,36(a5)
800415da:	800426b7          	lui	a3,0x80042
800415de:	7b068693          	addi	a3,a3,1968 # 800427b0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800427b1>
	key = (mstatus & SOC_MSTATUS_IEN);
800415e2:	88a1                	andi	s1,s1,8
800415e4:	78c70713          	addi	a4,a4,1932
	return sys_dlist_is_empty(list) ? NULL : list->head;
800415e8:	04d78563          	beq	a5,a3,80041632 <z_move_thread_to_end_of_prio_q+0x74>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
800415ec:	c3b9                	beqz	a5,80041632 <z_move_thread_to_end_of_prio_q+0x74>
800415ee:	570c                	lw	a1,40(a4)
	if (t1->base.prio < t2->base.prio) {
800415f0:	00e40603          	lb	a2,14(s0)
800415f4:	00e78503          	lb	a0,14(a5)
800415f8:	02a65963          	bge	a2,a0,8004162a <z_move_thread_to_end_of_prio_q+0x6c>
	node->prev = successor->prev;
800415fc:	43d4                	lw	a3,4(a5)
	node->next = successor;
800415fe:	c01c                	sw	a5,0(s0)
	node->prev = successor->prev;
80041600:	c054                	sw	a3,4(s0)
	successor->prev->next = node;
80041602:	c280                	sw	s0,0(a3)
	successor->prev = node;
80041604:	c3c0                	sw	s0,4(a5)
	thread->base.thread_state |= states;
80041606:	00d44783          	lbu	a5,13(s0)
		update_cache(thread == _current);
8004160a:	4708                	lw	a0,8(a4)
8004160c:	0407e793          	ori	a5,a5,64
80041610:	8d01                	sub	a0,a0,s0
80041612:	00f406a3          	sb	a5,13(s0)
80041616:	00153513          	seqz	a0,a0
8004161a:	3d81                	jal	8004146a <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004161c:	3004a4f3          	csrrs	s1,mstatus,s1
}
80041620:	40b2                	lw	ra,12(sp)
80041622:	4422                	lw	s0,8(sp)
80041624:	4492                	lw	s1,4(sp)
80041626:	0141                	addi	sp,sp,16
80041628:	8082                	ret
	return (node == list->tail) ? NULL : node->next;
8004162a:	00b78463          	beq	a5,a1,80041632 <z_move_thread_to_end_of_prio_q+0x74>
8004162e:	439c                	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80041630:	f3f1                	bnez	a5,800415f4 <z_move_thread_to_end_of_prio_q+0x36>
	node->prev = list->tail;
80041632:	571c                	lw	a5,40(a4)
	node->next = list;
80041634:	c014                	sw	a3,0(s0)
	node->prev = list->tail;
80041636:	c05c                	sw	a5,4(s0)
	list->tail->next = node;
80041638:	571c                	lw	a5,40(a4)
8004163a:	c380                	sw	s0,0(a5)
	list->tail = node;
8004163c:	d700                	sw	s0,40(a4)
8004163e:	b7e1                	j	80041606 <z_move_thread_to_end_of_prio_q+0x48>

80041640 <z_time_slice>:
	if (slice_time && sliceable(_current)) {
80041640:	800427b7          	lui	a5,0x80042
80041644:	5c07a783          	lw	a5,1472(a5) # 800425c0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425c1>
80041648:	cba1                	beqz	a5,80041698 <z_time_slice+0x58>
8004164a:	800427b7          	lui	a5,0x80042
8004164e:	78c78793          	addi	a5,a5,1932 # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
80041652:	4798                	lw	a4,8(a5)
		&& !z_is_thread_timeout_active(t);
80041654:	07f00693          	li	a3,127
80041658:	00e75603          	lhu	a2,14(a4)
8004165c:	02c6ee63          	bltu	a3,a2,80041698 <z_time_slice+0x58>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
80041660:	800426b7          	lui	a3,0x80042
80041664:	00e70603          	lb	a2,14(a4)
80041668:	5bc6a683          	lw	a3,1468(a3) # 800425bc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425bd>
8004166c:	02d64663          	blt	a2,a3,80041698 <z_time_slice+0x58>
	return thread == _idle_thread;
80041670:	800426b7          	lui	a3,0x80042
		&& !is_idle(t)
80041674:	5086a683          	lw	a3,1288(a3) # 80042508 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042509>
80041678:	02d70063          	beq	a4,a3,80041698 <z_time_slice+0x58>
		&& !z_is_thread_timeout_active(t);
8004167c:	4f14                	lw	a3,24(a4)
8004167e:	ee89                	bnez	a3,80041698 <z_time_slice+0x58>
		if (ticks >= _current_cpu->slice_ticks) {
80041680:	4b94                	lw	a3,16(a5)
80041682:	00d54963          	blt	a0,a3,80041694 <z_time_slice+0x54>
{
80041686:	1141                	addi	sp,sp,-16
			z_move_thread_to_end_of_prio_q(_current);
80041688:	853a                	mv	a0,a4
{
8004168a:	c606                	sw	ra,12(sp)
			z_move_thread_to_end_of_prio_q(_current);
8004168c:	3f0d                	jal	800415be <z_move_thread_to_end_of_prio_q>
}
8004168e:	40b2                	lw	ra,12(sp)
80041690:	0141                	addi	sp,sp,16
			reset_time_slice();
80041692:	b1cd                	j	80041374 <reset_time_slice>
			_current_cpu->slice_ticks -= ticks;
80041694:	8e89                	sub	a3,a3,a0
80041696:	cb94                	sw	a3,16(a5)
80041698:	8082                	ret

8004169a <z_remove_thread_from_ready_q>:
{
8004169a:	1141                	addi	sp,sp,-16
8004169c:	c422                	sw	s0,8(sp)
8004169e:	c226                	sw	s1,4(sp)
800416a0:	c606                	sw	ra,12(sp)
800416a2:	84aa                	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
800416a4:	4421                	li	s0,8
800416a6:	30043473          	csrrc	s0,mstatus,s0
		if (z_is_thread_queued(thread)) {
800416aa:	00d54783          	lbu	a5,13(a0)
	key = (mstatus & SOC_MSTATUS_IEN);
800416ae:	8821                	andi	s0,s0,8
800416b0:	0407f793          	andi	a5,a5,64
800416b4:	cb81                	beqz	a5,800416c4 <z_remove_thread_from_ready_q+0x2a>
	sys_dlist_remove(&thread->base.qnode_dlist);
800416b6:	3961                	jal	8004134e <sys_dlist_remove>
	thread->base.thread_state &= ~states;
800416b8:	00d4c783          	lbu	a5,13(s1)
800416bc:	fbf7f793          	andi	a5,a5,-65
800416c0:	00f486a3          	sb	a5,13(s1)
		update_cache(thread == _current);
800416c4:	800427b7          	lui	a5,0x80042
800416c8:	7947a503          	lw	a0,1940(a5) # 80042794 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042795>
800416cc:	8d05                	sub	a0,a0,s1
800416ce:	00153513          	seqz	a0,a0
800416d2:	3b61                	jal	8004146a <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
800416d4:	30042473          	csrrs	s0,mstatus,s0
}
800416d8:	40b2                	lw	ra,12(sp)
800416da:	4422                	lw	s0,8(sp)
800416dc:	4492                	lw	s1,4(sp)
800416de:	0141                	addi	sp,sp,16
800416e0:	8082                	ret

800416e2 <pend>:
{
800416e2:	1101                	addi	sp,sp,-32
800416e4:	cc22                	sw	s0,24(sp)
800416e6:	c62e                	sw	a1,12(sp)
800416e8:	842a                	mv	s0,a0
800416ea:	c432                	sw	a2,8(sp)
800416ec:	ce06                	sw	ra,28(sp)
	z_remove_thread_from_ready_q(thread);
800416ee:	3775                	jal	8004169a <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
800416f0:	00d44783          	lbu	a5,13(s0)
	if (wait_q != NULL) {
800416f4:	45b2                	lw	a1,12(sp)
800416f6:	4622                	lw	a2,8(sp)
800416f8:	0027e793          	ori	a5,a5,2
800416fc:	00f406a3          	sb	a5,13(s0)
80041700:	c18d                	beqz	a1,80041722 <pend+0x40>
	return list->head == list;
80041702:	419c                	lw	a5,0(a1)
		thread->base.pended_on = wait_q;
80041704:	c40c                	sw	a1,8(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80041706:	04f58563          	beq	a1,a5,80041750 <pend+0x6e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
8004170a:	c3b9                	beqz	a5,80041750 <pend+0x6e>
	if (t1->base.prio < t2->base.prio) {
8004170c:	00e40703          	lb	a4,14(s0)
80041710:	00e78683          	lb	a3,14(a5)
80041714:	02d75963          	bge	a4,a3,80041746 <pend+0x64>
	node->prev = successor->prev;
80041718:	43d8                	lw	a4,4(a5)
	node->next = successor;
8004171a:	c01c                	sw	a5,0(s0)
	node->prev = successor->prev;
8004171c:	c058                	sw	a4,4(s0)
	successor->prev->next = node;
8004171e:	c300                	sw	s0,0(a4)
	successor->prev = node;
80041720:	c3c0                	sw	s0,4(a5)
	if (timeout != K_FOREVER) {
80041722:	57fd                	li	a5,-1
80041724:	02f60d63          	beq	a2,a5,8004175e <pend+0x7c>
80041728:	0625                	addi	a2,a2,9
8004172a:	47a9                	li	a5,10
8004172c:	02f64633          	div	a2,a2,a5

extern void z_thread_timeout(struct _timeout *to);

static inline void z_add_thread_timeout(struct k_thread *th, s32_t ticks)
{
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
80041730:	01840513          	addi	a0,s0,24
}
80041734:	4462                	lw	s0,24(sp)
80041736:	40f2                	lw	ra,28(sp)
80041738:	800415b7          	lui	a1,0x80041
8004173c:	56058593          	addi	a1,a1,1376 # 80041560 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041561>
80041740:	6105                	addi	sp,sp,32
80041742:	0605                	addi	a2,a2,1
80041744:	a9dd                	j	80041c3a <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
80041746:	41d4                	lw	a3,4(a1)
80041748:	00d78463          	beq	a5,a3,80041750 <pend+0x6e>
8004174c:	439c                	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
8004174e:	f3e9                	bnez	a5,80041710 <pend+0x2e>
	node->prev = list->tail;
80041750:	41dc                	lw	a5,4(a1)
	node->next = list;
80041752:	c00c                	sw	a1,0(s0)
	node->prev = list->tail;
80041754:	c05c                	sw	a5,4(s0)
	list->tail->next = node;
80041756:	41dc                	lw	a5,4(a1)
80041758:	c380                	sw	s0,0(a5)
	list->tail = node;
8004175a:	c1c0                	sw	s0,4(a1)
8004175c:	b7d9                	j	80041722 <pend+0x40>
}
8004175e:	40f2                	lw	ra,28(sp)
80041760:	4462                	lw	s0,24(sp)
80041762:	6105                	addi	sp,sp,32
80041764:	8082                	ret

80041766 <z_pend_curr>:
	pend(_current, wait_q, timeout);
80041766:	800427b7          	lui	a5,0x80042
8004176a:	7947a503          	lw	a0,1940(a5) # 80042794 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042795>
{
8004176e:	1141                	addi	sp,sp,-16
80041770:	c422                	sw	s0,8(sp)
80041772:	842e                	mv	s0,a1
80041774:	85b2                	mv	a1,a2
	pend(_current, wait_q, timeout);
80041776:	8636                	mv	a2,a3
{
80041778:	c606                	sw	ra,12(sp)
	pend(_current, wait_q, timeout);
8004177a:	37a5                	jal	800416e2 <pend>
8004177c:	8522                	mv	a0,s0
}
8004177e:	4422                	lw	s0,8(sp)
80041780:	40b2                	lw	ra,12(sp)
80041782:	0141                	addi	sp,sp,16
80041784:	a3dfe06f          	j	800401c0 <__swap>

80041788 <z_unpend_first_thread>:
{
80041788:	1141                	addi	sp,sp,-16
8004178a:	c422                	sw	s0,8(sp)
8004178c:	c606                	sw	ra,12(sp)
8004178e:	c226                	sw	s1,4(sp)
80041790:	c04a                	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041792:	4421                	li	s0,8
80041794:	30043973          	csrrc	s2,mstatus,s0
		ret = _priq_wait_best(&wait_q->waitq);
80041798:	31d9                	jal	8004145e <z_priq_dumb_best>
8004179a:	84aa                	mv	s1,a0
	key = (mstatus & SOC_MSTATUS_IEN);
8004179c:	00897793          	andi	a5,s2,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
800417a0:	3007a7f3          	csrrs	a5,mstatus,a5

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
800417a4:	c10d                	beqz	a0,800417c6 <z_unpend_first_thread+0x3e>
	__asm__ volatile ("csrrc %0, mstatus, %1"
800417a6:	30043473          	csrrc	s0,mstatus,s0
	sys_dlist_remove(&thread->base.qnode_dlist);
800417aa:	3655                	jal	8004134e <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
800417ac:	00d4c783          	lbu	a5,13(s1)
	key = (mstatus & SOC_MSTATUS_IEN);
800417b0:	8821                	andi	s0,s0,8
800417b2:	9bf5                	andi	a5,a5,-3
800417b4:	00f486a3          	sb	a5,13(s1)
	__asm__ volatile ("csrrs %0, mstatus, %1"
800417b8:	30042473          	csrrs	s0,mstatus,s0
	thread->base.pended_on = NULL;
800417bc:	0004a423          	sw	zero,8(s1)
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
800417c0:	01848513          	addi	a0,s1,24
800417c4:	2301                	jal	80041cc4 <z_abort_timeout>
}
800417c6:	40b2                	lw	ra,12(sp)
800417c8:	4422                	lw	s0,8(sp)
800417ca:	8526                	mv	a0,s1
800417cc:	4902                	lw	s2,0(sp)
800417ce:	4492                	lw	s1,4(sp)
800417d0:	0141                	addi	sp,sp,16
800417d2:	8082                	ret

800417d4 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
800417d4:	800427b7          	lui	a5,0x80042
800417d8:	78c78793          	addi	a5,a5,1932 # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
800417dc:	02478713          	addi	a4,a5,36
800417e0:	d3d8                	sw	a4,36(a5)
	list->tail = (sys_dnode_t *)list;
800417e2:	d798                	sw	a4,40(a5)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
800417e4:	4581                	li	a1,0
800417e6:	4501                	li	a0,0
800417e8:	be45                	j	80041398 <k_sched_time_slice_set>

800417ea <z_impl_k_yield>:
}
#endif
#endif

void z_impl_k_yield(void)
{
800417ea:	1141                	addi	sp,sp,-16
800417ec:	c422                	sw	s0,8(sp)
	__ASSERT(!z_is_in_isr(), "");

	if (!is_idle(_current)) {
800417ee:	80042437          	lui	s0,0x80042
800417f2:	78c40793          	addi	a5,s0,1932 # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
800417f6:	4798                	lw	a4,8(a5)
800417f8:	800427b7          	lui	a5,0x80042
800417fc:	5087a783          	lw	a5,1288(a5) # 80042508 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042509>
{
80041800:	c606                	sw	ra,12(sp)
80041802:	c226                	sw	s1,4(sp)
	if (!is_idle(_current)) {
80041804:	04f70363          	beq	a4,a5,8004184a <z_impl_k_yield+0x60>
80041808:	78c40413          	addi	s0,s0,1932
	__asm__ volatile ("csrrc %0, mstatus, %1"
8004180c:	44a1                	li	s1,8
8004180e:	3004b4f3          	csrrc	s1,mstatus,s1
	sys_dlist_remove(&thread->base.qnode_dlist);
80041812:	4408                	lw	a0,8(s0)
	key = (mstatus & SOC_MSTATUS_IEN);
80041814:	88a1                	andi	s1,s1,8
80041816:	3e25                	jal	8004134e <sys_dlist_remove>
	return list->head == list;
80041818:	505c                	lw	a5,36(s0)
8004181a:	800426b7          	lui	a3,0x80042
8004181e:	7b068693          	addi	a3,a3,1968 # 800427b0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800427b1>
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
						 _current);
				_priq_run_add(&_kernel.ready_q.runq,
80041822:	4418                	lw	a4,8(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80041824:	04d78163          	beq	a5,a3,80041866 <z_impl_k_yield+0x7c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80041828:	cf9d                	beqz	a5,80041866 <z_impl_k_yield+0x7c>
8004182a:	5410                	lw	a2,40(s0)
	if (t1->base.prio < t2->base.prio) {
8004182c:	00e70583          	lb	a1,14(a4)
80041830:	00e78503          	lb	a0,14(a5)
80041834:	02a5d563          	bge	a1,a0,8004185e <z_impl_k_yield+0x74>
	node->prev = successor->prev;
80041838:	43d4                	lw	a3,4(a5)
	node->next = successor;
8004183a:	c31c                	sw	a5,0(a4)
	node->prev = successor->prev;
8004183c:	c354                	sw	a3,4(a4)
	successor->prev->next = node;
8004183e:	c298                	sw	a4,0(a3)
	successor->prev = node;
80041840:	c3d8                	sw	a4,4(a5)
					      _current);
			}
			update_cache(1);
80041842:	4505                	li	a0,1
80041844:	311d                	jal	8004146a <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041846:	3004a4f3          	csrrs	s1,mstatus,s1
	__asm__ volatile ("csrrc %0, mstatus, %1"
8004184a:	4521                	li	a0,8
8004184c:	30053573          	csrrc	a0,mstatus,a0
		}
	}
	z_swap_unlocked();
}
80041850:	4422                	lw	s0,8(sp)
80041852:	40b2                	lw	ra,12(sp)
80041854:	4492                	lw	s1,4(sp)
80041856:	8921                	andi	a0,a0,8
80041858:	0141                	addi	sp,sp,16
8004185a:	967fe06f          	j	800401c0 <__swap>
	return (node == list->tail) ? NULL : node->next;
8004185e:	00f60463          	beq	a2,a5,80041866 <z_impl_k_yield+0x7c>
80041862:	439c                	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80041864:	f7f1                	bnez	a5,80041830 <z_impl_k_yield+0x46>
	node->prev = list->tail;
80041866:	541c                	lw	a5,40(s0)
	node->next = list;
80041868:	c314                	sw	a3,0(a4)
	node->prev = list->tail;
8004186a:	c35c                	sw	a5,4(a4)
	list->tail->next = node;
8004186c:	541c                	lw	a5,40(s0)
8004186e:	c398                	sw	a4,0(a5)
	list->tail = node;
80041870:	d418                	sw	a4,40(s0)
80041872:	bfc1                	j	80041842 <z_impl_k_yield+0x58>

80041874 <z_impl_k_sleep>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER0_SIMPLE_VOID(k_yield);
#endif

s32_t z_impl_k_sleep(s32_t duration)
{
80041874:	7179                	addi	sp,sp,-48
80041876:	d606                	sw	ra,44(sp)
80041878:	d422                	sw	s0,40(sp)
8004187a:	d226                	sw	s1,36(sp)
8004187c:	d04a                	sw	s2,32(sp)
8004187e:	ce4e                	sw	s3,28(sp)
	__ASSERT(!z_is_in_isr(), "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
80041880:	e919                	bnez	a0,80041896 <z_impl_k_sleep+0x22>
80041882:	c62a                	sw	a0,12(sp)
K_SYSCALL_DECLARE0_VOID(K_SYSCALL_K_YIELD, k_yield)
80041884:	379d                	jal	800417ea <z_impl_k_yield>
		k_yield();
		return 0;
80041886:	4532                	lw	a0,12(sp)
		return __ticks_to_ms(ticks);
	}
#endif

	return 0;
}
80041888:	50b2                	lw	ra,44(sp)
8004188a:	5422                	lw	s0,40(sp)
8004188c:	5492                	lw	s1,36(sp)
8004188e:	5902                	lw	s2,32(sp)
80041890:	49f2                	lw	s3,28(sp)
80041892:	6145                	addi	sp,sp,48
80041894:	8082                	ret
80041896:	00950413          	addi	s0,a0,9
8004189a:	4529                	li	a0,10
8004189c:	02a44433          	div	s0,s0,a0
	expected_wakeup_time = ticks + z_tick_get_32();
800418a0:	2b71                	jal	80041e3c <z_tick_get_32>
800418a2:	49a1                	li	s3,8
	ticks = _TICK_ALIGN + z_ms_to_ticks(duration);
800418a4:	0405                	addi	s0,s0,1
	expected_wakeup_time = ticks + z_tick_get_32();
800418a6:	00a404b3          	add	s1,s0,a0
800418aa:	3009b9f3          	csrrc	s3,mstatus,s3
	z_remove_thread_from_ready_q(_current);
800418ae:	80042937          	lui	s2,0x80042
800418b2:	78c90913          	addi	s2,s2,1932 # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
800418b6:	00892503          	lw	a0,8(s2)
800418ba:	33c5                	jal	8004169a <z_remove_thread_from_ready_q>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
800418bc:	00892503          	lw	a0,8(s2)
800418c0:	800415b7          	lui	a1,0x80041
800418c4:	8622                	mv	a2,s0
800418c6:	56058593          	addi	a1,a1,1376 # 80041560 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041561>
800418ca:	0561                	addi	a0,a0,24
800418cc:	26bd                	jal	80041c3a <z_add_timeout>
	z_mark_thread_as_suspended(_current);
800418ce:	00892703          	lw	a4,8(s2)
800418d2:	0089f513          	andi	a0,s3,8
	thread->base.thread_state |= _THREAD_SUSPENDED;
800418d6:	00d74783          	lbu	a5,13(a4)
800418da:	0107e793          	ori	a5,a5,16
800418de:	00f706a3          	sb	a5,13(a4)
800418e2:	8dffe0ef          	jal	ra,800401c0 <__swap>
	ticks = expected_wakeup_time - z_tick_get_32();
800418e6:	2b99                	jal	80041e3c <z_tick_get_32>
800418e8:	8c89                	sub	s1,s1,a0
	return 0;
800418ea:	4501                	li	a0,0
	if (ticks > 0) {
800418ec:	f8905ee3          	blez	s1,80041888 <z_impl_k_sleep+0x14>
#ifdef _NEED_PRECISE_TICK_MS_CONVERSION
	/* use 64-bit math to keep precision */
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
#else
	/* simple multiplication keeps precision */
	return (u64_t)ticks * MSEC_PER_SEC / (u64_t)CONFIG_SYS_CLOCK_TICKS_PER_SEC;
800418f0:	3e800513          	li	a0,1000
800418f4:	02a495b3          	mulh	a1,s1,a0
800418f8:	06400613          	li	a2,100
800418fc:	4681                	li	a3,0
800418fe:	02a48533          	mul	a0,s1,a0
80041902:	947fe0ef          	jal	ra,80040248 <__udivdi3>
		return __ticks_to_ms(ticks);
80041906:	b749                	j	80041888 <z_impl_k_sleep+0x14>

80041908 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
80041908:	800427b7          	lui	a5,0x80042
8004190c:	7947a503          	lw	a0,1940(a5) # 80042794 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042795>
80041910:	8082                	ret

80041912 <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
80041912:	1141                	addi	sp,sp,-16
80041914:	c422                	sw	s0,8(sp)
80041916:	c04a                	sw	s2,0(sp)
80041918:	c606                	sw	ra,12(sp)
8004191a:	c226                	sw	s1,4(sp)
8004191c:	892a                	mv	s2,a0
8004191e:	4421                	li	s0,8
80041920:	30043473          	csrrc	s0,mstatus,s0
	key = (mstatus & SOC_MSTATUS_IEN);
80041924:	8821                	andi	s0,s0,8
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
80041926:	358d                	jal	80041788 <z_unpend_first_thread>
	if (thread != NULL) {
80041928:	c515                	beqz	a0,80041954 <z_impl_k_sem_give+0x42>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
8004192a:	00d54783          	lbu	a5,13(a0)
8004192e:	84aa                	mv	s1,a0
80041930:	8bfd                	andi	a5,a5,31
80041932:	e781                	bnez	a5,8004193a <z_impl_k_sem_give+0x28>
	if (z_is_thread_ready(thread)) {
80041934:	4d1c                	lw	a5,24(a0)
80041936:	e391                	bnez	a5,8004193a <z_impl_k_sem_give+0x28>
		z_add_thread_to_ready_q(thread);
80041938:	3e55                	jal	800414ec <z_add_thread_to_ready_q>
}

static ALWAYS_INLINE void
z_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
8004193a:	0604a623          	sw	zero,108(s1)
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
8004193e:	85a2                	mv	a1,s0
}
80041940:	4422                	lw	s0,8(sp)
80041942:	40b2                	lw	ra,12(sp)
80041944:	4492                	lw	s1,4(sp)
80041946:	4902                	lw	s2,0(sp)
	z_reschedule(&lock, key);
80041948:	80042537          	lui	a0,0x80042
8004194c:	7b850513          	addi	a0,a0,1976 # 800427b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800427b9>
}
80041950:	0141                	addi	sp,sp,16
	z_reschedule(&lock, key);
80041952:	bc4d                	j	80041404 <z_reschedule>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
80041954:	00892703          	lw	a4,8(s2)
80041958:	00c92783          	lw	a5,12(s2)
8004195c:	8f99                	sub	a5,a5,a4
8004195e:	00f037b3          	snez	a5,a5
80041962:	97ba                	add	a5,a5,a4
80041964:	00f92423          	sw	a5,8(s2)
80041968:	bfd9                	j	8004193e <z_impl_k_sem_give+0x2c>

8004196a <z_impl_k_sem_take>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_sem_give, K_OBJ_SEM, struct k_sem *);
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
8004196a:	862a                	mv	a2,a0
8004196c:	86ae                	mv	a3,a1
	__asm__ volatile ("csrrc %0, mstatus, %1"
8004196e:	47a1                	li	a5,8
80041970:	3007b7f3          	csrrc	a5,mstatus,a5
	__ASSERT(((z_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
80041974:	4518                	lw	a4,8(a0)
	key = (mstatus & SOC_MSTATUS_IEN);
80041976:	0087f593          	andi	a1,a5,8
8004197a:	c719                	beqz	a4,80041988 <z_impl_k_sem_take+0x1e>
		sem->count--;
8004197c:	177d                	addi	a4,a4,-1
8004197e:	c518                	sw	a4,8(a0)
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041980:	3005a7f3          	csrrs	a5,mstatus,a1
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
80041984:	4501                	li	a0,0
80041986:	8082                	ret
	}

	if (timeout == K_NO_WAIT) {
80041988:	e689                	bnez	a3,80041992 <z_impl_k_sem_take+0x28>
8004198a:	3005a7f3          	csrrs	a5,mstatus,a1
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return -EBUSY;
8004198e:	5541                	li	a0,-16

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
	return ret;
}
80041990:	8082                	ret
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
80041992:	80042537          	lui	a0,0x80042
80041996:	7b850513          	addi	a0,a0,1976 # 800427b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800427b9>
8004199a:	b3f1                	j	80041766 <z_pend_curr>

8004199c <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
8004199c:	00d54783          	lbu	a5,13(a0)
800419a0:	8bfd                	andi	a5,a5,31
800419a2:	e789                	bnez	a5,800419ac <z_is_thread_ready+0x10>
800419a4:	4d08                	lw	a0,24(a0)
800419a6:	00153513          	seqz	a0,a0
800419aa:	8082                	ret
800419ac:	4501                	li	a0,0
}
800419ae:	8082                	ret

800419b0 <k_is_in_isr>:
#endif
}

bool k_is_in_isr(void)
{
	return z_is_in_isr();
800419b0:	800427b7          	lui	a5,0x80042
800419b4:	78c7a503          	lw	a0,1932(a5) # 8004278c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004278d>
}
800419b8:	00a03533          	snez	a0,a0
800419bc:	8082                	ret

800419be <z_is_thread_essential>:
 *
 * Returns true if current thread is essential, false if it is not.
 */
bool z_is_thread_essential(void)
{
	return (_current->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
800419be:	800427b7          	lui	a5,0x80042
800419c2:	7947a783          	lw	a5,1940(a5) # 80042794 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042795>
800419c6:	00c7c503          	lbu	a0,12(a5)
}
800419ca:	8905                	andi	a0,a0,1
800419cc:	8082                	ret

800419ce <z_impl_k_thread_name_set>:
#else
	ARG_UNUSED(thread);
	ARG_UNUSED(value);
	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
800419ce:	fb900513          	li	a0,-71
800419d2:	8082                	ret

800419d4 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
800419d4:	4501                	li	a0,0
800419d6:	8082                	ret

800419d8 <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
800419d8:	1141                	addi	sp,sp,-16
800419da:	c422                	sw	s0,8(sp)
800419dc:	c606                	sw	ra,12(sp)
800419de:	c226                	sw	s1,4(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
800419e0:	4421                	li	s0,8
800419e2:	30043473          	csrrc	s0,mstatus,s0
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
800419e6:	00d54783          	lbu	a5,13(a0)
	key = (mstatus & SOC_MSTATUS_IEN);
800419ea:	8821                	andi	s0,s0,8
800419ec:	0047f713          	andi	a4,a5,4
800419f0:	eb01                	bnez	a4,80041a00 <z_impl_k_thread_start+0x28>
	__asm__ volatile ("csrrs %0, mstatus, %1"
800419f2:	30042473          	csrrs	s0,mstatus,s0
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
800419f6:	40b2                	lw	ra,12(sp)
800419f8:	4422                	lw	s0,8(sp)
800419fa:	4492                	lw	s1,4(sp)
800419fc:	0141                	addi	sp,sp,16
800419fe:	8082                	ret
	thread->base.thread_state &= ~_THREAD_PRESTART;
80041a00:	9bed                	andi	a5,a5,-5
80041a02:	00f506a3          	sb	a5,13(a0)
80041a06:	84aa                	mv	s1,a0
	if (z_is_thread_ready(thread)) {
80041a08:	3f51                	jal	8004199c <z_is_thread_ready>
80041a0a:	c119                	beqz	a0,80041a10 <z_impl_k_thread_start+0x38>
		z_add_thread_to_ready_q(thread);
80041a0c:	8526                	mv	a0,s1
80041a0e:	3cf9                	jal	800414ec <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
80041a10:	85a2                	mv	a1,s0
}
80041a12:	4422                	lw	s0,8(sp)
80041a14:	40b2                	lw	ra,12(sp)
80041a16:	4492                	lw	s1,4(sp)
	z_reschedule(&lock, key);
80041a18:	80042537          	lui	a0,0x80042
80041a1c:	7b850513          	addi	a0,a0,1976 # 800427b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800427b9>
}
80041a20:	0141                	addi	sp,sp,16
	z_reschedule(&lock, key);
80041a22:	9e3ff06f          	j	80041404 <z_reschedule>

80041a26 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
80041a26:	1101                	addi	sp,sp,-32
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80041a28:	5302                	lw	t1,32(sp)
{
80041a2a:	cc22                	sw	s0,24(sp)
80041a2c:	ce06                	sw	ra,28(sp)
	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80041a2e:	c01a                	sw	t1,0(sp)
{
80041a30:	842a                	mv	s0,a0
	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80041a32:	ebbfe0ef          	jal	ra,800408ec <z_new_thread>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
80041a36:	800427b7          	lui	a5,0x80042
80041a3a:	7947a783          	lw	a5,1940(a5) # 80042794 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80042795>
	sys_trace_thread_create(new_thread);
}
80041a3e:	40f2                	lw	ra,28(sp)
	new_thread->resource_pool = _current->resource_pool;
80041a40:	57bc                	lw	a5,104(a5)
80041a42:	d43c                	sw	a5,104(s0)
}
80041a44:	4462                	lw	s0,24(sp)
80041a46:	6105                	addi	sp,sp,32
80041a48:	8082                	ret

80041a4a <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, s32_t delay)
{
80041a4a:	1101                	addi	sp,sp,-32
#if defined(CONFIG_TEST) && defined(CONFIG_ARCH_HAS_USERSPACE) && !defined(CONFIG_USERSPACE)
	__ASSERT((options & K_USER) == 0,
		 "Platform is capable of user mode, and test thread created with K_USER option, but CONFIG_TEST_USERSPACE or CONFIG_USERSPACE is not set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80041a4c:	5302                	lw	t1,32(sp)
{
80041a4e:	cc22                	sw	s0,24(sp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80041a50:	c202                	sw	zero,4(sp)
{
80041a52:	5412                	lw	s0,36(sp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80041a54:	c01a                	sw	t1,0(sp)
{
80041a56:	ca26                	sw	s1,20(sp)
80041a58:	ce06                	sw	ra,28(sp)
80041a5a:	84aa                	mv	s1,a0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80041a5c:	37e9                	jal	80041a26 <z_setup_new_thread>
			  prio, options, NULL);

	if (delay != K_FOREVER) {
80041a5e:	57fd                	li	a5,-1
80041a60:	00f40563          	beq	s0,a5,80041a6a <z_impl_k_thread_create+0x20>
	if (delay == 0) {
80041a64:	e809                	bnez	s0,80041a76 <z_impl_k_thread_create+0x2c>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)
80041a66:	8526                	mv	a0,s1
80041a68:	3f85                	jal	800419d8 <z_impl_k_thread_start>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
80041a6a:	40f2                	lw	ra,28(sp)
80041a6c:	4462                	lw	s0,24(sp)
80041a6e:	8526                	mv	a0,s1
80041a70:	44d2                	lw	s1,20(sp)
80041a72:	6105                	addi	sp,sp,32
80041a74:	8082                	ret
	return (s32_t)ceiling_fraction(ms, ms_per_tick);
80041a76:	0425                	addi	s0,s0,9
80041a78:	4629                	li	a2,10
80041a7a:	02c44633          	div	a2,s0,a2
80041a7e:	800415b7          	lui	a1,0x80041
80041a82:	56058593          	addi	a1,a1,1376 # 80041560 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041561>
80041a86:	01848513          	addi	a0,s1,24
80041a8a:	0605                	addi	a2,a2,1
80041a8c:	227d                	jal	80041c3a <z_add_timeout>
80041a8e:	bff1                	j	80041a6a <z_impl_k_thread_create+0x20>

80041a90 <z_thread_single_abort>:
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_thread_resume, K_OBJ_THREAD, k_tid_t);
#endif

void z_thread_single_abort(struct k_thread *thread)
{
	if (thread->fn_abort != NULL) {
80041a90:	513c                	lw	a5,96(a0)
{
80041a92:	1141                	addi	sp,sp,-16
80041a94:	c422                	sw	s0,8(sp)
80041a96:	c606                	sw	ra,12(sp)
80041a98:	842a                	mv	s0,a0
	if (thread->fn_abort != NULL) {
80041a9a:	c391                	beqz	a5,80041a9e <z_thread_single_abort+0xe>
		thread->fn_abort();
80041a9c:	9782                	jalr	a5

	if (IS_ENABLED(CONFIG_SMP)) {
		z_sched_abort(thread);
	}

	if (z_is_thread_ready(thread)) {
80041a9e:	8522                	mv	a0,s0
80041aa0:	3df5                	jal	8004199c <z_is_thread_ready>
80041aa2:	cd09                	beqz	a0,80041abc <z_thread_single_abort+0x2c>
		z_remove_thread_from_ready_q(thread);
80041aa4:	8522                	mv	a0,s0
80041aa6:	3ed5                	jal	8004169a <z_remove_thread_from_ready_q>
		if (z_is_thread_timeout_active(thread)) {
			(void)z_abort_thread_timeout(thread);
		}
	}

	thread->base.thread_state |= _THREAD_DEAD;
80041aa8:	00d44783          	lbu	a5,13(s0)
	z_object_uninit(thread);

	/* Revoke permissions on thread's ID so that it may be recycled */
	z_thread_perms_all_clear(thread);
#endif
}
80041aac:	40b2                	lw	ra,12(sp)
	thread->base.thread_state |= _THREAD_DEAD;
80041aae:	0087e793          	ori	a5,a5,8
80041ab2:	00f406a3          	sb	a5,13(s0)
}
80041ab6:	4422                	lw	s0,8(sp)
80041ab8:	0141                	addi	sp,sp,16
80041aba:	8082                	ret
		if (z_is_thread_pending(thread)) {
80041abc:	00d44783          	lbu	a5,13(s0)
80041ac0:	8b89                	andi	a5,a5,2
80041ac2:	c781                	beqz	a5,80041aca <z_thread_single_abort+0x3a>
			z_unpend_thread_no_timeout(thread);
80041ac4:	8522                	mv	a0,s0
80041ac6:	90fff0ef          	jal	ra,800413d4 <z_unpend_thread_no_timeout>
		if (z_is_thread_timeout_active(thread)) {
80041aca:	4c1c                	lw	a5,24(s0)
80041acc:	dff1                	beqz	a5,80041aa8 <z_thread_single_abort+0x18>
	return z_abort_timeout(&thread->base.timeout);
80041ace:	01840513          	addi	a0,s0,24
80041ad2:	2acd                	jal	80041cc4 <z_abort_timeout>
80041ad4:	bfd1                	j	80041aa8 <z_thread_single_abort+0x18>

80041ad6 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
80041ad6:	7179                	addi	sp,sp,-48
	_FOREACH_STATIC_THREAD(thread_data) {
80041ad8:	800427b7          	lui	a5,0x80042
{
80041adc:	d04a                	sw	s2,32(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
80041ade:	80042937          	lui	s2,0x80042
{
80041ae2:	d422                	sw	s0,40(sp)
80041ae4:	d226                	sw	s1,36(sp)
80041ae6:	d606                	sw	ra,44(sp)
80041ae8:	ce4e                	sw	s3,28(sp)
80041aea:	cc52                	sw	s4,24(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
80041aec:	53c78413          	addi	s0,a5,1340 # 8004253c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004253d>
80041af0:	53c78493          	addi	s1,a5,1340
80041af4:	56c90913          	addi	s2,s2,1388 # 8004256c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004256d>
80041af8:	03246463          	bltu	s0,s2,80041b20 <z_init_static_threads+0x4a>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
80041afc:	8426                	mv	s0,s1
	k_sched_lock();
80041afe:	941ff0ef          	jal	ra,8004143e <k_sched_lock>
		if (thread_data->init_delay != K_FOREVER) {
80041b02:	54fd                	li	s1,-1
80041b04:	49a9                	li	s3,10
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
80041b06:	80041a37          	lui	s4,0x80041
	_FOREACH_STATIC_THREAD(thread_data) {
80041b0a:	03246f63          	bltu	s0,s2,80041b48 <z_init_static_threads+0x72>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
80041b0e:	5422                	lw	s0,40(sp)
80041b10:	50b2                	lw	ra,44(sp)
80041b12:	5492                	lw	s1,36(sp)
80041b14:	5902                	lw	s2,32(sp)
80041b16:	49f2                	lw	s3,28(sp)
80041b18:	4a62                	lw	s4,24(sp)
80041b1a:	6145                	addi	sp,sp,48
	k_sched_unlock();
80041b1c:	9a1ff06f          	j	800414bc <k_sched_unlock>
		z_setup_new_thread(
80041b20:	545c                	lw	a5,44(s0)
80041b22:	c23e                	sw	a5,4(sp)
80041b24:	501c                	lw	a5,32(s0)
80041b26:	c03e                	sw	a5,0(sp)
80041b28:	485c                	lw	a5,20(s0)
80041b2a:	01c42883          	lw	a7,28(s0)
80041b2e:	01842803          	lw	a6,24(s0)
80041b32:	4818                	lw	a4,16(s0)
80041b34:	4454                	lw	a3,12(s0)
80041b36:	4410                	lw	a2,8(s0)
80041b38:	404c                	lw	a1,4(s0)
80041b3a:	4008                	lw	a0,0(s0)
80041b3c:	35ed                	jal	80041a26 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
80041b3e:	401c                	lw	a5,0(s0)
80041b40:	cfe0                	sw	s0,92(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
80041b42:	03040413          	addi	s0,s0,48
80041b46:	bf4d                	j	80041af8 <z_init_static_threads+0x22>
		if (thread_data->init_delay != K_FOREVER) {
80041b48:	5050                	lw	a2,36(s0)
80041b4a:	00960563          	beq	a2,s1,80041b54 <z_init_static_threads+0x7e>
			schedule_new_thread(thread_data->init_thread,
80041b4e:	4008                	lw	a0,0(s0)
	if (delay == 0) {
80041b50:	e609                	bnez	a2,80041b5a <z_init_static_threads+0x84>
80041b52:	3559                	jal	800419d8 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
80041b54:	03040413          	addi	s0,s0,48
80041b58:	bf4d                	j	80041b0a <z_init_static_threads+0x34>
80041b5a:	0625                	addi	a2,a2,9
80041b5c:	03364633          	div	a2,a2,s3
80041b60:	560a0593          	addi	a1,s4,1376 # 80041560 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80041561>
80041b64:	0561                	addi	a0,a0,24
80041b66:	0605                	addi	a2,a2,1
80041b68:	28c9                	jal	80041c3a <z_add_timeout>
80041b6a:	b7ed                	j	80041b54 <z_init_static_threads+0x7e>

80041b6c <z_init_thread_base>:
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
80041b6c:	00d50623          	sb	a3,12(a0)
	thread_base->thread_state = (u8_t)initial_state;
80041b70:	00c506a3          	sb	a2,13(a0)

	thread_base->prio = priority;
80041b74:	00b50723          	sb	a1,14(a0)

	thread_base->sched_locked = 0U;
80041b78:	000507a3          	sb	zero,15(a0)
	node->next = NULL;
80041b7c:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
80041b80:	00052e23          	sw	zero,28(a0)

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
80041b84:	8082                	ret

80041b86 <z_impl_k_thread_abort>:

extern void z_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
80041b86:	7179                	addi	sp,sp,-48
80041b88:	d606                	sw	ra,44(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041b8a:	45a1                	li	a1,8
80041b8c:	3005b5f3          	csrrc	a1,mstatus,a1
	key = (mstatus & SOC_MSTATUS_IEN);
80041b90:	89a1                	andi	a1,a1,8
80041b92:	c62e                	sw	a1,12(sp)
	k_spinlock_key_t key = k_spin_lock(&lock);

	__ASSERT((thread->base.user_options & K_ESSENTIAL) == 0U,
		 "essential thread aborted");

	z_thread_single_abort(thread);
80041b94:	3df5                	jal	80041a90 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	z_reschedule(&lock, key);
80041b96:	45b2                	lw	a1,12(sp)
80041b98:	0868                	addi	a0,sp,28
80041b9a:	86bff0ef          	jal	ra,80041404 <z_reschedule>
}
80041b9e:	50b2                	lw	ra,44(sp)
80041ba0:	6145                	addi	sp,sp,48
80041ba2:	8082                	ret

80041ba4 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
80041ba4:	800427b7          	lui	a5,0x80042
80041ba8:	5c47a783          	lw	a5,1476(a5) # 800425c4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425c5>
80041bac:	e399                	bnez	a5,80041bb2 <elapsed+0xe>
80041bae:	cccff06f          	j	8004107a <z_clock_elapsed>
}
80041bb2:	4501                	li	a0,0
80041bb4:	8082                	ret

80041bb6 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
80041bb6:	411c                	lw	a5,0(a0)
80041bb8:	cd01                	beqz	a0,80041bd0 <remove_timeout+0x1a>
80041bba:	80042737          	lui	a4,0x80042
	return (node == list->tail) ? NULL : node->next;
80041bbe:	4e872703          	lw	a4,1256(a4) # 800424e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424e9>
80041bc2:	00e50763          	beq	a0,a4,80041bd0 <remove_timeout+0x1a>
	if (next(t) != NULL) {
80041bc6:	c789                	beqz	a5,80041bd0 <remove_timeout+0x1a>
		next(t)->dticks += t->dticks;
80041bc8:	4798                	lw	a4,8(a5)
80041bca:	4514                	lw	a3,8(a0)
80041bcc:	9736                	add	a4,a4,a3
80041bce:	c798                	sw	a4,8(a5)
	node->prev->next = node->next;
80041bd0:	4158                	lw	a4,4(a0)
80041bd2:	c31c                	sw	a5,0(a4)
	node->next->prev = node->prev;
80041bd4:	c3d8                	sw	a4,4(a5)
	node->next = NULL;
80041bd6:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
80041bda:	00052223          	sw	zero,4(a0)
}
80041bde:	8082                	ret

80041be0 <next_timeout>:

static s32_t next_timeout(void)
{
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
80041be0:	800427b7          	lui	a5,0x80042
80041be4:	5c87c783          	lbu	a5,1480(a5) # 800425c8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425c9>
{
80041be8:	1141                	addi	sp,sp,-16
80041bea:	c606                	sw	ra,12(sp)
80041bec:	c422                	sw	s0,8(sp)
80041bee:	c226                	sw	s1,4(sp)
80041bf0:	557d                	li	a0,-1
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
80041bf2:	e789                	bnez	a5,80041bfc <next_timeout+0x1c>
80041bf4:	80000537          	lui	a0,0x80000
80041bf8:	fff54513          	not	a0,a0
	return list->head == list;
80041bfc:	800427b7          	lui	a5,0x80042
80041c00:	4e478793          	addi	a5,a5,1252 # 800424e4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424e5>
80041c04:	4380                	lw	s0,0(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80041c06:	00f40d63          	beq	s0,a5,80041c20 <next_timeout+0x40>
	struct _timeout *to = first();
	s32_t ret = to == NULL ? maxw : MAX(0, to->dticks - elapsed());
80041c0a:	c819                	beqz	s0,80041c20 <next_timeout+0x40>
80041c0c:	4404                	lw	s1,8(s0)
80041c0e:	3f59                	jal	80041ba4 <elapsed>
80041c10:	8c89                	sub	s1,s1,a0
80041c12:	4501                	li	a0,0
80041c14:	0004c663          	bltz	s1,80041c20 <next_timeout+0x40>
80041c18:	4400                	lw	s0,8(s0)
80041c1a:	3769                	jal	80041ba4 <elapsed>
80041c1c:	40a40533          	sub	a0,s0,a0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
80041c20:	800427b7          	lui	a5,0x80042
80041c24:	79c7a783          	lw	a5,1948(a5) # 8004279c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004279d>
80041c28:	c781                	beqz	a5,80041c30 <next_timeout+0x50>
80041c2a:	00a7d363          	bge	a5,a0,80041c30 <next_timeout+0x50>
80041c2e:	853e                	mv	a0,a5
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
80041c30:	40b2                	lw	ra,12(sp)
80041c32:	4422                	lw	s0,8(sp)
80041c34:	4492                	lw	s1,4(sp)
80041c36:	0141                	addi	sp,sp,16
80041c38:	8082                	ret

80041c3a <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
80041c3a:	1101                	addi	sp,sp,-32
80041c3c:	cc22                	sw	s0,24(sp)
80041c3e:	ca26                	sw	s1,20(sp)
80041c40:	ce06                	sw	ra,28(sp)
80041c42:	842a                	mv	s0,a0
80041c44:	c632                	sw	a2,12(sp)
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
80041c46:	c54c                	sw	a1,12(a0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041c48:	44a1                	li	s1,8
80041c4a:	3004b4f3          	csrrc	s1,mstatus,s1
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
80041c4e:	3f99                	jal	80041ba4 <elapsed>
	ticks = MAX(1, ticks);
80041c50:	4632                	lw	a2,12(sp)
	key = (mstatus & SOC_MSTATUS_IEN);
80041c52:	88a1                	andi	s1,s1,8
80041c54:	00c04363          	bgtz	a2,80041c5a <z_add_timeout+0x20>
80041c58:	4605                	li	a2,1
	return list->head == list;
80041c5a:	800427b7          	lui	a5,0x80042
80041c5e:	4e47a703          	lw	a4,1252(a5) # 800424e4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424e5>
		to->dticks = ticks + elapsed();
80041c62:	962a                	add	a2,a2,a0
80041c64:	c410                	sw	a2,8(s0)
80041c66:	4e478793          	addi	a5,a5,1252
	return sys_dlist_is_empty(list) ? NULL : list->head;
80041c6a:	00f70463          	beq	a4,a5,80041c72 <z_add_timeout+0x38>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
80041c6e:	43cc                	lw	a1,4(a5)
		for (t = first(); t != NULL; t = next(t)) {
80041c70:	eb01                	bnez	a4,80041c80 <z_add_timeout+0x46>
	node->prev = list->tail;
80041c72:	43d8                	lw	a4,4(a5)
	node->next = list;
80041c74:	c01c                	sw	a5,0(s0)
	node->prev = list->tail;
80041c76:	c058                	sw	a4,4(s0)
	list->tail->next = node;
80041c78:	43d8                	lw	a4,4(a5)
80041c7a:	c300                	sw	s0,0(a4)
	list->tail = node;
80041c7c:	c3c0                	sw	s0,4(a5)
80041c7e:	a829                	j	80041c98 <z_add_timeout+0x5e>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
80041c80:	4710                	lw	a2,8(a4)
80041c82:	4414                	lw	a3,8(s0)
80041c84:	02c6da63          	bge	a3,a2,80041cb8 <z_add_timeout+0x7e>
				t->dticks -= to->dticks;
80041c88:	40d606b3          	sub	a3,a2,a3
80041c8c:	c714                	sw	a3,8(a4)
	node->prev = successor->prev;
80041c8e:	4354                	lw	a3,4(a4)
	node->next = successor;
80041c90:	c018                	sw	a4,0(s0)
	node->prev = successor->prev;
80041c92:	c054                	sw	a3,4(s0)
	successor->prev->next = node;
80041c94:	c280                	sw	s0,0(a3)
	successor->prev = node;
80041c96:	c340                	sw	s0,4(a4)
	return list->head == list;
80041c98:	4398                	lw	a4,0(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80041c9a:	00f70863          	beq	a4,a5,80041caa <z_add_timeout+0x70>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
80041c9e:	00e41663          	bne	s0,a4,80041caa <z_add_timeout+0x70>
			z_clock_set_timeout(next_timeout(), false);
80041ca2:	3f3d                	jal	80041be0 <next_timeout>
80041ca4:	4581                	li	a1,0
80041ca6:	b38ff0ef          	jal	ra,80040fde <z_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041caa:	3004a4f3          	csrrs	s1,mstatus,s1
		}
	}
}
80041cae:	40f2                	lw	ra,28(sp)
80041cb0:	4462                	lw	s0,24(sp)
80041cb2:	44d2                	lw	s1,20(sp)
80041cb4:	6105                	addi	sp,sp,32
80041cb6:	8082                	ret
			to->dticks -= t->dticks;
80041cb8:	8e91                	sub	a3,a3,a2
80041cba:	c414                	sw	a3,8(s0)
	return (node == list->tail) ? NULL : node->next;
80041cbc:	fab70be3          	beq	a4,a1,80041c72 <z_add_timeout+0x38>
80041cc0:	4318                	lw	a4,0(a4)
80041cc2:	b77d                	j	80041c70 <z_add_timeout+0x36>

80041cc4 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
80041cc4:	1141                	addi	sp,sp,-16
80041cc6:	c422                	sw	s0,8(sp)
80041cc8:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041cca:	4421                	li	s0,8
80041ccc:	30043473          	csrrc	s0,mstatus,s0
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
80041cd0:	411c                	lw	a5,0(a0)
	key = (mstatus & SOC_MSTATUS_IEN);
80041cd2:	8821                	andi	s0,s0,8
80041cd4:	cb89                	beqz	a5,80041ce6 <z_abort_timeout+0x22>
			remove_timeout(to);
80041cd6:	35c5                	jal	80041bb6 <remove_timeout>
			ret = 0;
80041cd8:	4501                	li	a0,0
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041cda:	30042473          	csrrs	s0,mstatus,s0
		}
	}

	return ret;
}
80041cde:	40b2                	lw	ra,12(sp)
80041ce0:	4422                	lw	s0,8(sp)
80041ce2:	0141                	addi	sp,sp,16
80041ce4:	8082                	ret
	int ret = -EINVAL;
80041ce6:	5529                	li	a0,-22
80041ce8:	bfcd                	j	80041cda <z_abort_timeout+0x16>

80041cea <z_get_next_timeout_expiry>:

	return ticks - elapsed();
}

s32_t z_get_next_timeout_expiry(void)
{
80041cea:	1141                	addi	sp,sp,-16
80041cec:	c606                	sw	ra,12(sp)
80041cee:	c422                	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041cf0:	47a1                	li	a5,8
80041cf2:	3007b473          	csrrc	s0,mstatus,a5
	s32_t ret = K_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
80041cf6:	35ed                	jal	80041be0 <next_timeout>
	key = (mstatus & SOC_MSTATUS_IEN);
80041cf8:	00847793          	andi	a5,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041cfc:	3007a7f3          	csrrs	a5,mstatus,a5
	}
	return ret;
}
80041d00:	40b2                	lw	ra,12(sp)
80041d02:	4422                	lw	s0,8(sp)
80041d04:	0141                	addi	sp,sp,16
80041d06:	8082                	ret

80041d08 <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
80041d08:	1101                	addi	sp,sp,-32
80041d0a:	cc22                	sw	s0,24(sp)
80041d0c:	ca26                	sw	s1,20(sp)
80041d0e:	ce06                	sw	ra,28(sp)
80041d10:	84aa                	mv	s1,a0
80041d12:	c62e                	sw	a1,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041d14:	4421                	li	s0,8
80041d16:	30043473          	csrrc	s0,mstatus,s0
	LOCKED(&timeout_lock) {
		int next = next_timeout();
80041d1a:	35d9                	jal	80041be0 <next_timeout>
	key = (mstatus & SOC_MSTATUS_IEN);
80041d1c:	8821                	andi	s0,s0,8
		 * what we have.  Also don't try to set a timeout when
		 * one is about to expire: drivers have internal logic
		 * that will bump the timeout to the "next" tick if
		 * it's not considered to be settable as directed.
		 */
		if (sooner && !imminent) {
80041d1e:	45b2                	lw	a1,12(sp)
80041d20:	00a4d863          	bge	s1,a0,80041d30 <z_set_timeout_expiry+0x28>
80041d24:	4785                	li	a5,1
80041d26:	00a7d563          	bge	a5,a0,80041d30 <z_set_timeout_expiry+0x28>
			z_clock_set_timeout(ticks, idle);
80041d2a:	8526                	mv	a0,s1
80041d2c:	ab2ff0ef          	jal	ra,80040fde <z_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041d30:	30042473          	csrrs	s0,mstatus,s0
		}
	}
}
80041d34:	40f2                	lw	ra,28(sp)
80041d36:	4462                	lw	s0,24(sp)
80041d38:	44d2                	lw	s1,20(sp)
80041d3a:	6105                	addi	sp,sp,32
80041d3c:	8082                	ret

80041d3e <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
80041d3e:	1101                	addi	sp,sp,-32
80041d40:	cc22                	sw	s0,24(sp)
80041d42:	ca26                	sw	s1,20(sp)
80041d44:	ce06                	sw	ra,28(sp)
80041d46:	c84a                	sw	s2,16(sp)
80041d48:	c64e                	sw	s3,12(sp)
80041d4a:	c452                	sw	s4,8(sp)
80041d4c:	c256                	sw	s5,4(sp)
80041d4e:	84aa                	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041d50:	4421                	li	s0,8
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
80041d52:	8efff0ef          	jal	ra,80041640 <z_time_slice>
80041d56:	30043473          	csrrc	s0,mstatus,s0
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
80041d5a:	800429b7          	lui	s3,0x80042
	return list->head == list;
80041d5e:	80042a37          	lui	s4,0x80042
80041d62:	80042937          	lui	s2,0x80042
80041d66:	5c99a223          	sw	s1,1476(s3) # 800425c4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425c5>
	key = (mstatus & SOC_MSTATUS_IEN);
80041d6a:	8821                	andi	s0,s0,8

	while (first() != NULL && first()->dticks <= announce_remaining) {
80041d6c:	5c498993          	addi	s3,s3,1476
80041d70:	4e4a0a13          	addi	s4,s4,1252 # 800424e4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800424e5>
80041d74:	5a890913          	addi	s2,s2,1448 # 800425a8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425a9>
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041d78:	4aa1                	li	s5,8
80041d7a:	000a2483          	lw	s1,0(s4)
80041d7e:	0009a783          	lw	a5,0(s3)
80041d82:	00092683          	lw	a3,0(s2)
80041d86:	00492503          	lw	a0,4(s2)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80041d8a:	01448863          	beq	s1,s4,80041d9a <z_clock_announce+0x5c>
80041d8e:	c491                	beqz	s1,80041d9a <z_clock_announce+0x5c>
80041d90:	4498                	lw	a4,8(s1)
80041d92:	04e7d063          	bge	a5,a4,80041dd2 <z_clock_announce+0x94>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
80041d96:	8f1d                	sub	a4,a4,a5
80041d98:	c498                	sw	a4,8(s1)
	}

	curr_tick += announce_remaining;
80041d9a:	96be                	add	a3,a3,a5
80041d9c:	41f7d713          	srai	a4,a5,0x1f
80041da0:	972a                	add	a4,a4,a0
80041da2:	00f6b7b3          	sltu	a5,a3,a5
80041da6:	97ba                	add	a5,a5,a4
80041da8:	00d92023          	sw	a3,0(s2)
80041dac:	00f92223          	sw	a5,4(s2)
	announce_remaining = 0;
80041db0:	0009a023          	sw	zero,0(s3)

	z_clock_set_timeout(next_timeout(), false);
80041db4:	3535                	jal	80041be0 <next_timeout>
80041db6:	4581                	li	a1,0
80041db8:	a26ff0ef          	jal	ra,80040fde <z_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041dbc:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
80041dc0:	40f2                	lw	ra,28(sp)
80041dc2:	4462                	lw	s0,24(sp)
80041dc4:	44d2                	lw	s1,20(sp)
80041dc6:	4942                	lw	s2,16(sp)
80041dc8:	49b2                	lw	s3,12(sp)
80041dca:	4a22                	lw	s4,8(sp)
80041dcc:	4a92                	lw	s5,4(sp)
80041dce:	6105                	addi	sp,sp,32
80041dd0:	8082                	ret
		curr_tick += dt;
80041dd2:	96ba                	add	a3,a3,a4
80041dd4:	41f75593          	srai	a1,a4,0x1f
80041dd8:	95aa                	add	a1,a1,a0
80041dda:	00e6b633          	sltu	a2,a3,a4
80041dde:	962e                	add	a2,a2,a1
		announce_remaining -= dt;
80041de0:	8f99                	sub	a5,a5,a4
		t->dticks = 0;
80041de2:	0004a423          	sw	zero,8(s1)
		remove_timeout(t);
80041de6:	8526                	mv	a0,s1
		curr_tick += dt;
80041de8:	00d92023          	sw	a3,0(s2)
80041dec:	00c92223          	sw	a2,4(s2)
		announce_remaining -= dt;
80041df0:	00f9a023          	sw	a5,0(s3)
		remove_timeout(t);
80041df4:	33c9                	jal	80041bb6 <remove_timeout>
80041df6:	30042473          	csrrs	s0,mstatus,s0
		t->fn(t);
80041dfa:	44dc                	lw	a5,12(s1)
80041dfc:	8526                	mv	a0,s1
80041dfe:	9782                	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041e00:	300ab473          	csrrc	s0,mstatus,s5
	key = (mstatus & SOC_MSTATUS_IEN);
80041e04:	8821                	andi	s0,s0,8
80041e06:	bf95                	j	80041d7a <z_clock_announce+0x3c>

80041e08 <z_tick_get>:
{
	can_wait_forever = 1;
}

s64_t z_tick_get(void)
{
80041e08:	1141                	addi	sp,sp,-16
80041e0a:	c422                	sw	s0,8(sp)
80041e0c:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041e0e:	4421                	li	s0,8
80041e10:	30043473          	csrrc	s0,mstatus,s0
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
80041e14:	a66ff0ef          	jal	ra,8004107a <z_clock_elapsed>
80041e18:	80042737          	lui	a4,0x80042
80041e1c:	5a870713          	addi	a4,a4,1448 # 800425a8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800425a9>
80041e20:	87aa                	mv	a5,a0
80041e22:	4308                	lw	a0,0(a4)
80041e24:	434c                	lw	a1,4(a4)
	key = (mstatus & SOC_MSTATUS_IEN);
80041e26:	8821                	andi	s0,s0,8
80041e28:	953e                	add	a0,a0,a5
80041e2a:	00f537b3          	sltu	a5,a0,a5
80041e2e:	95be                	add	a1,a1,a5
	__asm__ volatile ("csrrs %0, mstatus, %1"
80041e30:	30042473          	csrrs	s0,mstatus,s0
	}
	return t;
}
80041e34:	40b2                	lw	ra,12(sp)
80041e36:	4422                	lw	s0,8(sp)
80041e38:	0141                	addi	sp,sp,16
80041e3a:	8082                	ret

80041e3c <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
80041e3c:	1141                	addi	sp,sp,-16
80041e3e:	c606                	sw	ra,12(sp)
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
80041e40:	37e1                	jal	80041e08 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
80041e42:	40b2                	lw	ra,12(sp)
80041e44:	0141                	addi	sp,sp,16
80041e46:	8082                	ret

80041e48 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
80041e48:	1141                	addi	sp,sp,-16
80041e4a:	c422                	sw	s0,8(sp)
80041e4c:	c226                	sw	s1,4(sp)
80041e4e:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80041e50:	4421                	li	s0,8
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
80041e52:	4489                	li	s1,2
80041e54:	300437f3          	csrrc	a5,mstatus,s0
	s32_t ticks = z_get_next_timeout_expiry();
80041e58:	3d49                	jal	80041cea <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
80041e5a:	00a4c363          	blt	s1,a0,80041e60 <idle+0x18>
80041e5e:	4505                	li	a0,1
80041e60:	4585                	li	a1,1
80041e62:	355d                	jal	80041d08 <z_set_timeout_expiry>
	k_cpu_idle();
80041e64:	832ff0ef          	jal	ra,80040e96 <k_cpu_idle>
80041e68:	b7f5                	j	80041e54 <idle+0xc>

80041e6a <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
80041e6a:	1141                	addi	sp,sp,-16
80041e6c:	c422                	sw	s0,8(sp)
80041e6e:	c226                	sw	s1,4(sp)
	ARG_UNUSED(unused);
	struct k_mem_pool *p;

	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
80041e70:	80042437          	lui	s0,0x80042
80041e74:	800424b7          	lui	s1,0x80042
{
80041e78:	c606                	sw	ra,12(sp)
	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
80041e7a:	56c40413          	addi	s0,s0,1388 # 8004256c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004256d>
80041e7e:	56c48493          	addi	s1,s1,1388 # 8004256c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004256d>
80041e82:	00946863          	bltu	s0,s1,80041e92 <init_static_pools+0x28>
		k_mem_pool_init(p);
	}

	return 0;
}
80041e86:	40b2                	lw	ra,12(sp)
80041e88:	4422                	lw	s0,8(sp)
80041e8a:	4492                	lw	s1,4(sp)
80041e8c:	4501                	li	a0,0
80041e8e:	0141                	addi	sp,sp,16
80041e90:	8082                	ret
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
80041e92:	01440793          	addi	a5,s0,20
	z_sys_mem_pool_base_init(&p->base);
80041e96:	8522                	mv	a0,s0
	list->head = (sys_dnode_t *)list;
80041e98:	c85c                	sw	a5,20(s0)
	list->tail = (sys_dnode_t *)list;
80041e9a:	cc1c                	sw	a5,24(s0)
80041e9c:	afdfe0ef          	jal	ra,80040998 <z_sys_mem_pool_base_init>
	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
80041ea0:	0471                	addi	s0,s0,28
80041ea2:	b7c5                	j	80041e82 <init_static_pools+0x18>

80041ea4 <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
80041ea4:	8082                	ret
